#+TITTLE: GNU Emacs Lisp 编程入门  
  
* 第 1 章 列表处理  
Lisp Lots of Isolated Silly Parentheses
LISt Processing
** 1.1 Lisp 列表  
Lisp 中，一个列表看起来像这个样子：'(rose violet daisy buttercup)。
'(rose  
 violet  
 daisy  
 buttercup)  
  
'(this list has (a list inside of it))  
*** 1.1.1 Lisp atom
空列表同时看作既是一个原子，也是一个列表。  
symbolic expression 或者更简洁地被称作 *s-表达式(s-expression)* 。
简单理解：
4 是一个数，如果写成 2+2 的形式就是表达式，4 这个数在 lisp 中称为原子，
如果是以在计算机的内部编码来表 100 也中表达示
一个小表格的二元形式也可以称为表达示，九九表也可称。
表格（form）
代表“South American sloth”的单词“ai”与“a”和“i”这两个字母是完全不同的。  
 foo”和“forward-line"  
'(this list includes "text between quotation marks.")  
 *串（string)* 
*** 1.1.2 列表中的空格  
'(this list looks like this)  
*** 1.1.3 GNU Emacs 帮助你输入列表  
  
如果你在 GNU Emacs 中使用 Lisp 交互模式或是 Emacs Lisp 模式来输入一个 Lisp 表达  
式，那么你将可以使用多种命令来使 Lisp 表达式排成易于阅读的格式。例如，按  
TAB 键会使光标所在的行自动缩排到适当的位置。用于在一个区域内正确缩排的常  
用命令是 M-C-\。设计缩排，是为了使读者看清列表的哪些元素是属于哪个列表  
的——缩排时子列表的元素要比外围列表的元素更缩进一些。  
  
另外，当输入一个右括号时，Emacs 立即使光标跳到与之配对的左括号处，因此就  
可以看清它到底是哪一个列表。这个功能非常有用，因为 Lisp 中输入的每一个列  
表必须有一对匹配的左括号和右括号（有关 Emacs 模式的详细情况可以参见《GNU  
Emacs 技术手册》中“主要模式”一节）。  
  
** 1.2 运行一个程序  
 quote 
(+ 2 2)  
** 1.3 产生错误消息  
(this is an unquoted list)  
不加引号会求值  
Symbol's function definition is void:this  
符号              定义      
 注：在 Emacs 22 及更高的版本里，你会进入一个 *Backtrace* 缓冲区
** 1.4 符号名和函数定义  
Plus "+"。Robert Bob
 Texinfo “texinfo-”“rmail-”  
  
** 1.5 Lisp 解释器  
只要这个符号前没有引号也没有括号包围它。
特殊表（special form）就是如果没引号就对第一个求值，当第一个是特殊
表时，就会对第个求值
字节编译（byte compiled）
如 byte-compile-file
** 1.6 求值  
算表达式的值。在前面我已经数次使用了这个术语。这个词来自于日常用语之  
中，根据《Webster's New Collegiate Dictionary》的解释，它意指“确定值或  
数量，或者是“评价”。  
*附带效果（side effect）* 。
总之，对一个符号表达式求值几乎总是使 Lisp 解释器返回一个值，同时可能产生  
一个附带效果，不然，就产生一个错误消息。  
*对一个内部列表求值*   
eval-last-sexp。其中“sexp”是“symbol expression"
“eval”是“evaluation”
** 1.7 变量  
 （variable）。  
 “Cambridge”一词，既可以指那个在麻省的 Cambridge 市，也可以指其他赋予这  
个名字的信息，比如：“伟大的编程中心”。  
bind  

fill-column 没有函数定义。试一试对下面的表达式求值：  

(fill-column)  
  
Symbol's function definition is void:fill-column  
  
Symbol's value as variable is void:+  
  
** 1.8 argument
*** 1.8.1 参量的数据类型  
(concat "abc" "def")  
substring
(substring "The quick brown fox jumped." 16 19)  
*** 1.8.2 当参量是符号或列表的情形  
(+ 2 fill-column)  
(concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")  
需要 number-to-string 函数进行类型转换。
如果不用类型转换，提示出错为
 Debugger entered--Lisp error: (wrong-type-argument sequencep 82) 
*** 1.8.3 数目可变的参量  
*** 1.8.4 用一个错误类型的数据对象作为参量  
(+ 2 'hello)   
Wrong type argument:integer-or-marker-p, hello  
  C-@ 或者 C-<SPC> 命令设置标记时，这个位置就被记录为一个标记。
“Predicate”
谓词是指一个决定某些属性是否为真的函数。因此，“p”告诉我们  
integer-or-marker-p 也是个函数名，
这个函数是测度这个参量是一个整数或者是一个标记时是否为真。其他以“p”结尾的 
Lisp 符号应该都是测试类的函数，包括 zerop（这个函数测试  
参量值是否为零）和 listp（这个函数测试参量是否是一个列表）。  
*** 1.8.5 message 函效  
(message "This message appears in the echo area!")  
在使用 message 函数的绝大多数情况中，在回显区中打印消息只是一个附带作用，  
而打印出来的消息则是没有引号的。示例请参见 3.3.1 节，“交互的  
multiply-by-seven 函数”。  
  
在我的系统中，当对这个列表求值时，"The value of fill-column is 72."出现  
在我的回显区中。  
  
如果在带引号的字符串中有多于一个的“%s"，字符串后的第一个参量的值输出到  
第一个"%s”的位置，字符串后的第二个参量的值输出到第二个“%s”的位置，以  
此类推。例如，如果对下面的列表求值：  
  
(message "There are %d %s in the office!"  
         (- fill-column 14) "pink elephants")  
  
** 1.9 给一个变量赋值  
  
*** 1.9.1 使用 set 函数  
(set 'flowers '(rose violet daisy buttercup))  
flowers  
当对 flowers 求值时，列表(rose violet daisy buttercup)显示在回显区中。  
'flowers  
symbol's value as variable is  
*** 1.9.2 使用 setq 函数  
(setq carnivores '(lion tiger leopard)a)  
 setq 中的“q”就是指引用 quote）
(setq trees '(pine fir oak maple)  
      herbivores ' (gazelle antelope zebra))  
*** 1.9.3 计数  
(setq counter 0)               ;Let's call this the initializer.  
  
(setq counter (+ counter 1))   ;This is the incrementer.  
  
counter                        ;This is the counter.  
** 1.10 小结  
forward-paragraph
** 1.11 练习  
* 第 2 章 求值实践  
self-insert-command
** 2.1 缓冲区名  
Info
(buffer-name)  
buffer-name  
 Debugger entered--Lisp error: (void-variable buffer-name)
(buffer-file-name)  
"introduction.texinfo"是对(buffer-name)求值所返回的值，而  
"/gnu/work/intro/introduction.texinfo"是对(buffer-file-name)求值所返回  
的值。前者是缓冲区的名字，而后者是文件的名字。（在表达式中，括号告诉  
Lisp 解释器将 buffer-name 和 buffer-file-name 当做函数处理；如果没有括号，则  
解释器将它们当做变量来对这些符号求值。参见 1.7 节，“变量”。）  

nil 一词来自于拉丁语，意指“什么都没有”（空）。
 C-u C-x C-e 而不是键入 C-x C-e。这将  
** 2.2 获得缓冲区  
buffer-name
current-bufter
George 
scratch
<buffer *info*>。  
(other-buffer)  
<buffer *scratch*>
** 2.3 buffer
other-buffer  switch-to-buffer
 (buffer-name)
forward-char
forward-sentence
switch-to-buffer
(switch-to-buffer (other-buffer))  
set-buffer
** 2.4 buffer size
buffer-size
point、point-min and point-max
(point)  
(narrowing)
* 第 3 章 如何编写函数定义  
** 3.1 defun 特殊表  
mark-whole-buffer
defun 是“define function”
defun
1) function-name
  
2) arguments
  
3) optional-documentation
  
4) (interactive argument-passing-info); optional  
  
5) body
  
(defun function-name (arguments...)  
  "optional-documentation..."  
   (interactive argument-passing-info); optional  
  body...)  
  
  (defun multiply-by-seven (number)  
   "Multiply NUMBER by seven."  
     (* 7 number))  
multiplicand 
Shorty
apropos
(describe-function)
  
(multiply-by-seven 3)  
** 3.2 安装函数定义  
multiply-by-seven
(multiply-by-seven 3)
C-h f (describe-function)
** 3.3 使函数成为交互函数  
interactive
next-line 
C-x h 可以激活 mark-whole-buffer 函数。  
(defun multiply-by-seven  (number) ;Interactive version.  
  "Multiply NUMBER by seven."  
   (interactive "p")  
   (message "The result is %d" (* 7 number)))  
  
1) 键入一个包含了传送给函数的数字的前缀参量和 M-x 以及函数名，如下所  
   示：C-u 3 M-x forward-sentence；或者  
  
2) 键入函数绑定键或者键序列，如下所示：C-u 3 M-e。  
  
 【在我的 Emacs 23.2 版本里，也可以通过键入 Ctrl 键和后接一个数字（如 C-3）来输  
入一个前缀参量。详情可通过键入 C-h f digit-argument 获得。——Chiron 注】  
(defun multiply-by-seven (number) ;Interactive version.  
  "Multiply NUMBER by seven."  
   (interactive "p")  
   (message "The result is %d" (* 7 number)))  
  
在这个函数中，表达式(interactive "p")是由两个元素组成的一个列表。其中的  
"p"告诉 Emacs 要传送一个前缀参量给这个函数，并将它的值用于函数的参量。  
  
这个参量将是一个数。这意味着符号 number 将在这行绑定到一个数字上：  
  
(message "The result is %d" (* 7 number)))  
  
例如，如果前缀参量是 5，则 Lisp 解释器对这一行求值时就好像是对以下行  
  
(message "The result is %d" (* 7 5))  
  
 （注意，当你调用函数 multiply-by-seven 时，回显区的消息是不带引号的。但  
是，当你调用 message 函数时，打印出来的文本是带引号的。这是因为由 message  
函数返回的值将显示在回显区，而将其嵌入到一个函数中时，message 打印出来的  
文本是作为一个附带效果出现的，因此不带引号。）  
  
** 3.4 interactive 函数的不同选项  
  
例如，字符“r”使 Emacs 将位点所在区域的开始值和结束值作为函数的两个参量。  
用法如下：  

(interactive "r")  
  
在另一方面，"B"告诉 Emacs 用缓冲区的名字作为函数的参量。在这种情况下，  
Emacs 会在小缓冲区提示用户输入缓冲区的名字，并使用跟在“B”后面的字符串  
表示这种要求（如"BAppend to buffer:"）。Emacs 不仅提示输入函数名，而且如  
果用户给出了足够的信息并按下 TAB 键，Emacs 会自动补齐函数名。  
  
对于有两个或者更多参量的函数，对其参量可以各有各的值，在 interactive 中相  
应地增加一些内容就行了。当你这样做时，这些信息以其在 interactive 中定义的  
顺序被传送给每一个参量。在字符串中，两个部分之间用“\n”分隔开，这代表  
一个新的行。例如，你可以在“BAppend to buffer:”后面加上一个“\n”和一  
个“r”。这将使 Emacs 将位点和标记的值传送给函数并提示你输入缓冲区名字——  
一共是三个参量。  

  
在这个例子中，函数定义看起来就像下面的例子一样，其中 buffer、start 和 end  
是 interactive 绑定的当前缓冲区以及当前区域的起始值和结束值的符号:  
  
  (defun name-of-function (buffer start end)  
    "documentation... "  
     (interactive "BAppend to buffer: \nr")  
     (body-of-function...)  
  
interactive mark-whole-burfer
** 3.5 永久地安装代码  
  
 - .emacs
 - load
 - site-init.el 使得所有使用你的计算机的用户都可以使用这些函数。
** 3.6 let 函数  
let 特殊表（local variable）  
*** 3.6.1 let 表达式的各个部分  
  (let ((variable value)  
        (varibale value)  
       ...)  
      body...)  
  
*** 3.6.2 let 表达式例子  
  
(let ((zebra 'stripes)  
       (tiger 'fierce))  
      (message "One kind of animal has %s and another is %s."   
              zebra tiger))  
  
在这个例子中，变量列表是：((zebra 'stripes) (tiger 'fierce))。  
  
"One kind of animal has stripes and another is fierce."  
*** 3.6.3 let 语句中的未初始化变量  
(let ((birch 3)  
       pine  
       fir  
       (oak 'some))  
      (message   
       "Here are %d variables with %s, %s, and %s value."  
        birch pine fir oak))  
  
"Here are 3 variables with nil,nil, and some valu."  
  
** 3.7 if 特殊表  
beginning-of-buffer
then
(if true-or-false-test  
    action-to-carry-out-if-test-is-true)  
  
(if (> 5 4)                           ;if-part   
     (message "5 is greater than 4!"))  ;then-part   
  
(defun type-of-animal (characteristic)  
  "Print message in echo area depending on CHARACTERISTIC.  
   If the CHARACTERISTIC is the symbol `fierce',  
   then warn of a tiger."  
    (if (equal characteristic 'fierce)  
        (message "It's a tiger!")))  

(type-of-animal 'fierce)  
  
(type-of-animal 'zebra)  
  
*** type-of-animal 函数详解*   
  
如前所述，非交互的函数定义模板如下所示：  
  
(defun name-of-funtion (argument-list)  
  "documentation..."  
   body...)  
  
type-of-animal 函数中与此模板类似的部分如下所示：  
  
(defun type-of-animal (characteristic)  
  "Print message in echo area depending on CHARACTERISTIC.  
   If the CHARACTERISTIC is the symbol `fierce',  
   then warn of a tiger."  
   body: the if expression)  
  
  
if 表达式模板如下所示：   
  
(if true-or-false-test  
    action-to-carry-out-if-the-test-returns-true)  
  
在 type-of-animal 函数中，if 表达式的实际代码如下所示：  
  
    (if (equal characteristic 'fierce)  
        (message "It's a tiger!")))  
  
  
(equal characteristic 'fierce)  
** 3.8 if-then-else 表达式  
  
Lisp 中，else 部经常在一个新行中书写，并且缩进得比 then 部少：  
  
  (if true-or-false-test  
      action-to-carry-out-if-the-test-returns-true  
    action-to-carry-out-if-the-test-returns-false)  
  
(if (> 4 5)                               ;if-part  
       (message "5 is greater than 4!")    ;then-part  
     (message "4 is not greater than 5!")) ;else-part  
  
  
如果对下面的这个版本的 type-of-animal 函数定义求值以安装它，然后对后续的  
两个表达式求值以传送不同的参量给函数，这样你就可以看到 else 部的作用了。  
  
(defun type-of-animal (characteristic)  ; Second version.  
       "Print message in echo area depending on CHARACTERISTIC.  
     If the CHARACTERISTIC is the symbol `fierce',  
     then warn of a tiger;  
     else say it's not fierce."  
        (if (equal characteristic 'fierce)  
            (message "It's a tiger!")  
          (message "It's not fierce!")))  
  
      (type-of-animal 'fierce)  
  
      (type-of-animal 'zebra)  
** 3.9 Lisp 中的真与假  
"hell"）、一个符号（除 nil 外，如 flowers）、一个列表、甚至一个缓冲区时，  
则测试结果为“真”。  
在 Lisp 中，nil 这个符号有两种意思[fn:5]。第一，它表示一个空列表。第二，它  
表示“假”,并是真假测试为“假”时的返回值。可以将 nil 写作一个空列表()或  
nil。只要是关于 Lisp 解释器，()和 nil 都是相同的。但是人类却倾向于用 nil 代表  
 “假”，用()代表空列表。  
  
(if 4   
    'true  
    'false)   
  
(if nil   
    'true   
    'false)  
  
(> 5 4)  
  
另一方面，如果测试为“假”，函数将返回 nil。  
  
(> 4 5)  
  
** 3.10 save-excursion
在 Emacs Lisp 中，位点是一个整数。缓冲区的第一个字符对应数字 1，第二个字符  
对应数字 2，以此类推。point 函数返回光标的当前位置，其值是一个数。每一个  
缓冲区都有它自己的位点。  
标记（mark）是缓冲区中的另外一个位置。它的值可以用一个命令（如 C-<SPC>  
或 C-@ 或  (set-mark-command)）来设置。如果设置了一个标记，可以用命令  
C-x C-x (exchange-point-and-mark)使光标从位点跳到标记处，并将光标当初所  
处的位置设置成一个标记。另外，如果设置了另外一个标记，原来标记的位置就  
被保存在标记环中，用这种方法可以保存许多标记位置。可以一次或者多次键入  
C-u C-<SPC>命令来使光标跳到被保存的标记处。  

位点和标记之间的缓冲区被称作现域（region），或简称域或区域。许多命令是  
对域操作的，这些命令包括：center-region、count-lines-region、  
kill-region 和 print-region。  
  
save-excursion 特殊表用于 append-to-buffer 函数的  
*save-excursion 表达式模板*  
(save-excursion  
   body...)  
  
(save-excursion  
    first-expression-in-body  
    second-expression-in-body  
    third-expression-in-body  
    ...  
    last-expression-in-body)  

在 Emacs Lisp 代码中，一个 save-excursion 表达式经常出现在一个 let 表达式主体  
中。它看起来就像这样：  
(let  varlist  
   (save-excursion  
    body...))  
** 3.11 回顾  
- eval-last-sexp  
- defun  
   (defun back-to-indentation ()  
    "Point to first visible character on line."  
     (interactive)  
     (beginning-of-line 1)   
     (skip-chars-forward " \t"))  
  
- interactive  
  b    一个已经存在的缓冲区的名字。  
  f    一个已经存在的文件的名字。  
  p    数字前缀参量。（注意，这个字符是小写"p"。）  
  r    位点和标记，作为两个数字参量，小的在前面。这是唯一定义两个连续参量  
       而不是一个参量的控制符。  
- let  
  
   (let ((foo (buffer-name))  
         (bar (buffer-size)))  
     (message  
    "This buffer is %s and has %d characters."  
    foo bar))  
  
- save-excursion  
   (message "We are %d characters into this buffer."  
        (-  (point)   
           (save-excursion   
              (goto-char (point-min)) (point))))  
  
- if  
  
   (if (string= (int-to-string 19)  
              (substring (emacs-version) 10 12))  
       (message "This is version 19 Emacs")  
       (message "This is not version 19 Emacs"))   
  
- equal、eq  
  
  测试两个对象是否相同。如果两个对象有相似的结构和内容，equal 则返回  
   “真”。如果两个参量确实是完全相同的对象，则另一个函数 eq 返回“真”。  
  
- <、>、<=、>=  
  
  <函数测试其第一个参量是否小于第二个参量。与之对应的>函数则测试其第一  
  个参量是否大于第二个参量。同样地，<=函数测试其第一个函数是否小于或者  
  等于第二个参量，>=函数则测试第一个参量是否大于或者等于第二个参量。所  
  有这些函数使用的参量都是数字。  
  
- message  
  
  这个函数往回显区中打印一条消息。打印的消息只可以有一行。这个函数的第  
  一个参量是一个字符串，这个字符串中能够包含"%s"、"%d"或者"%c"，以打印  
  字符串后面的参量的值。用来替代"%s"的参量必须是一个字符串或者一个符  
  号；用来替代"%d"的参量必须是一个数字。而用来替代"%c"的参量必须是一个  
  数字，它将打印出具有相应数值的 ASCII 字符。  
  
- setq、set   
  
  setq 函数将其第一个参量的值设置为第二个参量的值。第一个参量由这个 setq  
  函数自动地加上引号。这个函数对后续的成对参量执行同样的赋值操作。另外  
  一个 set 函数只能接受两个参量，并在将其第一个参量返回的值设置为其第二个  
  参量返回的值之前对它们求值。  
  
- buffer-name  
  
  这个函数不需要参量，它将缓冲区的名字以一个字符串的形式返回。  
  
- buffer-file-name  
  
  这个函数不需要参量，它返回缓冲区正在访问的文件的名字。  
  
- current-buffer  
  
  返回 Emacs 中当前缓冲区的名字，这个当前缓冲区可能并不是屏幕上看到的缓冲区。  
  
- other-buffer  
  
  返回最近选择过的缓冲区（既不是作为参量传送给 other-buffer 函数的缓冲  
  区，也不是当前缓冲区。）  
  
- switch-to-buffer  
  
  这个函数为 Emacs 选择一个活动的缓冲区，并将它显示在当前的窗口，以使用户  
  能够看到它。这个函数经常被绑定到 C-x b 键序列。  
  
- set-buffer  
  
  将 Emacs 的注意力切换到另外一个运行程序的缓冲区。不要改变当前窗口正在显  
  示的内容。  
  
- buffer-size  
  
  返回当前缓冲区中的字符数。  
  
- point  
  
  返回当前光标位置对应的值，这个值是从缓冲区的开始处直到光标所在位置所  
   占的总的字符数。  
  
- point-min  
  
  返回当前缓冲区中位点的最小可能值。如果变窄没有开启，这个值就是 1。  
  
- point-max  
  
  返回当前缓冲区中位点的最大可能值。如果变窄没有开启，这个值就是缓冲区  
  末尾对应的值。  
  
* 第 4 章 与缓冲区有关的函数  
** 4.1 查找更多的信息  
  
在这个浏览中，我将对要遇到的每一个函数进行或者详细或者简单的描述。如果  
你感兴趣的话，可以键入 C-h f 以及函数名（当然还要加上回车键<RET>），随时  
得到任何一个 Emacs Lisp 函数的全部文档。类似地，可以键入 C-h v 和变量名（以  
及回车键<RET>）得到任何变量的全部文档。  
  
同样，如果要在一个原始的源代码文件中查看一个函数定义，可以使用  
find-tags 函数跳到相应的位置。键入 M-. （即同时键入 META 键和句点，或者键入  
ESC 键后再键入句点），然后在提示符下输入要查看源代码的函数的函数名，例如  
mark-whole-buffer，然后键入回车键<RET>。Emacs 将切换缓冲区并在屏幕上显示  
函数的源代码。要切换回原来的缓冲区，键入 C-x b <RET>。  
  
根据你的 Emacs 拷贝的初始缺省设置值的不同，你可能还需要定义一个“标记  
表”(tags table)，这是一个名为“TAGS”的文件。这个文件最可能在  
 “emacs/src”目录中，因此应使用 M-x visit-tages-table 命令并指定一个类似  
"/usr/local/lib/emacs/19.23/src/TAGS"这样的路径名。关于如何创建自己的  
 “TAGS”文件，可以参见《GNU Emacs 技术手册》的“标记表”一节，也可以参见  
本书的 12.5 节，“创建自己的‘TAGS’文件”。  
  
当你对 Emaes Lisp 更加熟悉后，你会频繁地使用 find-lags 去浏览源代码，并且可  
以创建自己的“TAGS”标记表。  
  
顺便说一说，包含 Lisp 代码的文件习惯上称为库（library）。这种隐喻说法来自  
于特别定义的库，例如法律库、工程库而非一般的图书馆。每一个库，或者一个  
文件，都是与某个主题或者某项活动有关的函数。例如，"abbrev.el"用于处理缩  
写和其他输入快捷键，而"help.el"用于在线帮助。（有时为了某个任务需要几个  
库，例如各种"rmail..."文件为阅读电子邮件提供代码。）在《GNU Emacs 技术手  
册》中，将看到这样的句子：“C-h p 命令让你用主题关键字搜索 Emacs Lisp 标准  
库”。  
  
** 4.2 简化的 beginning-of-buffer 函数定义  
下面就是这个简化的 beginning-of-buffer 函数的完整代码：  
  
(defun simplified-beginning-of-buffer ()   
  "Move point to the begining of the buffer;   
   leave mark at previous position."  
    (interactive)   
    (push-mark)   
    (goto-char (point-min)))  
  
就像所有的函数定义一样，这个定义在特殊表 defun 之后有五个部分：  
  
1）函数名：在这个例子中，就是 simplified-beginning-of-buffer。  
  
2）参量列表：在这个例子，是一个空列表()。  
  
3）文档字符串。  
  
4）交互表达式。  
  
5）函数体。  
  
** 4.3 mark-whole-buffer 函数的定义  
  
(defun mark-whole-buffer ()  
  "Put Point at beginning and mark at end of buffer."    
   (interactive)  
   (push-mark (point))  
   (push-mark (point-max))  
   (goto-char (point-min)))  
  
(defun name-of-function (argument-list)  
  "documentation..."  
   (interactive-expression...)  
  body...)  
** 4.4 append-to-buffer 函数的定义  
(defun append-to-buffer (buffer start end)  
  "Append to specified buffer the text of the region.  
   It is inserted into that buffer before its point.  
  
   When calling from a Program, give three argumnets:  
   a buffer or the name of one, and tow character numbers  
   specifying the portion of the current buffer to be copied."    
     (interactive "BAppend to buffer: \nr")  
     (let ((oldbuf (current-buffer)))  
        (save-excursion   
          (set-buffer (get-buffer-create buffer))  
          (insert-buffer-substring oldbuf start end))))  
拷贝文本的目的缓冲区，start 和 end 参量是指将要被拷贝的当前缓冲区中指定  
域的起始和终止位点。  
*** 4.4.1 append-to-buffer 函数的交互表达式  
  
(interactive "BAppend to buffer: \nr")  
  
*** 4.4.2 append-to-buffer 函数体  
  
(defun append-to-buffer (buffer start end)   
  "documentation..."  
   (interactive "BAppend to buffer: \nr")  
   (let ((variable value))  
        body)  
  
let 表达式有三个元素：   
  
1) 符号 let；  
  
2) 一个变量列表，在这个例子中．这个变量列表包含一个两元素列表(variable  
   value)  
3) let 表达式主体。  
*** 4.4.3 append-to-buffer 函数中的 save-excursion  
  
append-to-buffer 函数中 let 表达式的主体由一个 save-excursion 表达式组成。  
(defun ...  
  ...  
  ...  
    (let...  
       (save-excursion  
        ...  
  
从这种格式化编排约定可以很容易看出 save-excursion 表达式主体中的两行由与  
save-excursion 联系在一起的括号包围，就像 save-excursion 表达式本身由与  
let 表达式联系在一起的括号包围一样：  
  
  (let ((oldbuf (current-buffer)))  
    (save-excursion  
      (set-buffer (get-buffer-create buffer))  
      (insert-buffer-substring oldbuf start end)))  
  
save-excursion 函数的使用可以被看做是填充下面这个模板的一个过程：  
  
(save-excursion  
  first-expression-in-body  
  second-expression-in-body  
  ...  
  last-expression-in-body)  
  
  (set-buffer (get-buffer-create buffer))  
  (insert-buffer-substring  oldbuf start end)  
  
  
set-buffer 函数将 Emacs 的注意力转移到文本将要拷贝到的目的缓冲区，而  
save-excursion 函数将从这个缓冲区返回。完成这一工作的一行表达式如下所示：  
  
(set-buffer (get-buffer-create butfer))  
  
append-to-buffer 的最后一行所做的工作就是增添文本：  
  
(insert-buffer-substring oldbuf start end)  
  
insert-buffer-substring 函数从作为其第一个参量指定的缓冲区中拷贝一个字  
符串， 并将其插入到当前的缓冲区中。 在这个例子中，传送给  
insert-buffer-substring 的参量是由 let 创建并绑定的变量的值，也就是  
oldbuf 的值，它是当发出 append-to-buffer 命令时的当前缓冲区。  
  
insert-buffer-substring 函数执行完之后，save-excursion 将恢复对原来缓冲区  
的操作，并且 append-to-buffer 将完成其工作。  
  
用一个粗略的框架来描述这个函数，其函数体的工作如下所示：  
  
(let (bind-oldbuf-to-value-of-current-buffer)  
    (save-excursion                      ;Keep track of buffer  
    change-buffer  
    insert-substring-from-oldbuf-into-buffer)  
  
    change-back-to-original-buffer-when-finished  
   let-the-local-meaning-of-oldbuf-disappear-when-finished  
  
总之，append-to-buffer 函数是这样工作的：它在变量 oldbuf 中保存当前缓冲区  
的值；并获得一个新的缓冲区（如果需要的话就创建一个新的缓冲区），然后使  
Emacs 切换到这个缓冲区。使用 oldbuf 的值，这个函数将来自原来缓冲区的文本域  
插入到新的缓冲区中，然后用 save-excursion 函数返回到原来的缓冲区。  
  
在考查这个 append-to-buffer 函数时，你已经深入接触了一个相当复杂的函数。  
它演示了如何使用 let 和 save-excursion，以及如何变换到其他缓冲区并返回原来  
的缓冲区。许多函数定义中都是这样使用 let、save-excursion 和 set-buffer 的。  
  
** 4.5 回顾  
  
下面简单地小结一下本章讨论过的函数。  
  
- describe-function、describe-variable  
- find-tag  
  找到存放某个函数或者变量的源代码的文件，并切换到这个缓冲区，将位点  
   （光标）置于相应函数或者变量的开始处。习惯上将它绑定到 M-.   
  
- save-excursion  
- push-mark  
- goto-char  
- insert-buffer-substring  
- mark-whole-buffer  
- set-buffer  
- get-buffer-create、get-buffer  
** 4.6 练习  
- 编写自己的 simplified-end-of-buffer 函数定义，然后测试它是否能工作。  

- 用 if 和 get-buffer 编写一个函数，这个函数要打印一个说明某个缓冲区是否存  
  在的消息。  
  
- 用 find-tag 找到 copy-to-buffer 函数的源代码。  
  
* 第 5 章 更复杂的函数  
** 5.1 copy-to-buffer 函数的定义  
...  
(interactiv "BCopy to buffer: \nr")  
    (let ((oldbuf (current-buffer)))  
       (save-excursian  
         (set-buffer (get-buffer-create buffer))  
         (erase-buffer)  
         (save-excursion  
           (insert-buffer-substring oldbuf start end))))  
  
为什么要两次使用 save-excursion 函数呢？再一次考查这个函数做些什么。  
  
在结构上说．copy-to-buffer 函数体如下所示：  
  
  (let (bind-oldbuf-to-value-of-current-buffer)  
     (save-excursion      ;First use of save-excursion.  
       change-buffer  
          (erase-buffer)  
          (save-excursion  ;Second use of save-excursion.  
           insert-substring-from-oldbuf-into-buffer)))  
** 5.2 insert-buffer 函数的定义  
  
  (defun insert-buffer (buffer)   
  "Insert after point the contents of BUFFER.  
   Puts mark after the inserted text.  
   BUFFER may be a buffer or a buffer name ·"  
   (interactive "*bInsert buffer: ")  
   (or (bufferp  buffer)  
       (setq buffer (get-buffer buffer)))   
   (let (start end newmark)  
     (save-excursion   
        (save-excursion  
          (set-buffer buffer)  
          (setq start (point-min) end (point-max)))  
        (insert-buffer-substring buffer start end)  
        (setq newmark (point)))  
     (push-mark newmark)))  
  
就像其他的函数定义一样，可以使用函数定义的模板来分析这个函数的框架：  
  
  (defun insert-buffer (buffer)  
   "documentation..."  
   (interactive  "*bInsert buffer:")  
   body...)  
  
*** 5.2.1 insert-buffer 函数中的交互表达式  
  
在 insert-buffer 函数中，给 interactive 表达式说明的参量有两个部分：一部分  
是一个星号“*"，另一部分是“bInsert buffer:”。  
  
+ 只读缓冲区  
 
星号“*”用于缓冲区是一个只读缓冲区的情况，只读缓冲区就是指一个不能改变  
内容的缓冲区。如果 insert-buffer 被一个只读缓冲区调用，一条消息将打印在回  
显区，终端将发出蜂鸣或者闪亮一下，警告不允许往这个缓冲区插入任何东西。  
星号这个控制符无需后接一个换行符来分隔不同的参量。  
 
- 交互表达式中的“b”  
  
在交互表达式中的下一个参量以“b”字符开始。（这一点与 append-to-buffer 函  
数的代码不同，在那个函数定义中使用一个大写的“B”。参见 4.4 节  
 “append-to-buffer 函数的定义”。）小写的“b”告诉 Lisp 解释器传送给  
insert-buffer 函数的参量应是一个存在的缓冲区或者这个缓冲区的名字。（大写  
的“B”，可以允许参量传送不存在的缓冲区）。Emacs 将提示你输入缓冲区的名  
字，并为你提供一个默认的缓冲区。如果这个缓冲区不存在，你将收到一条消息  
告之“找不到该缓冲区”，你的终端也将对你发生蜂鸣叫声。  
  
*** 5.2.2 insert-buffer 函数体  
  
insert-buffer 函数体有两个主要的部分：一个 or 表达式和一个 let 表达式。or 表  
达式的目的是为了确保 buffer 参量真正与一个缓冲区绑定在一起，而不是绑定到  
缓冲区的名字。let 表达式包含了将另外一个缓冲区的内容拷贝到当前缓冲区所需  
的代码。  
  
从结构上说，适合 insert-buffer 函数的两个表达式如下所示：  
  
(defun insert-buffer (buffer)  
  "documentation..."  
   (interactive "*bInsert buffer:")   
   (or ...  
      ...  
   (let (varlist)  
     body-of-let...)  
  
为了理解 or 表达式如何确保参量 buffer 确实是绑定到一个缓冲区，而不是绑定到  
一个缓冲区的名字，首先需要理解 or 函数本身。  

在讲述 or 函数之前，让我用 if 表达式重新改写函数的这一部分，这样你就可以看  
到这是如何以另外一种方式完成类似的工作的。  
  
*** 5.2.3 用 if 表达式（而不是 or 表达式）编写的 insert-buffer 函数  
  
用 if 表达式来改写这个部分代码，是为了确保 buffer 的值是缓冲区本身而不是缓  
冲区的名字。如果 buffer 的值是缓冲区的名字，则一定要设法得到缓冲区本身。  
  
可以想象，好比在一个会议上，一个引座员手拿一本印有你大名的花名册寻找  
你：引座员绑定到你的名字，而不是你，但是当引座员找到你并拉住你的手的时  
候，引座员就绑定到你了。  
  
在 Lisp 中，可以这样描述这种情况：  
  
(if (not (holding-on-to-guest))   
     (find-and-take-arm-of-guest))  
  
我们希望对一个缓冲区做同样的事情——如果没有获得缓冲区本身，就要设法得到  
它。  
  
一个名为 bufferp 的谓词会告诉我们是否得到一个缓冲区本身（而不是缓冲区的名  
字），因此可以这样编写代码：  
  
(if (not (bufferp buffer))                 ;if-part  
     (setq buffer (get-buffer buffer))) ;then-part  
  
     zhua not 不是真，是假的 ，那是假的就是 then-part
bufferp 函数名的最后一个字符是“p”，这种后带“p”是一种习惯，它  
表示这个函数是一个谓词，也就是这些带“p”的函数是用来判断一些特性的真假。  
  
(not (bufferp buffer))  
  
not 函数的功能是：如果其参量为“假”，则其返回“真”；如果其参量值为  
 “真”，则其返回“假”。因此，如果(bufferp buffer)表达式返回“真”，则  
not 表达式返回“假”；反之亦然：“不真”就是“假”，“不假”就是“真”。  
*** 5.2.4 函数体中的 or 表达式  
  
insert-buffer 函数中的 or 表达式的目的是确保 buffer 参量绑定到一个缓冲区而不  
仅仅是一个缓冲区的名字。前面一节介绍了这可以用 if 表达式完成。然而，  
insert-buffer 函数实际上使用了 or 表达式。为了理解这一点，有必要弄懂 or 表达  
式是如何工作的。  
  
一个 or 函数可以有很多参量。它逐一对每一个参量求值并返回第一个其值不是  
nil 的参量的值。同样，这是 or 表达式的一个重要特性，一旦遇到其值不是 nil 的  
参量之后，or 表达式就不再对后续的参量求值。  
  
or 表达式如下所示：  
  
  (or (bufferp buffer)   
       (setq buffer (get-buffer buffer)))  
  
or 表达式的第一个参量是(bufferp buffer)。如果变量 buffer 确实对应着一个缓  
冲区，则这个表达式返回“真”(一个非空值，not-nil)；如果 buffer 仅仅是一个  
缓冲区的名字，则这个表达式返回“假”。在这个 or 表达式中，如果确实是这么  
一回事，则 or 表达式返回这个“真”值，而且不再对其下一个表达式求值——这正  
是我们需要的，如果 buffer 确实是一个缓冲区，无需对 buffer 的值做任何事情。  
  
另一个方面，如果(bufferp buffer)的值是 nil，Lisp 解释器则对 or 表达式的下一  
个元素求值。这种情况当 buffer 的值是一个缓冲区的名字时就会发生。下一个元  
素就是表达式(setq bufrer (get-burfer buffer))。这个表达式返回一个非空  
值，其返回值就是变量 buffer 设置的值——也就是缓冲区本身，而不是缓冲区的名  
字。  
  
所有这些代码的执行结果是：符号 buffer 总是绑定到一个缓冲区本身而不是缓冲  
区的名字。之所以需要这些代码，是因为后面的 set-buffer 函数仅仅对一个缓冲  
区起作用，而不对缓冲区的名字起作用。  
  
顺便提一下，用 or 函数，那么引座员的情况可以写成下面的形式：  
  
(or (holding-on-to-guest) (find-and-take-arm-of-guest))  
  
*** 5.2.5 insert-buffer 函数中的 let 表达式  
  
在确保变量 buffer 是指向一个缓冲区而不是一个缓冲区的名字之后，  
insert-buffer 函数继续使用 let 表达式。这定义了三个变量：start、end 和  
newmark，并将它们绑定到初始值 nil。这些变量在 let 表达式内部使用，并暂时屏  
蔽 Emacs 中所有同名的变量直到 let 表达式结束。  
  
let 表达式的主体包含了两个 save-excursion 表达式。首先，将详细分析内层的那  
个 save-excursion 表达式。这个表达式如下所示：  
  
  (save-excursion  
    (set-buffer buffer)  
    (setq start (point-min) end (point-max)))  
  
表达式(set-buffer buffer)将 Emacs 的注意力从当前的缓冲区切换到要从中拷贝  
文本的缓冲区。在那个缓冲区中，用 point-min 和 point-max 函数将变量 start 和  
end 设置成该缓冲区的开始处和结束处。注意，这里已经演示了 setq 如何在一个表  
达式中给两个变量赋值。setq 的第二个参量的值被赋给第一个参量，第四个参量  
的值被赋给第三个参量。  
  
内层的 save-excursion 表达式被求值之后，它恢复原来的缓冲区，但是 start 和  
end 变量仍然被设置成从中拷贝文本的缓冲区的开始处和结束处。  
  
外层的 save-excursion 表达式如下所示：  
  
  (save-excursion   
    (inner-save-excursion-expression  
      (go-to-new-buffer-and-set-start-and-end)  
    (insert-buffer-substring buffer start end)  
    (setq newmark (point)))  
  
insert-buffer-substring 函数将文本从由 buffer 中的 start 和 end 变量界定的区域  
拷贝到当前缓冲区。因为第二个缓冲区的全部内容都在 start 和 end 之间，因此第  
二个缓冲区的所有内容都被拷贝到你正在编辑的当前缓冲区。接下来，位于插入  
文本末尾的位点的值记录在变量 newmark 中。  
  
外层的 save-excursion 被求值之后，位点和标记被重新定位到它们原来的位置。  
  
然而，习惯上，标记的位置一般在新插入的文本之后，而位点的位置在新插入的  
文本的开始处。newmark 变量记录新插入的文本的末尾。在 let 表达式的最后一  
行，(push-mark newmark)表达式在这个位置设置了一个标记。（上一个标记的位  

----------------------- Page 66-----------------------

置仍然可以找到，它记录在标记环中，可以键入 C-u C-<SPC>返回到原来标记  
处。）同时，位点设置在插入的文本的开始处，也就是位点设置在你调用插入函  
数之前所处的位置。  
  
整个 let 表达式如下所示：   
  
(let (start end newmark)  
    (save-excursion  
       (save-excursion  
           (set-buffer buffer)  
           (setq start (point-min) end (point-max)))  
    (insert-buffer-substring buffer start end)  
    (setq newmark (point)))  
    (push-mark newmark))  
  
就像 append-to-buffer 函数那样．insert-buffer 函数使用了 let、  
save-excursion 和 set-buffer 函数。除此之外，这个函数展示了使用 or 函数的一  
个方法。在后面将一次又一次看到这些函数，它们都是构建 Lisp 程序的基本函数。  
  
** 5.3 beginning-of-buffer 函数的完整定义  
  
在前面已经讨论过 beginning-of-buffer 函数的基本结构。（参见 4.2 节，“简化  
的 beginning-of-buffer 函数定义”。）本节描述这个函数定义的复杂部分。  
  
就像前面描述的，不带参量激活 beginning-of-buffer 函数时，它将光标移动到缓  
冲区的开始处，并在原来光标的位置设置一个标记。然而，当带参量激活  
beginning-of-buffer 函数时，如果参量是介于 1 和 10 之间的一个数，则该函数认  
为那个数是指缓冲区长度的十分之几，而且 Emacs 将光标移动到从缓冲区开始到这  
个分数值所指示的位置。因此，可以用键序列 M-<调用这个函数，这是指将光标移  
动到缓冲区的开始处，也可以用这样的命令调用这个函数：C-u 7 M-< ，这是指  
将光标移动到从缓冲区开始的这个缓冲区的 70％处。如果这个作为参量的数大于  
10，函数则将光标移动到缓冲区的末尾。  
  
beginning-of-buffer 函数可以带参量调用，也可以不带参量调用，参量的使用是  
可选的。  
  
*** 5.3.1 可选参量  
  
除非已经声明，否则 Lisp 总是希望一个函数定义中带参量的函数在被调用时要传  
递一个值给该参量。如果没有传递相应的值，函数就会出错，并得到这样一个错  
误消息：“wrong number or arguments”。  
  
然而，可选参量是 Lisp 的一个特性：有一个关键词可以用于告诉 Lisp 解释器某个  
参量是可选的。这个关键词是 &optional（在单词“optional”之前的符号“&”  

是关键词的一部分）。在一个函数定义中，如果一个参量跟在 &optional 这个关  
键词后面，则当调用这个函数时就不一定要传送一个值给这个参量。  
  
因此，beginning-of-buffer 函数定义的第一行就变成如下所示的形式：  
  
(defun beginning-of-buffer (&optional arg)  
  
从结构上说，整个函数如下所示：  
  
(defun beginning-of-buffer (&optional arg)   
  "documentation..."  
   (interactive "P")  
   (push-mark)  
   (goto-char  
     (if-there-is-an-agrument  
        figure-out-where-to-go  
      else-go-to  
       (point-min))))  
  
除了这个函数在 interactive 表达式中使用了“P”参量以及将 goto-char 函数用在  
一个条件表达式中以判断将光标移动到何处之外，上面这个函数与  
simplified-beginning-of-buffer 函数很相似。  
  
interactive 表达式中的"P"参量告诉 Emacs，如果有参量的话，就传递一个前缀参  
量给这个函数。一个前缀参量由键入 META 键以及后接的一个数组成的，或者由键  
入 C-u 和一个后接的数组成（如果你没有键入一个数，C-u 默认为 4)。  
  
上面的函数定义中，if 条件表达式的真假测试很简单：它只是参量 arg 而已。如果  
参量 arg 有一个非空（nil）值，即当 beginning-of-buffer 函数带参量调用时，真  
假测试返回“真”，并且 if 表达式中的 then 部被求值；另一方面，如果不带参量  
调用 beginning-of-buffer 函数，这个 arg 参量为 nil，并且 if 表达式的 else 部被求  
值。if 表达式的 else 部只是 point-min，并且当这就是 if 表达式的结果时，整个  
goto-char 表达式就是(goto-char (point-min))，这就是我们在前面看到的  
beginning-of-buffer 函数的简化形式。  
  
*** 5.3.2 带参量的 beginning-of-buffer 函数  
  
当带参量调用 beginning-of-buffer 函数时，就要有一个表达式计算应该传递什么  
值给 goto-char 表达式。这个表达式初看起来似乎相当复杂，它包含一个 if 表达式  
和许多算术计算。这个表达式如下所示：  
  
(if (> (buffer-size) 10000)  
   ;; Avoid overflow for large buffer sizes!  
    (* (prefix-numeric-value arg) (/ (buffer-size) 10))  
   (/   
     (+ 10   
        (*   
           (buffer-size)(prefix-numeric-value arg))) 10))  
  
就像其他复杂的表达式一样，这个表达式也可以用模板来一一揭开其中的奥秘。  
在这个例子中，模板就是 if 表达式模板。当用结构框架来看这个表达式时，这个  
表达式如下所示：  
  
(if (buffer-is-large  
    divide-buffer-size-by-10-and-multiply-by-arg  
   else-use-alternate-calculation  
  
在这个内层的 if 表达式中，真假测试用于检查缓冲区的大小。之所以要检查缓冲  
区的大小是因为第 18 版的 Emacs Lisp 使用了不大于 8,000,000 的数字来描述缓冲区  
的大小（更大的数就不需要了），并当在后续的计算中遇到很大的缓冲区  
时，Emacs 就试图使用超大的数来描述它。在注释中提到的术语"overflow" （溢  
出）是指所用的数太大了。  
  
这里有两种情况：缓冲区很大或者并不大。  
  
1．大缓冲区的情况  
  
在 beginning-of-buffer 函数中，内层的 if 表达式判断缓冲区是否大于 10,000 个字  
符。它使用>函数和 buffer-size 函数来完成这一工作：  
  
  (if (> (buffer-size) 10000)  
  
当缓冲区大于 10,000 时，if 表达式的 then 部被求值。其中 then 部如下所示：  
  
  (*   
     (prefix-numeric-value arg)   
     (/ (buffer-size) 10))  
  
这个表达式是一个乘法，*函数有两个参量。  
  
其中的第一个参量是(prefix-numeric-value arg)。当在 interactive 表达式中使  
用“P”参量时，作为函数参量传给函数的值是以一个“未加工的前缀参量”(raw  
prefix argument)的形式传递的。（它是在一个列表中的一个数。）为了执行算  
术运算，有必要对它进行变换，prefix-numeric-value 函数就是完成这一工作的。  
  
其中的第二个参量是(/ (buffer-size) 10)。这个表达式将缓冲区的大小（数  
字）除以 10。这个表达式产生一个数，这个数就是指缓冲区大小的十分之一有多  
少字符。（在 Lisp 中， /用于除法，就像*用于乘法一样）。  

  
在乘法表达式中，这个数作为一个整体乘以前缀参量的值，乘法的结构如下所示：  
  
  (* numeric-value-of-prefix-arg  
    number-of-characters-in-one-tenth-of-the-buffer)  
  
例如，如果前缀参量是"7"，则缓冲区的十分之一的值乘以 7 得到缓冲区的 70％。  
  
如果是大缓冲区，则所有这些代码的最后结果就使 goto-char 表达式变成这样：  
  
  (goto-char  (*  (prefix-numeric-value arg)  
                  (/ (buffer-size) 10)))  
  
这个表达式的功能是将光标置于我们需要的地方。  
  
2．小缓冲区的情况  
  
如果缓冲区中包含的字符数少于 10,000 个，就要执行一个稍微不同的计算。你可  
能认为这不必要，因为前面的计算可以完成这个工作。然而，在一个小缓冲区  
中，第一种方法无法精确地将光标置于所需的那一行。这第二种方法可以更好地  
做到这一点。  
  
这部分代码是：  
  
(/ (+ 10 (* (buffer-size)(prefix-numeric-value arg)))10)  
  
这个函数代码看似有些复杂，但是通过逐一分析函数是如何嵌入到括号中，就可  
以清楚地分析出最后的结果。如果以缩进的方式重写每一个表达式，就可以更容  
易地阅读它。  
  
(/   
    (+ 10   
       (* (buffer-size)  
          (prefix-numeric-value arg)))  
  10)  
  
  
检查这些括号，会发现最内层的操作是(prefix-numeric-value arg)，即把未加  
工的前缀参量转换成一个数。这个数在下面的表达式中乘以缓冲区的大小：  
  
  (* (buffer-size) (prefix-numeric-value arg))  
  
这个乘法的结果是产生一个数，这个数可能大于缓冲区的大小——如果参量是 7，就  
是缓冲区的 7 倍。然后这个数再加 10，最后用这个结果除以 10，这样产生的数比缓  

----------------------- Page 70-----------------------

冲区中相应比例仅仅多一个字符。  
  
所有这些代码执行后产生的最终的一个数被传递到 goto-char 函数，并且光标就移  
动到那个位点。  
  
*** 5.3.3 完整的 beginning-of-buffer 函数  
  
下面是 beginning-of-buffer 函数的完整形式：   
  
(defun beginning-of-buffer (&optional arg)  
  "Move Point to the beginning of the buffer;  
  leave mark at previous position.  
 With arg N,Put point N/10 of the way  
 from the true begining.   
 Don't use this in Lisp Programs!   
 \(goto-char (point-min)) is faster   
  and does not set the mark."   
   (interactive "P")  
   (push-mark)  
   (goto-char  
    (if arg  
        (if(> (buffer-size) 10000)  
        ;;Avoid overflow for large buffer sizes!  
            (* (prefix-numeric-value arg)  
               (/ (buffer-size) 10))  
      (/ (+ 10 (* (buffer-size)  
               (prefix-numeric-value arg)))  
        10))  
      (point-min)))  
   (if arg (forward-line 1)))  
  
除了两个小点外，前面的讨论展示了这个函数是如何工作的。第一点处理文档字  
符串中的细节，第二点关于函数的最后一行。  
  
在文档字符串中，提到了这样一个表达式：  
  
 \(goto-char (point-min))  
  
其中的第一个括号之前有一个"\"符号。这个符号告诉 Lisp 解释器将这个表达式作  
为文档打印出来，而不作为一个符号表达式对它求值。  
  
最后，当这个函数带参量调用时，beginning-of-buffer 函数的最后一行是让光标  
移动到后续一行的开始处：  
  
(if arg (forward-line 1))  
  
这个命令将光标置于缓冲区中相应于前缀参量值的位置的后续第一行的行首。这  
是一个好主意，它意味着光标总是置于缓冲区中至少是需要的位置。我们当然希  
望光标精确地置于需要到达的位置，但是这并不是必须的。如果没有精确地置于  
需要到达的位置，也不要抱怨太多。  
  
** 5.4 回顾  
  
- or  
  
  逐一对每一个参量求值，并返回第一个非空值（不是 nil）。如果所有参量的  
  值都是 nil，就返回 nil。简要地说，它返回参量的第一个“真”值；如果一个  
  参量或者其他任何参量的值为“真”时，则返回“真”值。  
  
- and  
  
  逐一对每一个参量求值，如果有任何一个参量的值为 nil，则返回 nil。如果没  
  有 nil 值，则返回最后一个参量的值。简要地说，仅当所有参量都是“真”值  
  时，它才返回一个“真”值；如果一个参量和其他所有参量的值都是“真”值  
  时，则返回“真”值。  
  
- &optional  
  
  在函数定义中用于指出一个参量是可选参量。这意味着这个函数可以带参量调  
  用，也可以不带参量调用。  
  
- prefix-numeric-value  
  
  将一个由(interactive "P")产生的未加工的前缀参量转换成一个数值。  
  
- forward-line  
  
  将光标移动到下一行的行首，如果其参量大于 1，则移动多行。如果无法移动  
  所需的行数，forward-line 就移动尽可能多的行数，并返回它实际少移动的  
  行数。  
  
- erase-buffer  
  
  删除当前缓冲区的全部内容。  
  
- bufferp  
  
  如果其参量是一个缓冲区则返回“真”，否则返回“假”(nill)。  
  
  
** 5.5 &optional 参量练习  
  
编写一个带可选参量的交互函数，这个函数要测试函数被调用时是否有参量（其  
值是一个数），这个数是否大于或小于 fill-column 的值，并将结果以一个消息的  
形式给出。然而，如果不带参量调用这个函数时，则使用 56 作为默认值。  
  
* 第 6 章 变窄和增宽  
  
 “变窄”(narrowing)是 Emacs 的一个特性，这个特性允许你让 Emacs 关注于一个  
缓冲区的特定部分，而不会在无意中更改缓冲区的其他部分。变窄一般都是没有  
开启的，因为它会将新手弄得不知所措。  
  
采用变窄技术之后，缓冲区的其余部分就变成不可见的了，就像它们并不存在一  
样。这样做有一个好处，例如，要在缓冲区的某个部分而不是在别的部分替换一  
个单词：首先将那个部分隔离出来，替换工作就在缓冲区的这个变窄的部分进  
行，而不在缓冲区的其余部分进行。查询也是在缓冲区的一个变窄的部分进行，  
而不是在缓冲区的其他部分进行。因此，如果你正在修改一个文档，你可以使自  
己严格限制在要修改的那个部分，而不要跑到其他部分去。只要用变窄技术就可  
以实现这一点。  
  
然而，变窄确实使缓冲区的其余部分不可见，这会使那些无意中设置了变窄功能  
的人惊恐不安，并认为他们已经删除了文档的一部分。更有甚者，undo 命令（这  
个命令经常绑定到 C-x u）无法取消变窄开启（或者不应当）。因此，如果人们不  
知道可以用 widen 命令使其余部分重新变成可见的，他们就会非常绝望。（在  
Emacs 第 18 版中，widen 命令一般绑定到 C-x w；而在第 19 版中，则绑定到  
C-x n w。）  
  
 【将当前区域开启变窄是 C-x n n  （narrow-to-region）。——Chion 注】  
  
变窄技术不仅对人有用，而且对 Lisp 解释器也同样有用。通常，一个 Emacs Lisp  
函数被设计成针对缓冲区的一个区域操作，或者反过来说，Emacs Lisp 函数需要  
在一个变窄开启的缓冲区中执行。例如，如果一个缓冲区设置了变窄开启，  
what-line 函数从缓冲区中取消变窄开启，然后完成它本身的工作，随后再恢复缓  
冲区中原来的变窄开启。另一方面，由 what-line 调用的 count-line 函数则用变窄  
技术来将这个函数的执行范围限制到缓冲区中你感兴趣的那个部分，并随后恢复  
原来的状态。  
  
** 6.1 save-restriction 特殊表  
  
在 Emacs Lisp 中，能用 save-restriction 特殊表来跟踪变窄开启的部分。当 Lisp  

解释器遇到 save-restriction 特殊表时，它执行这个表达式中的代码，并恢复这  
些代码导致的变窄开启的变更。例如，如果缓冲区本来是变窄开启的，而  
save-restriction 表达式中的代码取消了变窄开启，save-restriction 特殊表就  
返回变窄开启的缓冲区部分。在 what-line 命令中，缓冲区中可能包含的变窄开启  
都可以用紧跟在 save-restriction 特殊表后面的 widen 命令取消。在这个函数执行  
完之前，所有的变窄开启都被恢复了。  
  
save-restriction 表达式的模板很简单：  
  
  (save-restriction  
   body...)  
  
save-restriction 特殊表的主体是一个或多个表达式，这些表达式将被 Lisp 解释  
器逐一求值。  
  
最后，有一点值得提醒一下：当你同时使用 save-excursion 和 save-restriction  
时（并且是一个紧接着另一个使用时），应当在外层使用 save-excursion。如果  
采用了相反的次序，就会在调用 save-excursion 之后无法记录缓冲区中变窄开启  
的标记。因而，当同时使用这两个特殊表时，应当采用类似下面的顺序：  
  
  (save-excursion  
    (save-restriction  
     body...))  
  
** 6.2 what-line 函数  
  
what-line 命令告诉你光标所在的行数。这个函数展示了如何使用  
save-excursion 和 save-restriction 命令。下面是这个函数的全部代码：  
  
(defun what-line ()   
  "Print the current line number (in the buffer) of point."  
   (interactive)  
   (save-restriction  
    (widen)  
      (save-excursion  
         (beginning-of-line)  
         (message "Line %d"  
                 (1+ (count-lines 1 (point)))))))  
  
这个函数有一个文档说明行，并且该函数就像你希望的那样，也是一个交互函数。  
函数定义中接下来的两行使用了 save-restriction 和 widen 函数。  
  
save-restriction 特殊表判断当前缓冲区是否设置了变窄开启，如果设置了，就  
在 save-restriction 特殊表中的所有代码执行完之后恢复变窄开启。  
  
上面的代码中，save-restriction 特殊表之后紧跟了一个 widen 命令。当  
what-line 被调用时，这个函数取消当前缓冲区中可能有的所有的变窄开启标记。  
 （其中的变窄开启标记由 save-restriction 特殊表记录下来。）这个增宽操作使  
对行的计数从缓冲区的开始处进行。否则，计数就被局限在缓冲区的可见部分。  
所有原有的变窄开启在 save-restriction 特殊表执行完时被恢复。  
  
在 widen 命令之后紧跟着 save-excursion 特殊表，它保存光  
标的位置（即位点），并在此作一个标记，当 save-excursion 特殊表中的代码使  
用 beginning-of-line 函数来移动位点之后再恢复它们。  
  
 （注意，(widen)表达式夹在 save-restriction 和 save-excursion 之间。当你编写  
连续含有两个 save-...的表达式时，总是要将 save-excursion 写在最外层。）  
  
what-line 函数的最后两行代码对缓冲区中行数进行计数，然后在回显区中打印这  
个数。  
  
(message "Line %d"  
          (1+ (count-lines 1 (point))))  
  
这个 message 函数在 Emacs 屏幕底部输出一行消息。该函数的第一个参量是引号中  
的字符串。然而，这个字符串可以包含如"%d"、"%s"或者"%c"这样的控制符，以  
打印跟在字符串后面的参量。"%d"将后续的参量作为十进制数输出。因此这个消  
息将输出如“Line 243”这类的消息。  
  
代替"%d"而输出的数是由函数的最后一行计算得到的：  
  
(1+ (count-lines 1 (point)))  
  
这个表达式所做的工作，就是从缓冲区的开始位置（由 1 表示）计数，直到位点处  
(point)，并对最后的计数加 1。（1+函数就是对其参量加 1。）我们之所以加 1，  
是因为第 2 行只是在第 1 行前面 1 行。而且 count-lines 只对当前行前面的行数计  
数。）  
  
在 count-lines 求值完成时，消息输出在回显区，save-excursion 恢复位点和标记  
到它们原来的位置；而如果有变窄开启，save-restriction 则恢复变窄开启的原  
有标记。  
  
** 6.3 练习：变窄  
  
编写一个函数，这个函数在即使设置了变窄开启而使缓冲区的前一半不可见的情  
况下也能显示出当前缓冲区的头 60 个字符。要在显示完成之后恢复位点、标记和  
变窄开启等相关设置。对这个练习题，要使用 save-restriction、widen、  
goto-char、point-min、buffer-substring、message 和其他函数，真可以算得上  
是一个大杂烩！  
  
* 第 7 章 基本函数：car、cdr、cons  
  
cons construct
cdr Contents of the Address part of the Register
（寄存器地址部分的内容）短语的首字母缩写；而
cdr（读作"could-er"）是"Contents or the Decrement part or the  
Register" （寄存器后部内容）短语的首字母缩写。

** 7.1 car 和 cdr 函数  
  
 龙头龙身 书上说起这个名 first and rest 
(cdr '(rose violet daisy buttercup))  
  
(car '((lion tiger cheetah)  
        (gazelle antelope zebra)  
        (whale dolphin seal)))  
  
在这个例子中，列表的第一个元素（或者列表的 car）就是猛兽的列表，(lion  
tiger cheetah)。其余部分就是((gazelle antelope zebra)(whale dolphin  
seal))。  
  
(cdr '((lion tiger cheetah)   
        (gazelle antelope zebra)  
        (whale dolphin seal)))  
  
值得在此说明的是，car 和 cdr 函数都是“非破坏性”的——也就是说，它们不改变  
它们所作用的列表。这一点对于如何使用这两个函数非常重要。  
  
而且，在第 1 章中讨论原子时，曾经说过，在 Lisp 中，某些类型的原子（例如数  
组）能够被分割成几个部分；但是这种分割的机制与分割一个列表的机制是不同  
的。只要是论及 Lisp，列表中的原子就是不可分的。（参见 1.1.1 节，"Lisp 原子  
"。）car 和 cdr 函数用于分割一个列表，并且是 Lisp 的基本操作。因为它们不能分  
割一个数组或者对数组的一部分操作，所以一个数组被认为是一个原子。相反，  
另外一些基本的函数（例如 cons），能够组成或构建一个列表，但是不能构建一  
个数组。（数组是由与数组相关的函数来处理的。参见《GNU Emacs Lisp 技术手  
册》中的“数组”一节。）  
  
** 7.2 cons 函数  
  
(cons 'pine '(fir oak maple))  
(pine fir oak maple)  
  
cons 必须有一个待插入元素的列表（实际上，可以将一个元素 cons 进一个原子来  
生成一个带点的偶对。带点偶对的内容超过了本书的范围，详情请参考《GNU  
Emacs Lisp 技术手册》）。绝对不能从一无所有开始。如果正在创建一个列表，  
首先至少需要提供一个空列表。下面是一系列 cons 函数，它们构建了一个花的列  
表。如果你在 GNU Emacs 的 Info 中阅读这份文档，可以用通常的方法对下面的每一  
个表达式求值，表达式的值是打印在“=>”之后的文本，你可以将其读作“求值  
得”:  
  
(cons 'buttercup ())  
     => (buttercup)  
  
(cons 'daisy '(buttercup))  
     =>(daisy buttercup)  
  
(cons 'violet '(daisy buttercup))  
     =>(vioiet daisy buttercup)  
(cons 'rose '(violet daisy buttercup))  
     =>(rose violet daisy buttercup)  
*查询列表的长度：length 函数*  
  
通过使用 Lisp 的 length 函数，你能够找出一个列表中有多少元素。例如，  
  
  (length '(buttercup))  
          => 1   
  
  (length '(daisy buttercup))  
          => 2  
  
  (length (cons 'violet '(daisy buttercup)))  
          => 3   
  
在上面的第三个例子中，cons 函数被用于构建一个三元素列表，这个列表随后被  
传递给 length 函数作为其参量。  
  
也可以用 length 函数来计算空列表中元素的个数：  
  
  (length ())  
    =>0  
(length)  
  
Wrong number of arguments：#＜subr length>, 0  
  
错误消息中的“#<subr length>”是函数名。它是以一种特殊形式写出来的，  
"#subr"是指 length 函数是一个用 C 语言编写的、而不是用 Emacs Lisp 编写的基本  
函数。（"subr"是“subroutine" （子例程）一词的缩写。）更多关于子例程的资  
料，参见《GNU Emacs Lisp 技术手册》中的“什么是函数？”一节。  
  
** 7.3 nthcdr 函数  
  
nthcdr 函数与 cdr 函数联系在一起。它所做的就是重复地取列表的 cdr。  
  (cdr '(fir oak maple)  
       => (oak maple)  
  
  (cdr '(oak maple))  
      => (maple)  
  
  (cdr '(maple))  
      => nil   
  
  (cdr 'nil)  
      => nil  
  
  (cdr ())  
      => nil  
  
你也可以无需输出值而连续使用 cdr，就像这样：  
  
(cdr (cdr '(pine fir oak maple)))  

     => (oak maple)  
  
在这个例子中，Lisp 解释器首先对最内层的列表求值。最内层的列表带有引号，  
因此它仅仅将这个列表本身传递给 cdr。这个 cdr 将一个由原来列表的第二个元素  
以及其后的其他元素组成的列表传递给外部的 cdr。这个 cdr 则将产生由原始列表  
的第三个元素以及其后的其他元素组成的列表。在这个例子中，cdr 函数被重复使  
用，并返回一个由原始列表的除头两个元素之外的元素组成的列表。  
  
nthcdr 函数的功能就像重复调用 cdr 函数一样。在后续的例子中，参量 2 以及一个  
列表被传递给 nthcdr 函数，返回值是由原始列表中除头两个元素之外的元素组成  
的列表，这与重复两次使用 cdr 函数得到的结果完全一样：  
  
  (nthcdr 2 '(pine fir oak maple))  
          => (oak maple)  
  
使用 4 个元素的原始列表，可以看到当给 nthcdr 函数传递不同的数字参量时会发生  
什么情况，例子中使用的参量包括 0、1 和 5:  
  
;;留下列表全部。  
  
(nthcdr 0 '(pine fir oak maple))  
      => (pine fir oak maple)  
  
;;返回移去第一个元素的列表。  
  
(nthcdr 1 '(pine fir oak maple))  
     => (fir oak maPle)   
  
;;返回移去 3 个元素的列表。  
  
(nthcdr 3 '(pine fir oak maple))  
    => (maple)  
  
;;返回移去 4 个元素的列表。  
  
(nthcdr 4 '(pine fir oak maple))  
   =>nil   
  
;;返回一个移去所有元素的列表。  
  
(ntbcdr 5 '(pine fir oak maple))  
   =>nil  
  
值得一提的是，就像 cdr 函数一样，nthcdr 函数也不改变原始列表——这个函数是  

非破坏性的。这一点与 setcar 和 setcdr 函数截然不同。  
  
** 7.4 setcar 函数  
  
从函数的名字，你可能已经猜测到，setcar 和 setcdr 函数将一个列表的 car 和 cdr  
设置为一个新的值。不像 car 和 cdr 函数不改变原始列表，setcar 和 setcdr 这两个  
函数实际上改变了原始列表。了解它们如何工作的一个途径就是不断尝试。我们  
将从 setcar 函数开始。  
  
首先，构造一个列表并用 setq 函数将这个列表赋值给一个变量。下面是一个动物  
的列表：  
  
(setq animals '(giraffe antelope tiger lion))  
  
当对变量 animals 求值时，我们看到它被绑定到列表(girafre antelope tiger  
lion)上：  
  
 animals  
     => (giraffe antelope tiger lion)  
  
这也就是说，变量 animals 指向了列表(giraffe antelope tiger lion)。  
  
接下来，要给 setcar 函数设置两个参量，一个是变量 animals，一个是带引号的符  
号 hippopotamus；这是通过编写一个三元素列表(setcar animals  
'hippopotamus)并随后用通常的方法对它求值来完成的：  
  
  (setcar animals 'hippopotamus)  
  
对这个表达式求值之后，再对变量 animals 求值。你将会看到 animals 指向的列表  
已经改变了：  
  
animals  
 => (hippopotamus antelope tiger lion)  
  
这个列表的第一个元素 giraffe 已经被 hippopotamus 取代了。  
  
因此我们能够看到：setcar 函数不是像 cons 函数那样在列表中增加一个元素；它  
用新元素 hippopotamus 取代原来的元素 giraffe，它改变了列表。  
  
** 7.5 setcdr 函数  

  
setcdr 函数与函数 setcar 相似，不同之处仅在于这个函数替换列表的第二个以及  
其后的所有元素，而不是列表的第一个元素。  
  
为了了解这个函数是如何工作的，通过对下面的表达式求值来将驯养动物的列表  
赋值给一个变量：  
  
  (setq domesticated-animals '(horse cow sheep goat))  
  
如果现在对这个变量求值，将返回一个列表：  
  
domesticated-animals  
    =>(horse cow sheep goat)  
  
接下来，要给 setcdr 函数设置两个参量，一个是变量名(这个变量有一个列表作为  
其值),另一个参量是一个列表(它是第一个列表的 cdr 将被设置的值):  
  
(setcdr domesticated-animals '(cat dog))  
  
如果对这个表达式求值，列表(cat dog)将出现在回显区中。这就是这个函数的返  
回值。但是我们感兴趣的是这个函数的附带效果，对变量 domesticated-animals  
求值就可以看到这个附带效果：  
  
domesticated-animals  
       => (horse cat dog)  
  
的确，驯养动物的列表已经从(horse cow sheep goat)变成了(horse cat dog)。  
也就是说，列表的 cdr 已经从(cow sheep goat)变成了(cat dog)。  
  
* 第 8 章 剪切和存储文本  
kill yank clip
  
  ("a piece of text" "last piece")   
  
cons 函数能用于往这个列表中增加一段文本片断，就像这样：  
  
  (cons "another piece"   
       '("a piece of text" "last piece"))  
  
如果对这个表达式求值，则三个元素的列表将会出现在回显区中：  
  
  ("another piece" "a piece of text" "last piece")  
  
使用 car 和 nthcdr 函数，能从这个列表中将任何一个文本重新提取出来。例如，在  
下面的代码中，nthcdr 1... 返回由参量列表的第一个元素之外的所有元素组成  
的列表，car 函数则返回这个中间列表的第一个元素——也就是原始列表的第二个元  
素：  
  
(car (nthcdr 1  '("another piece"   
                  "a piece of text"  
                  "last piece")))  
          => "a piece of text"  
  
当然，Emacs 中实际的函数比这个例子更加复杂。必须编写剪切和找回文本的代  
码，以便 Emacs 能计算出列表中的那个元素是你所需要的——第一个、第二个、第三  
个……。除此之外，当你到达列表末尾时，Emacs 会重新回到第一个元素，而不是  
空元素。  
  
保存被剪切的一段文本的列表被称为 kill 环(kill ring)。这一章首先介绍这个  
kill 环，然后用 zap-to-char 函数这个例子来了解如何使用这个列表。  
zap-to-char 函数调用另外一个对 kill 环操作的函数，因而在介绍 zap-to-char 这  
个函数之前首先介绍那个函数，就像在攀登高峰之前，先爬小山。  
** 8.1 zap-to-char 函数  
在 Emacs 第 19 版中，交互的 zap-to-char 函数的功能就是：将光标当前位置(即位  
点)与出现特定字符的下一个位置之间这一区域中的文本剪切掉。zap-to-char 函  
数剪切的文本放在 kill 环中，并能通过键入 C-y (yank) 命令从 kill 环中找回这些  
文本。如果这个命令带有参量，它就将从位点处到特定字符出现了参量所示次数  
的那个位置之间这一区域内的文本剪切掉。因而，如果光标在这个句子[fn:6]的  
开头，而指定字符是"s"，则“Thus”一词将被剪切。如果给定的参量是 2,  
"Thus, if the curs"将被剪切，即从位点到第二次出现指定字符"s"之间的文本  
(包含“cursor”中的指定字符"s")被剪切了。  
  
Emacs 第 18 版中，这个函数将位点到指定字符区域之间的文本(但不包含指定字符)剪  
切。因而，在上面的例子中，字符“s”就不被剪切。  
  
除此之外，在第 18 版中，如果没有找到指定字符，则将位点直到缓冲区末尾整个  
区域内的文本全部剪切；但是在第 19 版中，如果发生这种情况则仅仅产生一个错  
误消息(不剪切任何文本)。  
  
为了决定究竟有多少文本被剪切，两个版本的 zap-to-char 函数都使用了一个查询  
函数。查询函数在操纵文本的代码中广泛使用，关注查询函数与关注删除命令一  
样，都是值得的。  
  
这是第 19 版中 zap-to-char 函数的完整代码：  
  
(defun zap-to-char (arg char) ;version 19 implementation  
  "Kill up to and including ARG'th occurrence of CHAR.  
 Goes backward if ARG is negative;error if CHAR not found."  
   (interactive "*p\ncZap to char:")  
   (kill-region (point)  
            (progn   
          (search-forward  
           (char-to-string char) nil nil arg)  
          (point))))  
  
*** 8.1.1 interactive 表达式  
  
zap-to-char 函数中的交互(interactive)表达式如下所示：  
  
  (interactive "*p\ncZap to char:")  
  
括号中的部分"*p\ncZap to char:"，指定了三件事情。第一，也是最简单的，即  
星号“*”，它意味着，如果缓冲区是只读的，就产生一个错误信号。这就是说，  
如果你试图在一个只读缓冲区中使用 zap-to-char 函数，你将无法剪切任何文本，  
并且你将收到一个这样的消息："Buffer is read-on1y"，你的终端还可能会对着  
你鸣叫报警。  
  

----------------------- Page 85-----------------------

"*p\ncZap to char:"的第二部分是字符“p”。这部分以一个换行符"\n"结束。  
小写“p”是指传送给函数的第一个参量将是一个处理过的前缀参量的值。前缀参  
量用 C-u 以及其后的一个数来传送，或者用 M-和一个数来传送。如果不带前缀参量  
交互地调用这个函数，默认值 1 将被传送给这个函数。  
  
"*p\ncZap to char:"的第三部分是“cZap to char:”。在这一部分中，小写  
"c"是指交互表达式希望产生一个提示并且后续的参量将是一个字符。提示信息是  
跟在"c"之后的字符串“Zap to char: ”。(冒号后面带一个空格会使提示信息更  
好看。)  
  
所有这些，都是为 zap-to-char 函数准备参量。至此，这些参量都有了正确的类  
型，并显示给用户一个提示信息。  
  
*** 8.1.2 zap-to-char 函数体  
  
zap-to-char 函数体包含了从光标的当前位置(即位点)直到(并包含)指定字符这一  
区域剪切文本的代码。代码的第一个部分如下所示：  
  
  (kill-region (point)...  
  
(point)就是光标所处的当前位置，即位点。  
  
代码的下一个部分是一个使用 progn 的表达式。progn 表达式的主体由  
search-forward 和 point 函数组成。学习了 search-forward 函数之后，就容易理解  
progn 是如何工作的了。因此我们将先学习 search-forward 函数，然后再学习  
proqn 函数。  
  
*** 8.1.3 search-forward 函数  
  
search-forward 函数是用于定位 zap-to-char 函数中被截取的字符的。如果查询成  
功，search-forward 函数就在目标字符串中最后一个字符处设置位点(在这个例子  
中，目标字符串只有一个字符)。如果查询是朝后进行的，search-forward 函数就  
在目标字符串的第一个字符处设置位点。同样，search-forward 函数返回 t 值表示  
查询成功。(移动位点只是这个函数的附带效果。)  
  
在 zap-to-char 函数中，search-forward 函数如下所示：   
  
(search-forward (char-to-string char) nil nil arg)  
  
search-forward 函数有 4 个参量:   
  
1) 第一个参量是目标，就是所要查找的内容。这个参量必须是一个字符串，如  
"z"。  
  

----------------------- Page 86-----------------------

执行时，传送给 zap-to-char 函数的参量是一个单字符。由于计算机本身工作原理  
的限制，Lisp 解释器认为单个字符与一个字符串是不同的。在计算机内部，单个  
字符与一个仅仅包含单个字符的字符串有不同的存储格式(单个字符能用一个字节  
精确地记录，但是一个字符串可能很长也可能很短，计算机需要为此做准备)。因  
为 search-forward 函数是查询一个字符串的，所以 zap-to-char 函数接收的、作为  
其参量的字符，必须在计算机内从一种格式转换成另外一种格式，否则  
search-forward 函数将会无法工作。char-to-string 函数就是用于完成这种转换  
工作。  
  
2) 第二个参量绑定查询范围；它被指定为缓冲区中的某个位置。在这个例子中，  
查询能到达缓冲区末尾，因此没有设置任何绑定，第二个参量就是空(nil)。  
  
3) 第三个参量告诉这个函数如果查询失败应该怎么办——可以发出一个出错信号  
(并打印一条消息)，也可以返回空值(nil)。如果第三个参量被设置成空(nil)，  
就是告诉这个函数如果查询失败就发出一个出错信号。  
  
4) 第四个参量是重复计数值——待查找字符串出现的次数的计数。这个参量是可选  
的，如果在调用这个函数时没有给定计数值，就使用默认值 1。如果这个参量是一  
个负数，查询就朝后进行。  
  
用一个模板形式来分析的话，search-forward 函数就是这样：  
  
  (search-forward "target-string"  
                 limit-of-search  
                 what-to-do-if-search-fails  
                 repeat-count)  
  
下面我们将学习 progn 函数。  
  
*** 8.1.4 progn 函数  
  
progn 函数使其每一个参量被逐一求值并返回最后一个参量的值。前面若干表达式  
的求值，仅仅是作为函数的附带效果，这些值被统统扔掉了。  
  
progn 表达式的模板很简单：  
  
  (progn   
    body...)  
  
在 zap-to-char 函数中，progn 表达式要完成两件事情：在正确的位置设置位点，  
将位点返回以使 kill-region 函数知道要剪切到什么地方。  
  
progn 表达式的第一个参量就是 search-rorward。当 search-forward 函数在文本中  
找到目标字符串时，它就在文本中的目标字符串最后一个字符处设置位点(在这个  

----------------------- Page 87-----------------------

例子中目标字符串只有单个字符)。如果查询是朝后进行的，search-forward 函数  
就在目标字符串的第一个字符处设置位点。位点的设置和变动也只是这个函数的  
附带效果。  
  
progn 表达式的第二个也是最后一个参量是表达式(point)。这个表达式返回位点  
的值，在这种情况下就是由 search-forward 函数移动过的位点的值。这个值由  
progn 表达式返回，并传递给 kill-region 函数作为其第二个参量。  
  
*** 8.1.5 总结 zap-to-char 函数  
  
现在已经了解了 search-forward 函数和 progn 函数是如何工作的了，因此也就能  
分析 zap-to-char 函数是如何工作的了。  
  
当 zap-to-char 函数被调用时，给 kill-region 的第一个参量是光标所在的位置，  
也就是当时位点的值。在 progn 表达式内部，search-forward 函数将位点移动到查  
找到的字符后，(point)表达式则返回位点的值。kill-region 函数将这两个值结  
合起来，第一个值作为要剪切部分的开始，第二个值作为要剪切部分的末尾，然  
后将这个区域内的文本剪切掉。  
  
progn 函数是需要的，因为 kill-region 命令需要两个参量。如果 search-forward  
函数和(point)表达式作为它另外两个参量，它将运行失败。progn 表达式是  
kill-region 命令的一个参量而不是两个，它的返回值正是 kill-region 命令需要  
的第二个参量。  
  
*** 8.1.6 第 18 版中 zap-to-char 函数的实现方法  
  
在第 18 版中，zap-to-char 函数的实现方法与第 19 版中这个函数的实现方法稍有不  
同：它剪切的文本不包含指定字符；并且当没找有到指定字符时就剪切到缓冲区  
末尾。  
  
产生这种不同的原因在于 kill-region 命令的第二个参量。这个参量在第 19 版中是  
这样的：  
  
  (progn  
     (search-forward (char-to-string char) nil nil arg)  
     (point))  
  
而在第 18 版中，则是下面这个样子的：   
  
(if (search-forward (char-to-string char) nil t arg)  
     (progn (goto-char  
            (if (> arg 0) (1-  (point))(1+ (point))))  
            (point))  
     (if (> arg 0)  

----------------------- Page 88-----------------------

         (point-max)  
    (point-min)))  
  
这部分代码看起来相当复杂，但是如果将其一部分一部分分解开来分析，就容易  
理解了。  
  
代码的第一部分是：  
  
  (if (search-forward (char-to-string char) nil t arg)  
  
用 if 表达式模板来分析，就是：  
  
  (if able-to-locate-zapped-for-character-and-move-point-to-it  
     then-move-point-to-the-exact-spot-and-return-this-location  
     else-move-to-end-of-buffer-and-return-that-location)  
  
对这个 if 表达式的求值，就给出了 kill-region 函数的第二个参量。因为它的第一  
个参量是位点，因此这个过程使 kill-region 函数可以将位点和指定字符之间的文  
本全部剪切掉。  
  
我们已经描述了 search-forward 函数如何将移动位点作为它的附带效果完成的这  
一过程。在这个函数中，如果查找成功，search-forward 函数的返回值就是 t。否  
则，根据 search-forward 函数的第三个参量的不同，它要么返回 nil 值，要么产生  
一个错误消息。在这个例子中，t 是它的第三个参量，这使得 search-forward 函数  
在查找失败时返回 nil 值。就像我们将要看到的，可以容易地编写代码来处理函数  
返回 nil 值的这种情况。  
  
在第 18 版的 zap-to-char 函数的实现中，if 表达式将查询表达式作为其真假测试表  
达式。如果查询成功，Emacs 就对 if 表达式的 then 部求值；另一方面，如果查询失  
败，Emacs 就对 if 表达式的 else 部求值。  
  
在 if 表达式中，当查询成功时，progn 表达式被执行——也就是说，它就像一个程序  
一样被运行。  
  
前面已经讲过，progn 是一个函数，它使其中的参量逐一被求值，并返回最后一个  
参量的值。前面的其他表达式仅仅作为附带效果而被求值。它们产生的值被统统  
扔掉了。  
  
在这个版本的 zap-to-char 中，当查询函数 search-forward 找到它要查询的字符  
时，progn 表达式就被执行。这个 progn 表达式要完成两件事情：在正确的位置设  
置位点，返回位点的值以使 kill-region 知道要剪切到何处。  
  
之所以需要 progn 表达式中的代码，是因为当 search-forward 函数找到指定字符串  
时，它就在目标字符串的最后一个字符后设置位点(在这个例子中，目标字符串只  

----------------------- Page 89-----------------------

有一个字符)。如果是朝后查询的，则在目标字符串的第一个字符处前设置位点。  
  
然而，这个版本的 zap-to-char 函数并不剪切最后匹配的字符。例如，如果  
zap-to-char 函数要剪切直到“z”的所有文本，实际上它并不剪切“z”字符。因  
此，位点要仅仅移动到匹配字符不被剪切的位置。  
  
*** 8.1.7 progn 表达式主体  
  
progn 表达式的主体包含两个表达式。若要展开来详细描绘两个版本中 progn 表达  
式的不同之处，并加上注释，这个版本的 progn 表达式如下所示：  
  
  (progn  
    (goto-char        ;First expression in progn.  
     (if(> arg 0)     ;If arg is positive,  
    (1-  (point)) ; move back one character;  
       (1+ (point)))) ; else move forward one character.  
  
    (point)           ;Second expression in progn:  
                      ; return position of point.  
  
这个 progn 表达式是这样工作的：当查询是朝前进行的(arg 是正值),Emacs 就在查  
找到的字符后面设置位点。通过将位点向后移动一个位置，查找到的字符就不被  
剪切。在这个例子中，progn 表达式应变成这样：(goto-char (1-  (point)))。  
这个表达式将位点后移一个字符(1-函数从其参量中减 1，就像 1+函数往其参量中  
加 1 一样)。另一方面，如果传递给 zap-to-char 函数的参量是负数，查询就是朝后  
进行的。if 表达式检查到这一点，因此表达式实际上就成了:(goto-char (1+  
(point)))。(1+函数往其参量中加 1。)  
  
progn 表达式的第二个也是最后一个参量是表达式(point)。这个表达式返回由  
progn 表达式的第一个参量决定的位点的值。然后，if 表达式返回这个值。if 表达  
式是 kill-region 表达式的一部分，并将 if 表达式的这个返回值传递给  
kill-region 表达式作为它的第二个参量。  
  
简要地说，这个函数的工作方式就是：kill-region 的第一个参量是当  
zap-to-char 命令执行时光标所在的位置——也就是那个时候位点的值。然后，如果  
查询成功，查询函数将位点移动。progn 表达式将位点移动到匹配字符串刚好不被  
剪切的位置，并返回这时位点的值。最后，kill-region 函数剪切这段区域内的  
文本。  
  
最后，if 表达式中的 else 部处理目标字符串没有被查到的情况。如果  
zap-to-char 函数的参量是正的(或者没有给出)而且查询失败，则当前位点到缓冲  
区可见区域末尾的所有文本都将被剪切。(如果没有设置变窄开启，就是从当前位  
点到整个缓冲区末尾的所有文本都将被剪切。)如果 arg 是负的，而又没有查找到  
目标字符串，则从当前位点到缓冲区可见区域开始处的文本都将被剪切。完成这  

----------------------- Page 90-----------------------

些工作的代码是一个简单的 if 表达式：  
  
  (if (>arg 0) (point-max)(point-min))  
  
这就是说，如果 arg 是一个正数，返回 point-max 的值；否则，返回 point-min 的值。  
回顾起来．下面是包含 kill-region 表达式的代码(带有注释):  
  
  (ki11-region   
    (point)                     ;beginning-of-region  
    (if (search-forward  
         (char-to-string char)  ;target  
         nil                   ;limit-of-search:none  
         t                     ;Rettlrn nil if fail.  
         arg)                  ;repeat-count.  
  
        (progn                  ;then-part  
           (goto-char  
             (if (> arg 0)  
                 (1-  (point))  
                 (1+ (point))))  
           (point))  
  
       (if (> arg 0)        ;else-part  
               (point-max)  
               (point-min))))  
  
通过比较你可以看到：第 19 版中 zap-to-char 函数的实现代码比第 18 版中该函数的  
实现代码少一些，但是更简洁。  
  
** 8.2 kill-region 函数  
  
zap-to-char 函数使用了 kill-region 函数。这个 kill-region 函数很简单，就是删  
去文档字符串的一部分。其代码如下：  
  
(defun kill-region (beg end)   
  "kill between point and mark.  
  The text is deleted but saved in the kill ring."  
   (interactive "*r")  
   (copy-region-as-kill beg end)  
   (delete-region beg end))  
  
一个要特别注意的地方是，这个函数使用了 delete-region 和  
copy-region-as-kill 函数。这些函数将在接下来的章节描述。  
  

----------------------- Page 91-----------------------

** 8.3 delete-region 函数：接触 C  
  
zap-to-char 命令使用了 kill-region 函数，而 kill-region 函数又使用了两个其他  
的函数：copy-region-as-kill 和 delete-region。copy-region-as-kill 函数将在  
随后小节中描述，它的作用是将某个区域中的文本复制一份到 kill 环中，因此这  
份文本可以重新找回来。(参见 8.5 节“copy-region-as-kill 函数”。)  
  
delete-region 函数删除一个区域中的内容，而且你无法找回它。  
  
不像在这里讨论的其他函数，delete-region 函数不是用 Emacs Lisp 编写的，它是  
用 C 语言编写的，并且是 GNU Emacs 系统的一个基本函数。因为它非常简单，所以  
我就从 Lisp 中岔开来讲讲这个 C 语言函数。  
  
就像许多其他的 Emacs 基本函数一样，delete-region 是作为一个 C 语言宏的实例来  
被编写的，一个宏就是一个代码模板。这个宏的第一个部分如下所示：  
  
 DEFUN ("delet-region", Fdelete_region, Sdelete_region, 2, 2, "r",  
    "Delete the text between point and mark.\n\n  
    When called from a program, expects two arguments,\n\  
    character numbers specifying the stretch to be deleted.")  
  
在没有深入到这个宏编写过程的细节之前，首先要指出的是这个宏是以 DEFUN 开始  
的。之所以选择 DEFUN 这个词，是因为它完成 Lisp 中 defun 相同的事情。DEFUN 一词  
后面的括号内跟着七个部分：  
  
- 第一个部分是 Lisp 中的函数名，在这个例子中就是 delete-region。  
  
- 第二部分是 C 语言中的函数名，即 Fdelete_region。习惯上，它以“F”开头。  
  因为 C 语言中函数名不使用连字符，所以使用下划线。  
  
- 第三部分是 C 常数结构名，这些常数结构在函数内部记录信息。它是 C 语言中的  
  函数名，但是它以字符“S”开头而不是以“F”开头。  
  
- 第四和第五部分指定了函数中允许的参量数目的最小值和最大值。在这个例子  
  中，这个函数需要两个参量。  
  
- 第六部分就像 Lisp 的一个函数中跟在 interactive 说明之后的参量那样：要么是  
  一个字符，要么是一个提示信息。在这个例子中，字符是“r"，它是指函数的  
  两个参量将是一个缓冲区中某个区域的开始和结束的位置。在这段代码中，没  
  有提示信息。  
  
- 第七部分是文档字符串。除了每一个换行符都必须显式地写成“\n”的形式  
  外，它与 Emacs Lisp 中编写的函数的文档就没有别的不同之处了。  
  

----------------------- Page 92-----------------------

随后就是正式的参数(每个参数都有对这个参数的类型进行说明的语句)，然后就  
是这个宏的主体部分。对 delete-region 函数而言，这个宏的主体包含了如下三行：  
  
validate_region (&b, &e);  
del_range (XINT (b), XINT (e));  
return Qnil;  
  
其中的第一个函数 validate_region 检查传递来的值的类型，判断它们作为缓冲区  
中一个区域的开始和结束值是否正确，是否在正确的范围之内。第二个函数  
del_range 实际上真正完成删除文本的功能。如果这个函数正确地删除了文本，则  
第三行中的函数返回 Qnil 来表示它已经顺利完成了删除任务。  
  
del_range 函数是一个复杂的函数，在此不再继续深入研究。它的作用是更新缓冲  
区并完成一些其他的事情。然而，看看传递给它的两个参量还是值得的。这两个  
参量是 XINT(b)和 XINT(e)。在 C 语言中，b 和 e(代表的)是两个 32 位的整数，它们记  
录要删除的区域的开始和结束的位置。但是就像 Emacs Lisp 中的其他数一样，32  
位中只有 24 位是用于存放实际的数值，剩下的 8 位用于跟踪这些数的类型和其他信  
息。(在某些机器中，只有 6 位能用于这种目的。)在这个例子中，8 位用于指出这  
些数是指缓冲区中的位置。当一个数中的某些位用于这样的目的时，这就被称作  
一个标签(tag)。在 32 位数据中使用 8 位标签使得这样编写 Emacs 代码的速度比用其  
他方式编写代码的速度更快。另一方面，由于实际数字只占用了 24 位，因此  
Emacs 缓冲区近似地限制在 8MB。(通过在编译前在“emacs/src/config.h”中定义  
VALBITS 和 GCTYPEBITS，你就可以增加缓冲区的最大容量。参见 Emacs 发行版本中  
的"emacs/etc/FAQ"文件中的注释。)  
  
"XINT"是一个 C 语言宏 ，它从 32 位的 Emacs 对象中提取 24 位，用于其他目的的 8 位  
就被扔掉了。因此，del_range(XINT(b),XINT(e))删除以“b”开始以“e”结束  
的区域中的内容。  
  
从开发 Lisp 的人员的角度来看，Emacs 是相当简单的；但是隐藏在其中的内容却非  
常复杂玄妙。  
  
** 8.4 用 defvar 初始化变量  
  
不像 delete_region 函数是用 C 语言编写的，copy-region-as-kill 函数是用 Emacs  
Lisp 编写的。这个函数的功能就是拷贝缓冲区中的一个区域并将其保存到被称为  
kill-ring 的变量中。这一节就描述这个变量如何被创建和如何被初始化。  
  
(再一次提醒你，kill-ring 这个术语确属于用词不当。从缓冲区中剪切出去的文  
本能够被找回来。它不是尸体之环，而是一个可以复活的文本环。)  
  
在 Emacs Lisp 中，一个变量(如 kill-ring)是通过使用 defvar 特殊表而被创建和赋  
初值的。这个特殊表的名字来源于“define variable”(定义变量之意)。  
  

----------------------- Page 93-----------------------

defvar 特殊表与给一个变量赋值的 setq 函数相似。它和 setq 有两个不同之处。第  
一，它只对无值的变量赋值。如果变量已经有一个值，defvar 特殊表就不会覆盖  
已经存在的值。第二，defvar 特殊表有一个文档字符串。  
  
可以用 describe-variable 函数查看任何一个变量的当前值，describe-variable  
这个函数常常通过键入 C-h v 来激活。如果键入 C-h v，然后在提示下输入  
kill-ring(并回车)，将看到当前的 kill 环中的内容——可能是相当多的。相反，如  
果在这个 Emacs 进程中除了阅读之外什么也没有做，你可能什么也看不到。在  
 “*Help*”缓冲区的末尾，将看到 kill-ring 的文档：  
  
Documentation:  
List of killed text sequences.  
  
kill 环是用下面的方式由 defvar 定义的：  
  
  (defvar kill-ring nil   
   "List of killed text sequences.")  
  
在这个变量定义中，变量被初始化为 nil，这是有意义的，因为如果你什么也没有  
保存，当你用 yank 命令时就无需返回任何东西。文档字符串就像 defun 中的文档字  
符串一样被编写。至于 defun 定义中的文档字符串，其第一行应当是一个完整的句  
子，因为有些命令(如 apropos)仅仅打印其中的第一行。后续的行不应缩排；否则  
当你使用 C-h v(describe-variable)时它们看起来很奇怪。  
  
绝大多数变量是 Emacs 的内部变量，但是有一些是可以用 edit-options 命令方便地  
设置的。(这些设置仅仅在一个编辑过程中有效；要永久地设置一个值，可以编写  
一个“.emacs"文件。参见第 16 章，“配置你的‘.emacs’文件”。)  
  
一个可以重新设置的变量，是用文档字符串的第一行前面加上星号“*”来使之与  
Emacs 中的其他变量区别开来。  
  
例如：  
  
(defvar line-number-mode nil  
  “*Non-nil means display line number in mode line.”)  
  
这意味着你能够使用 edit-options 命令来改变 line-number-mode 变量的值。  
  
当然，你也能够在一个 setq 表达式当中对 line-number-mode 变量求值来改变这个  
变量的值。  
  
(setq line-number-mode t)  
  
参见 1.9.2 节，“使用 setq 函数”。  

----------------------- Page 94-----------------------

  
** 8.5 copy-region-as-kill 函数  
  
copy-region-as-kill 函数拷贝缓冲区中的一个文本区域，并将其保存到  
kill-ring 变量中。  
  
如果在调用 kill-region 命令后马上调用 copy-region-as-kill 函数，Emacs 将会把  
这个新拷贝的文本追加到原来拷贝的文本后。这意味着如果要找回文本，你将得  
到所有的内容(包括原来拷贝的内容和新拷贝的内容)，另外，如果在调用  
copy-region-as-kill 函数之前有其他命令，这个函数就将文本拷贝到 kill 环的另  
外一个入口。  
  
下面是第 18 版中的 copy-region-as-kill 函数的全部代码，在此增加了几个注释以  
使格式更清楚：  
  
(defun copy-region-as-kill (beg end)  
  "Save the region as if killed, but don't kill it."  
   (interactive "r")  
  
   (if (eq last-command 'kill-region)  
       ;;then-part: Combine newly copied text  
       ;; with previously copied text.  
       (kill-append (buffer-substring beg end) (< end beg))  
    ;; else-part: Add newly copied text as a new element  
    ;;   to the kill ring and shorten the kill ring if necessary.  
     (setq kill-ring  
           (cons (buffer-substring beg end) kill-ring))  
     (if (> (length kill-ring) kill-ring-max)  
         (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))  
    
    (setq this-command 'kill-region)  
    (setq kill-ring-yank-pointer kill-ring))  
  
像通常一样，这个函数能被分成几个组成部分：  
  
(defun copy-region-as-kill (argument-list)  
  "documentation..."  
   (interactive "r")  
  body...)  
  
从这里可以清楚地看到，函数的参量是 beg 和 end，并且函数是交互的，带有“r”  
参数。因此函数的两个参量必须指向一个区域的开始和结束位置。如果你是从头  
阅读这份文档，理解这几部分几乎就像是例行公事一样简单。  
  

----------------------- Page 95-----------------------

除非你记得"kill"一词与它的原意有一定的差别，否则函数的文档会使你有些糊  
涂。  
  
函数体开始于一个 if 从句。这个从句所做的工作就是判别两种不同情况：这个命  
令是否是在前面一个 kill-region 函数后面立即执行的。如果是，则新拷贝的文本  
被追加到原来拷贝的文本后。否则，就作为一个与原来的文本分开的单独文本插  
入 kill 环的开头。  
  
函数的最后两行是两个 setq 表达式。其中一个表达式将变量 this-command 设置为  
kill-region，另外一个表达式将变量 kill-ring-yank-pointer 指向 kill 环。  
  
copy-region-as-kill 函数体将在下面详细讨论。  
  
copy-region-as-kill 函数体  
  
编写 copy-region-as-kill 函数是为了使在一行中两次或者多次剪切的文本最终将  
重新组合到 kill 环的同一个入口。如果要从 kill 环找回文本，则会得到整个文本。  
而且，如果是从当前光标处朝前剪切文本，则剪切掉的文本将加到原来剪切文本  
的末尾处；如果是从当前光标处朝后剪切文本，则剪切掉的文本将加到原来剪切  
文本的开始处。这就是说，kill 环中的文字仍然是以正常的次序存放的。  
  
copy-region-as-kill 函数使用了两个变量存放当前和之前的一个 Emacs 命令。这  
两个变量是 this-command 和 last-command。  
  
正常情况下，每当一个函数执行时，Emacs 将 this-command 变量设置为正被执行的  
函数(在这个例子中就是 copy-region-as-kill)。同时，Emacs 将变量  
last-command 设置为变量 this-command 原来的值。然而，copy-region-as-kill 命  
令就不同，它将 this-command 变量设置成 kill-region，这是调用  
copy-region-as-kill 的函数名。  
  
在 copy-region-as-kill 函数体的第一部分，if 表达式判定 last-command 变量的值  
是否是 kill-region。如果是，这个表达式的 then 部被求值，它使用 kill-append  
函数将拷贝的文本追加到 kill 环中第一个元素的文本之后。另一方面，如果变量  
last-command 的值不是 kill-region, copy-region-as-kill 函数在 kill 环中加入  
一个新的元素。  
  
这个 if 表达式如下所示，它使用了一个我们未曾看到过的 eq 函数：  
  
(if (eq last-command 'kill-region)  
   ;;then-part  
     (kill-append (buffer-substring beg end)(< end beg))  
  
eq 函数测试其第一个参量是否与其第二个参量是同一个 Lisp 对象。eq 函数与  
equal 函数类似，它们在用于测试是否相等方面是一样的；但是，它们在判定不同  

----------------------- Page 96-----------------------

名的两种表示所对应的 Lisp 对象是否是计算机中的同一个对象时是不同的。  
equal 函数判定两个表达式的结构和内容是否完全等同。  
  
1. kill-append 函数  
  
kill-append 函数如下所示：   
  
(defun kill-append (string before-p)  
     (setcar kill-ring  
            (if before-p  
                 (concat string (car kill-ring))  
                 (concat (car kill-ring) string))))  
  
可以一部分一部分地分析这个函数。其中，setcar 函数使用 concat 函数将新的文  
本追加到 kill 环的 car 中(即第一个元素)。它是否追加或者前插文本依赖于 if 表达  
式的结果：  
  
  (if before-p                        ;if-part  
      (concat string (car kill-ring)) ;then-part  
     (concat (car kill-ring) string)) ;else-part  
  
如果被剪切的文本是在最近一个命令剪切的文本之前，则这些文本应被插入到原  
来 kill 环中保存的内容之前。反过来，如果被剪切的文本是在最近被剪切的文本  
之后，则它应当被追加到原来那些文本之后。if 表达式依赖于 before-p 的判断来  
决定是否应将新保存的文本放在原来保存的文本之前还是之后。  
  
符号 before-p 是 kill-append 函数的另外一个参量的名字。当 kill-append 函数被  
求值时，这个符号绑定到实际参量被求值后返回的值。在这个例子中，这就是表  
达式(< end beg)。这个表达式并不直接决定剪切的文本是插入到前一个命令剪切  
的文本之前，还是追加到该文本之后。这个表达式所做的工作就是判定变量 end 的  
值是否小于变量 beg 的值。如果是，则说明用户希望朝缓冲区开头剪切。同样地，  
如果对这个表达式求值的结果为“真”，则被剪切的文本将被插入到原来文本之  
前。另一方面，如果变量 end 的值大于变量 beg 的值，被剪切的文本就被追加到原  
来文本之后。  
  
当新保存的文本要被插入到原有文本之前时，带新文本的字符串将被连接到老文  
本之前：  
  
(concat string (car kill-ring))  
  
但是，如果文本是被追加，则它将被连接到老文本之后：  
  
(concat (car kill-ring) string)  
  

----------------------- Page 97-----------------------

为了理解这是如何实现的，首先需要回顾一下 concat 函数。concat 函数将两个文  
本字符串连接在一起，其结果是一个字符串。例如：  
  
(concat "abc" "def")  
   => "abcdef"  
  
(concat "new "  
        (car '("first element" "second element")))  
   => "new first element"  
  
(concat (car  
       '("first element" "second element")) " modified")  
   => "first element modified"  
  
现在，我们能够来关注 kill-append 函数：它改变了 kill 环中的内容。kill 环是一  
个列表，其中的每一个元素都是保存的文本。setcar 函数实际上改变这个列表的  
第一个元素。它是通过使用 concat 函数将最新保存的文本连接到 kill 环的第一个  
元素来取代原来的第一个元素来实现的。最新保存的文本放在老文本之前或者之  
后，这依赖于在缓冲区中它是在原有文本之前还是之后。连接后的元素，成为  
kill 环新的第一个元素。  
  
顺便说一说，下面就是我的 kill 环开始处的内容：  
  
  ("concatenating together" "saved text" "element" ...  
  
2. copy-region-as-kill 函数中的 else 部  
  
现在，回到 copy-region-as-kill 函数的解释：  
  
如果最后一个命令不是 kill-region，则函数不是调用 kill-append，而是调用下  
面代码中的 else 部：  
  
(if true-or-false-test  
    what-is-done-if-test-returns-true  
   ;; else-part  
   (setq kill-ring  
         (cons (buffer-substring beg end) kill-ring))  
   (if (> (length kill-ring) kill-ring-max)  
       (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))  
  
else 部中的 setq 这一行，将在 kill 环上追加被剪切的字符串，并将这个新值赋给  
kill 环。  
  
用一个小例子就可以看到它是如何运作的：  

----------------------- Page 98-----------------------

  
(setq example-list '("here is a clause" "another clause"))  
  
键入 C-x C-e 对这个表达式求值后，可以对 example-list 求值并查看它所返回的值：  
  
example-list  
   => ("here is a clause" "another clause")  
  
现在，通过对下面的表达式求值，就能够往这个列表中增加一个新的元素：  
  
(setq example-list (cons "a third clause" example-list))  
  
当对 example-list 求值时，将发现它的值是：  
  
example-list  
  => ("a third clause" "here is a clause" "another clause")  
  
因而，通过 cons 函数，第三个元素增加到了 example-list 列表中。  
  
除了用 buffer-substring 截取剪切区域中的文本之外，这个例子与在  
copy-region-as-kill 函数中使用 setq 和 cons 函数的情况非常相似。这个语句重新  
写在下面：  
  
(setq kill-ring (cons (buffer-substring beg end) kill-ring))   
  
copy-region-as-kill 函数中 else 部的下一段是另外一个 if 表达式。这个 if 表达式  
使 kill 环不致于过长。它是这样的：  
  
(if (> (length kill-ring) kill-ring-max)  
     (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))  
  
这部分代码检查 kill 环的长度是否大于最大允许的长度。最大允许长度就是  
kill-ring-max 的值(默认的情况下是 30)。如果 kill 环的长度太长，这部分代码将  
kill 环的最后一个元素设置为 nil。这是通过使用 setcdr 和 nthcdr 函数来实现的。  
  
我们首先来看看 setcdr 函数(参见 7.5 节“setcdr 函数”)。这个函数设置一个列表  
的 cdr，就像 setcar 函数设置一个列表的 car 一样。然而在这个例子中，setcdr 并  
不是设置整个 kill 环列表的 cdr；nthcdr 函数用于设置 kill 环的第二个元素到最后  
一个元素这个列表的 cdr——这意味着，如果第二个元素到最后一个元素的 cdr 是  
kill 环的最后一个元素，它将设置 kill 环的最后一个元素。  
  
nthcdr 函数反复地取一个列表的 cdr——即它取一个列表的 cdr 的 cdr 的 cdr……这样  
重复 N 次，并返回最后的结果。  
  

----------------------- Page 99-----------------------

因此，如果现有一个 4 元素的列表，而假设只能有 3 个元素，则需要设置第二个元  
素到最后一个元素的 cdr 为最后一个元素并赋 nil 值，从而缩短列表的长度。  
  
依次对下面三个表达式求值就可以看到这一点。首先将变量 trees 的值设置为  
(maple oak pine birch)，然后设置其第二次 cdr 的 cdr 为 nil，然后求 trees 变量  
的值：  
  
  
  (setq trees '(maple oak pine birch))  
        => (maple oak pine birch)  
  
  (setcdr (nthcdr 2 trees) nil)  
        => nil  
  
 trees  
        => (maple oak pine)  
      
(由 setcdr 表达式返回的值是 nil，因为这就是 cdr 设置的值。)  
  
再重复一下，在 copy-region-as-kill 函数中，nthcdr 函数重复取若干次的 cdr,其  
次数是 kill 环的最大允许长度减 1，并将那个元素的 cdr(其实这就是列表的最后一  
个元素)设置为 nil。这就可以避免 kill 环无限制地增长。  
  
copy-region-as-kill 函数的倒数第二行是：   
  
(setq this-command 'kill-region)  
  
这一行代码既不属于内层 if 表达式，也不属于外层 if 表达式，因此每当  
copy-region-as-kill 函数被调用一次，这个表达式就被求值一次。在这里，我们  
发现此处 this-command 变量被赋值为 kill-region。就像前面看到的，当执行下一  
个命令时，变量 last-command 将被赋为这个值。  
  
最后，copy-region-as-kill 函数的最末一行是：  
  
(setq kill-ring-yank-pointer kill-ring)  
  
变量 kill-ring-yank-pointer 是一个全局变量，它被设置为 kill-ring。  
  
虽然 kill-ring-yank-pointer 变量被称为“pointer"(指针)，但是它仅仅是一个  
像 kill 环这样的列表变量。然而，选择这样的名字是为了帮助人们理解如何使用  
这个变量。像 yank 和 yank-pop 这样的函数常使用这个变量(参见第 10 章，“找回文  
本”)。  
  
yank 这些函数使我们将已经剪切的文本重新找回来。然而，在讨论 yank 命令之  

----------------------- Page 100-----------------------

前，最好先学习列表是如何在计算机中实现的。这可以使像术语“指针”的使用  
这样神秘的内容变得清楚易懂。  
  
** 8.6 回顾  
  
下面是本章已经介绍过的一些函数的简单小结。  
  
- cdr、car  
  
   car 返回一个列表的第一个元素，cdr 则返回列表的第二个元素直到最后一个元  
   素的列表。  
  
   例如，  
  
    (car '(1 2 3 4 5 6 7))  
         => 1   
  
    (cdr '(1 2 3 4 5 6 7))  
         => (2 3 4 5 6 7)   
  
-  cons  
  
   这个函数通过将它的第一个参量插入到它的第二个参量中来构造一个列表。  
  
   例如，  
  
     (cons 1 '(2 3 4))  
          => (1 2 3 4)   
  
-  nthcdr  
  
   这个函数返回对一个列表求 N 次 cdr 的值，也就是“剩余的剩余部分”。  
  
   例如，  
  
    (nthcdr 3 '(1 2 3 4 5 6 7))  
          => (4 5 6 7)  
  
-  setcdr、setcar  
  
   setcar 改变一个列表的第一个元素，而 setcdr 则改变一个列表的第二个到最后  
   一个元素。  
  
   例如：   

----------------------- Page 101-----------------------

  
    (setq triple '(1 2 3))  
  
    (setcar triple '37)  
  
   triple  
      => (37 2 3)  
  
   (setcdr triple '("foo" "bar"))   
   
  triple  
      => (37 "foo" "bar")  
  
-  progn  
  
   这个函数依次对其每一个参量求值，并返回最后一个参量的值。  
  
   例如：  
  
    (progn 1 2 3 4)  
        => 4   
  
-  save-restriction  
  
   这个函数记录当前缓冲区中变窄开启是否设置，如果已经设置，就在对后续的  
   参量求值之后恢复变窄开启。  
  
-  search-forward  
  
   这个函数查找一个字符串，并且如果找到这个字符串就移动位点。  
  
   这个函数有 4 个参量：   
  
   1) 要查找的字符串。  
  
   2) 查找的限制范围(可选)。  
  
   3) 如果查找失败应如何处理，是返回 nil 还是返回一个错误消息(可选)。  
  
   4) 重复查找多少次，如果这个参里的值是负的，就是朝后查找(可选)。  
  
  
-  kill-region、delete-region、copy-region-as-kill  
  

----------------------- Page 102-----------------------

   kill-region 函数将一个缓冲区中位点和标记之间的文本剪切掉，并将这些文  
   本保存在 kill 环中，因此能够将它们重新找回来。  
  
   delete-region 函数将缓冲区中位点和标记之间的文本移走并扔掉，不能够将  
   它们再重新找回来。  
  
   copy-region-as-kill 函数将缓冲区中位点和标记之间的文本拷贝到 kill 环  
   中，从 kill 环中可以将它们重新找回来。这个函数不将缓冲区中的文本剪切掉。  
  
** 8.7 查找练习  
  
- 编写一个查找字符串的交互函数。如果找到需要的字符串，在其后设置位点并  
  显示这样一条消息："Found!"。(不要使用 search-forward 作为这个函数的函数  
  名；如果用了这样一个函数名，将覆盖 Emacs 的 search-forward 函数本身。可以  
  使用如 test-search 这样的函数名。)  
  
- 编写一个函数，这个函数在回显区打印 kill 环的第三个元素。如果 kill 环没有  
  第三个元素，则打印一条适当的消息。  
  
- 在第 19.29 版中，copy-region-as-kill 函数不再设置 this-command 变量。这种  
  变化的后果是什么？要采取什么样的相应变化，才能达到同样的效果？  
  
* 第 9 章 列表是如何实现的  
  
在 Lisp 中，原子是以一种直观的方式记录在计算机中的；如果说它在实际的实现  
上不那么简单，那么它至少在理论上是简单的。例如，原子“rose”是由紧挨着  
的四个字符"r"、"o"、"s"、"e"记录下来的。在另一方面，列表是用一种不同的  
方式保存的。列表的保存机制同样简单，但是要理解这个思想需要花一点时间。  
列表是用一系列成对的指针保存的。在这个成对的指针系列中，每一对指针的第  
一个指针要么指向一个原子，要么指向另外一个列表；而其第二个指针要么指向  
下一个指针对，要么指向符号 nil，这个符号标记一个列表的结束。  
  
指针本身相当简单，就是它指向的电子地址。因此，一个列表实际上就是被保存  
为一系列电子地址。  
  
例如，列表(rose violet buttercup)有三个元素："rose"、"violet"和  
"buttercup"。在计算机中，"rose"的电子地址存储在计算机内存片段中，其后紧  
跟着给出原子"violet"存放位置的地址。这个地址又与给出"buttercup"存放位置  
的地址连接在一起。  
  
         ___ ___      ___ ___      ___ ___  
         |___|___|--> |___|___|--> |___|___|--> nil  

           |            |            |  
           |            |            |  
           --> rose     --> violet   --> buttercup  
  
在这个图中，每一个方框代表计算机内存中的一个“字”(word)，它通常是以内  
存地址的方式存放一个 Lisp 对象。这些方框，也就是这些地址，是成对的。图中  
的箭头要么是指向一个原子的地址，要么是指向另外一对地址的地址。第一个方  
框是“rose”的地址，其箭头指向"rose"；第二个方框是下一对方框的地址。这  
第二对方框中的第一个方框是“violet”的地址，而其第二个方框指向下一对方  
框的地址。最后一对方框的第二个方框(也就是最后一个方框)指向符号 nil。这个  
符号标记一个列表的结束。  
  
当用一个函数(如 setq)将一个列表赋给一个变量时，实际上就是将列表的第一个  
方框的地址赋给那个变量。因此，对下面这个表达式求值  
  
(setq bouquet '(rose violet buttercup))  
  
产生如下图展示出来的情况：   
  
     bouquet  
           |  
           |     ___ ___      ___ ___      ___ ___  
           --> |___|___|--> |___|___|--> |___|___|--> nil  
                  |             |            |  
                  |            |            |  
                  --> rose     --> violet   --> buttercup  
  
在这个例子中，符号 bouquet 中保存第一个方框对的地址。确实，这个符号由一组  
地址框组成，其中第一个地址框就是“bouqoet”一词的地址；如果有同名的函数  
定义加到这个符号上，其中第二个地址框是这个函数定义的地址；其中第三个地  
址框就是列表(rose viole buttercup)的成对地址框系列中第一对的地址；等等。  
  
这个列表同样可以用下面这种不同的方式来表示：  
  
     bouquet  
       |  
       |    --------------       ---------------       ----------------  
       |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |  
       -->| rose  |   o------->| violet |   o------->| butter-  |  nil |  
           |       |      |     |        |      |     | cup     |      |  
           --------------       ---------------       ----------------  
  
在前面的一节中，我曾经建议将一个符号想象成为一个抽屉箱。函数定义被放在  
其中一个抽屉中，符号的值放在另外一个抽屉中，等等。保存符号值的抽屉中的  


内容的改变，不影响保存函数定义的抽屉中的内容。反之亦然。实际上，放在每  
一个抽屉中的都是符号值的地址或者函数定义的地址。这就像你在阁楼中找到一  
个旧抽屉箱，在其中一个抽屉中发现了一张地图，这张地图告诉你财宝存放的位  
置。  
  
(除了符号名、符号定义和变量的值之外，符号还有一个“抽屉”保存其属性列表。  
这个属性列表能用于记录其他信息。属性列表不在这里介绍，有关它的内容可以  
参见《GNU Emacs Lisp 技术手册》的“属性列表”一节。)  
  
下面是一个充满想象力的表示：   
  
                 Chest of Drawers            Contents of Drawers  
                    (抽屉箱)                      (抽屉内容)  
              ---------------------  
              |                     |   
              |     symbol name     |             bouquet  
              |                     |  
              +---------------------+  
              |                     |  
              |  symbol definition  |             [none]  
              |                     |  
              +---------------------+  
              |                     |  
              |    variable value   |         (rose violet buttercup)  
              |                     |  
              +---------------------+  
              |                     |  
              |    property list    |             [not described here]  
              |                     |  
              +---------------------+  
              |/                   \|  
  
如果一个符号被设置为一个列表的 cdr，这个列表本身没有改变；符号仅仅只有列  
表的地址。(用术语来说，car 和 cdr 是非破坏性的。)因此，对下面的表达式求值  
  
(setq flowers (cdr bouquet))  
  
将产生这样的结果：  
  
     bouquet        flowers  
        |              |  
        |     ___ ___  |     ___ ___      ___ ___  
        --> |   |   |  --> |   |   |    |   |   |  
             |___|___|----> |___|___|--> |___|___|--> nil  

----------------------- Page 105-----------------------

               |               |            |  
               |              |            |  
               --> rose       --> violet   --> buttercup  
  
flowers 的值是(violet buttercup)，这就是说，符号 flowers 存放成对的地址框  
的地址，成对的地址框的第一个地址对中存放 violet 的地址，第二个地址对中存  
放 buttercup 的地址。  
  
一个成对的地址框被称为一个“cons 原胞”(cons cell)或者一个“带点偶  
对”(dotted pair)。具体内容参见《GNU Emacs Lisp 技术手册》中的“Lisp 类  
型”一节以及“带点偶对注解”一节。  
  
就像前面说的那样，cons 函数在一系列地址对前面插入一个新的地址对。例如，  
对下面的表达式求值  
  
(setq bouquet (cons 'lilly bouquet))  
  
会得到：  
  
     bouquet                       flowers  
        |                              |  
        |     ___ ___        ___ ___  |     ___ ___       ___ ___  
        --> |   |   |      |   |   |  --> |   |   |     |   |   |  
             |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil  
               |               |              |             |  
               |              |              |             |  
               --> lily      --> rose       --> violet    --> buttercup  
  
然而，这并不改变符号 flowers 的值，不信可以通过对下面的表达式求值来看一看：  
  
(eq (cdr (cdr bouquet)) flowers)  
  
这个表达式的返回值为“真”(t)。  
  
除非被重新赋值，否则符号 flowers 的值仍旧是(violet buttercup)。这就是说，  
它拥有首地址为 violet 的地址的 cons 原胞的地址。同样，这并不改变任何已经存  
在的 cons 原胞，它们还是原封不动地存在那里。  
  
因而，在 Lisp 中，要得到一个列表的 cdr，只要得到地址系列中下一个 cons 原胞的  
地址即可；要得到一个列表的 car，就是得到这个列表的第一个元素的地址；要用  
cons 函数在一个列表中插入一个新元素，其作用就是往列表中插入了一个新的  
cons 原胞。这就是列表实现的方式。Lisp 底层的结构就是这样不可思议的简单。  
  
cons 原胞系列中最后一个地址指向什么呢？就是指向空列表(即符号 nil)的地址。  

----------------------- Page 106-----------------------

  
总之，当为一个 Lisp 变量赋值时，它提供的是列表的地址，变量就指向这个列表  
的地址。  
  
** 练习  
  
将符号 flowers 设置为 violet 和 buttercup 两个元素组成的列表。往这个列表中增  
加两种新的花名，并将这个新的列表赋值给 more-flowers 变量。将 flowers 的 car  
设置为一种鱼的名字。看一看 more-flowers 列表现在的内容是什么？  
  
* 第 10 章 找回文本  
  
在 GNU Emacs 中，无论你何时用"kill"命令从缓冲区中剪切了文本，你都能用一个  
"yank"命令将其重新找回。从缓冲区中剪切的文本被放在 kill 环中，yank 命令则  
将 kill 环中适当的内容重新插入到缓冲区中(不一定非得是原来的缓冲区)。  
  
一个简单的 C-y (yank)命令，就从 kill 环中取出第一个元素插入到当前的缓冲区  
中。如果 C-y 命令后面紧跟一个 M-y 命令，则不是第一个元素而是第二个元素被插  
入到当前缓冲区中。连续的 M-y 命令则将使第三个元素或第四个元素等代替第二个  
元素而被插入到当前缓冲区中。当这样不断键入 M-y 而到达 kill 环的最后一个元素  
时，它就循环地将第一个元素插入到当前缓冲区中。(因此 kill 环被称为“环”，  
而不仅仅是列表。然而，保存文本的实际数据结构是一个列表。关于将一个列表  
作为环来处理的详细内容，参见附录 B, “处理 kill 环”。)  
  
** 10.1 kill 环总览  
  
kill 环是文本字符串的一个列表。它类似于下面的列表：  
  
("some text" "a different piece of text" "yet more text")  
  
如果 kill 环的内容就是这样的一个列表，当键入 C-y 时，字符串"some text"将插  
入到当前缓冲区中光标当前所处的位置(即位点处)。  
  
yank 命令也用于复制文本，这通过拷贝文本实现。被拷贝的文本不是从缓冲区中  
删除掉，但是这部分文本的一个拷贝被放到 kill 环中，并可以用 yank 命令将其找  
回来插入到当前缓冲区中。  
  
能够将文本从 kill 环中找回的函数有三个：yank 函数，通常绑定到 C-y；  
yank-pop 函数，通常绑定到 M-y；rotate-yank-pointer 函数，这个函数被前面两  
个函数使用。  
  
这些函数通过一个被称为 kill-ring-yank-pointer 的变量指向 kill 环。事实上，  
yank 函数和 yank-pop 函数中插入文本的代码都是下面这个表达式：  
  

----------------------- Page 107-----------------------

  (insert (car kill-ring-yank-pointer))  
  
在开始理解 yank 函数和 yank-pop 函数如何工作之前，分析一下  
kill-ring-yank-pointer 变量和 rotate-yank-pointer 函数是必要的。  
  
** 10.2 kill-ring-yank-pointer 变量  
  
就像 kill-ring 是一个变量一样，kill-ring-yank-pointer 也是一个变量。它通过  
被绑定到相应的值来指向某些东西，这一点与其他 Lisp 变量没有什么两样。  
  
因而，如果 kill 环的值是：  
  
  ("some text" "a different piece of text" "yet more text")  
  
并且 kill-ring-yank-pointer 变量指向其中的第二个元素，则  
kill-ring-yank-pointer 变量的值就是：  
  
  ("a different piece of text" "yet more text")  
  
就像在前面章节中解释的那样(参见第 9 章，“列表是如何实现的”)，计算机并不  
保存同时被 kill-ring 变量和 kill-ring-yank-pointer 变量指向的内容的两个拷贝。  
"a different piece of text"和"yet more text"两个字符串都没有复制的副本。  
事实上，两个 Lisp 变量指向同样的一个文本块。用一个图来表示就是：  
  
     kill-ring     kill-ring-yank-pointer  
          |               |  
          |      ___ ___  |     ___ ___      ___ ___  
          ---> |   |   |  --> |   |   |    |   |   |  
                |___|___|----> |___|___|--> |___|___|--> nil  
                  |              |            |  
                  |              |            |  
                  |              |             --> "yet more text"  
                  |              |  
                  |               --> "a different piece of text"  
                  |  
                  --> "some text"  
  
变量 kill-ring 和变量 kill-ring-yank-pointer 都是指针。但是在提到 kill 环本身  
时，常常就像是指其组成部分。在提到变量 kill-ring 时，就像它是一个列表而不  
是一个指向这个列表的指针。相反，在提到变量 kill-ring-yank-pointer 时，它  
确实是指向一个列表的指针。  
  
这样两种讨论同样一件事情的方法，使人初看之下不免迷惑；但是仔细分析，就  
会发现这是有意义的。kill 环一般被认为是保存从当前缓冲区中剪切的文本信息  

----------------------- Page 108-----------------------

的完整结构。另一方面，变量 kill-ring-yank-pointer 则用于指示(即“指  
向”)kill 环的某一部分，kill 环的这一部分的第一个元素将被插入到缓冲区中。  
  
rotate-yank-pointer 函数改变 kill-ring-yank-pointer 变量指向的 kill 环中的元  
素。当这个指针指向的下一个元素超出了 kill 环的末尾，它自动将这个指针指向  
kill 环的第一个元素。这就是将一个列表自动地转化为一个环的方法。  
rotote-yank-pointer 函数本身并不难理解，但是它包含了许多细节。在附录 B"处  
理 kill 环"中，将描述这个函数以及更简单的 yank 函数和 yank-pop 函数。  
  
** 10.3 练习：使用 yank 函数和 nthcdr 函数  
  
- 使用 C-h v (describe-variable)命令，看一看你的 kill 环的值。为你的 kill 环  
  增加几个元素，然后再看一看它的值。使用 M-y (yank-pop)命令在 kill 环中移  
  动。你的 kill 环中有多少个元素？用 kill-ring-max 得到这个值。你的 kill 环是  
  否已经满了，或者你能否可以继续往其中保存更多的文本块？。  
  
- 使用 nthcdr 和 car 函数构建一系列表达式分别来返回一个列表的第一个元素、第  
  二个元素、第三个元素、第四个元素，等等。  
    
* 第 11 章 循环和递归  
  
Emacs Lisp 有两种方式使一个表达式或者一系列表达式不断被求值：一是使用  
while 循环，一是使用“递归”(recursion)。  
** 11.1 while  
  
   (while true-or-false-test  
     body...)  
  
while 循环的返回值就是真假测试的返回值。它的一个有趣的结果就是一个无错的  
while 循环，将总是返回 nil 或者“假”，而不管它循环求值了 1 次或者 100 次，或  
者根本一次也没有。一个求值成功的 while 表达式从不返回“真”值！这意味着，  
while 表达式总是为了它的附带效果，也就是在 while 循环主体中的表达式的结果，  
而被求值。这一点很有意义。循环本身不是目的，但是在循环中表达式被求值才  
是重要的。  
  
*** 11.1.1 while 循环和列表  
  
控制 while 循环的一个通用方法就是测试一个列表中是否还有元素。如果有，循环  
就重复下去；如果没有，循环就结束。因为这是一种重要的技术，因此在此将创  
建一个简短的例子来演示它。  
  
测试一个列表中是否有元素的简单方法就是对列表求值：如果列表中没有元素，  
它就是一个空列表，因此这种测试返回一个空列表()，也就是 nil 或者“假”。另  
一方面，如果列表中有元素，对列表的求值就返回这些元素。因为 Lisp 认为非空  
的任何元素都是“真”，所以任何有元素的列表在测试时都返回“真”。  
  
例如，通过对下面的 setq 表达式求值，能够将变量 empty-list 设置为 nil。  
  
(setq empty-list ())  
  
对这个 setq 表达式求值后，能够用通常的办法——将光标置于符号之后并键入 C-x  
C-e，来对变量 empty-list 求值。nil 将出现在回显区中：  
  
empty-list  
  
另一方面，如果将一个有元素的列表赋值给一个变量，当对这个变量求值时，它  
指向的列表中的元素将显示在回显区中。对下面的两个表达式求值就可以看到这  
一点：  
  

----------------------- Page 110-----------------------

(setq animals '(giraffe gazelle lion tiger))   
  
animals  
  
因此，要创建一个 while 循环来测试在列表 animals 中是否有元素，while 循环的第  
一个部分将是这个样子：  
  
(while animals  
       ...  
  
当 while 测试它的第一个参量时，animals 列表被求值。这返回一个列表。只要这  
个列表中还有元素，while 就认为测试为“真”。但是当列表空了时，则测试结果  
为“假”。  
  
为了避免 while 循环永无止境地循环下去，需要一些机制来最终提供空的列表。一  
个经常使用的技术，就是在 while 表达式主体中用一个表达式将这个列表的值设置  
为这个列表的 cdr。每执行一次 cdr 求值，列表就更短，元素就更少，直到最终只  
剩下一个空列表。这时，while 循环的测试将返回"假"，就不会再对循环主体求  
值了。  
  
例如，绑定到变量 animals 的关于动物的列表，能够用下面的表达式将其设置为原  
来列表的 cdr。  
  
(setq animals (cdr animals))  
  
如果你已经对前面的表达式求值并随后再对这个表达式求值，你将看到(gazelle  
lion tiger)显示在回显区中。如果再一次对这个表达式求值，(lion tiger)将显  
示在回显区中。如果继续对这个表达式求值，(tiger)将显示在回显区。再继续求  
值下去最后就是一个空列表，显示为 nil。  
  
下面是一个 while 循环模板，它重复地使用 cdr 函数以使 while 循环的真假测试最终  
返回“假”值：  
  
(while test-whether-list-is-empty  
      body...  
      set-list-to-car-of-list)  
  
对列表长度的测试以及使用 cdr 来逐一减少列表中的元素，可以放在一个函数中，  
用来遍历一个列表，并将列表的每一个元素以一个元素独占一行的方式打印出来。  
  
*** 11.1.2 一个例子：print-elements-of-list  
  
print-elements-of-list 函数演示了使用一个列表作为测试部分的 while 循环的结  
构。  

----------------------- Page 111-----------------------

  
这个函数需要几行的空间来输出。因为回显区只有一行，我们不像前面演示其他  
函数那样在 Info 中对它求值来显示它是如何工作的，而是需要将必要的表达式拷  
贝到“*scrach*”(草稿)缓冲区，并在草稿缓冲区中对它们求值。你可以用  
C-<SPC> (set-mark-command)命令标记待拷贝区域的开始处，将光标移动到这个  
区域的末尾并键入 M-w (copy-region-as-kill)命令来拷贝这个区域。在草稿缓冲  
区中，能够通过键入 C-y (yank)命令来插入这些表达式。  
  
当你已经将这些表达式拷贝到草稿缓冲区之后，逐一对这些表达式求值。一定要  
对最后一个表达式——(print-elements-of-list animais)求值，求值是通过键入  
C-u C-x C-e 完成的，也就是给 eval-last-sexp 命令传送一个参量。这将使对表达  
式的求值结果被显示在草稿缓冲区中而不是被显示在回显区中。(否则你将在回显  
区中看到诸如：^Jgiraffe ^J^Jgazelle^J^Jlion^J^Jtiger^Jnil 这样的东西，  
其中，"^J”代表一个新行，在草稿缓冲区中，每一个元素都放在单独的一行中。  
如果你高兴的话，只管在 Info 中对这些表达式求值好了，看看会得到什么样的结  
果。)  
  
  (setq animals '(girafe gazelle lion tiger))  
  
  (defun print-elements-of-list (list)  
   "Print each element of LIST on a line of its own."  
    (while list  
       (print (car list))  
       (setq list (cdr list))))  
  
  (print-elements-of-list animals)  
  
  
当你在草稿缓冲区中依次对上述三个表达式求值时，下面的内容将显示在草稿缓  
冲区中：  
  
girafe  
  
gazelle  
  
lion  
  
tiger  
nil  
  
列表的每一个元素都分别占一行打印出来(这是由 print 函数完成的)，然后这个函  
数的返回值 nil 被打印出来。因为这个函数的最后一个表达式是 while 循环，又因  
为 while 循环总是返回 nil 的，所以打印完列表的最后一个元素之后，就打印函数  
的返回值 nil。  

----------------------- Page 112-----------------------

  
*** 11.1.3 使用增量计数器的循环  
  
只有当该停止时就停止下来，这个循环才是有用的。除了用列表来控制循环之  
外，一个通用的终止一个循环的方法是：当所需数量的循环次数执行完毕时，其  
作为测试内容的第一个参量变成“假”。这意味着循环必须要有一个计数器——一  
个记录循环次数的表达式。  
  
这种测试可以是这样的表达式(< count desired-number)。这个表达式在变量  
count 的值小于 desired-number 变量的值时返回“真”，而在 count 的值等于或者  
大于 desired-number 的值时返回“假”。对变量 count 进行增量运算的表达式可以  
是简单的 setq 表达式，如(setq count (1+ count))，这里 1+函数是 Emacs Lisp 的  
内置函数，它对其参量加 1。(表达式(1+ count)与表达式(+ count 1)功能完全等  
价，但是更易于人们阅读。)  
  
由增量计数器控制的 while 循环的模板如下所示：  
  
 set-count-to-initial-value  
  (while (< count desired-number) ;true-or-false-test  
    body...  
     (setq count (1+ count)))     ;incrementer  
  
注意，你需要为变量 count 设置初始值，通常将它设置为 1。  
  
1．使用增量计数器的例子  
  
假设你正在海滩上玩耍，并决定用鹅卵石排出一个三角形。在第一行放置一块鹅  
卵石，在第二行放置两块鹅卵石，在第三行放置三块鹅卵石，如此等等。在如下  
所示：  
  
  
                    *  
                   * *  
                  * * *  
                 * * * *  
  
(大约在 2500 年前，毕达哥拉斯和其他人通过考虑类似的问题发展了早期的数论。)  
  
假设你想知道，要排出一个 7 行的三角形，需要多少块鹅卵石？  
  
很清楚，你所要做的就是从 1 加到 7。有两种方法完成它，一是从小的数开始，依  
次往上加；一是从最大的 7 开始，依次减到 1。由于在编写 while 循环时，这两种方  
式都是通用的，因此我们将创建两个例子，一个从 1 往上加到 7，一个从 7 往下减到  
1。在第一个例子中，我们从 1 开始往上加 2、3，等等。  

----------------------- Page 113-----------------------

  
如果你仅仅对一个短的数字列表求和，最简单的办法就是直截将这些数字全部加  
起来。但是，如果你事先不知道列表中有多少数字，或者要对一个相当长的列表  
操作，就需要设计求和函数，以使你只需多次重复一个简单的过程，而不是单次  
执行一个复杂的过程来完成求和工作。  
  
例如，不要一次将所有的鹅卵石块加起来，你可以将第一行的鹅卵石数 1 加上第二  
行的鹅卵石数 2，然后将这个结果加上第三行的鹅卵石数 3。之后，加上第四行的  
鹅卵石数 4……如此等等。  
  
这个过程的关键特征就在于重复执行的每一个过程都很简单。在这个例子中，每  
一步我们只要将两个数相加，即当前一行的鹅卵石数加上先前已经加好的前几行  
的鹅卵石总数。将两个数相加的过程，一次又一次地重复执行，直到最后一行加  
到前面各行的总数之中。在更加复杂的循环中，重复执行的每一步可能不像这样  
简单，但它总比一次完成所有的事情要简单。  
  
2． 函数定义部分  
  
前面的分析告诉了我们这个函数定义的骨架：首先，需要一个称为 total 的变量，  
这个变量记录鹅卵石的总数。这个值最终由函数返回。  
  
其次，这个函数需要一个参量：即三角形的总行数。它叫做 number-of-rows。  
  
最后，需要一个作为计数器的变量。可以将这个变量称为 counter，但是一个更好  
的名字是 row-number。这是因为，这个计数器是对行数计数的，而且一个程序应  
当尽可能使人们易于理解。  
  
当 Lisp 解释器对这个函数的表达式求值时，total 变量的值应当被设置为 0，因为  
此时尚未往它中加任何数字。然后，这个函数应当往 total 变量中加上第一行的鹅  
卵石数 1，继而加上第二行的鹅卵石数 2……直到没有可加的为止。  
  
total 变量和 row-number 变量都只用在函数内部，因此可以用 let 命令将它们声明  
为局部变量并赋初始值。很清楚，total 变量的初始值应当是 0。row-number 变量  
的初始值应当是 1，原因是要从第一行开始计数。这意味着 let 语句应该这样：  
  
(let ((total 0)  
       (row-number 1))  
  
   body...)  
  
声明了内部变量并绑定到它们的初始值之后，就可以开始 while 循环了。用作测试  
的表达式应当在 row-number 变量的值小于或者等于 number-of-rows 变量的值时返  
回“真”。(如果测试表达式只在 row-number 的值小于 number-of-rows 的值时返回  
 “真”，三角形的最后一行将不被计算到总数中，因此行数应当小于或者等于总  

----------------------- Page 114-----------------------

行数)。  
  
Lisp 提供了<=函数，这个函数在其第一个参量小于或者等于其第二个参量的值时  
返回"真"；否则返回"假"。因此这个 while 表达式的第一个参量应当如下所示：  
  
  (<= row-number number-of-rows)  
  
鹅卵石的总数是这一行的鹅卵石数加上前面所有各行的鹅卵石数目的总和。因为  
每一行的鹅卵石的数目就等于行数，因此可以直接将 row-number 变量的值加到鹅  
卵石总数上。(很清楚，在更复杂的情况下，某一行的鹅卵石的数目以一种更复杂  
的方式与它所在的行相关。如果是这种情况，就要用适当的表达式取代下面表达  
式中的 row-number 变量。)  
  
  (setq total (+ total row-number))  
  
这个表达式所做的工作就是将 total 变量重新赋值为原有值加上当前一行的鹅卵石  
数目。  
  
设置了 total 变量的值之后，如果有的话，就应当为下一次循环建立条件了。这就  
是将 row-number 变量用作一个计数器，将它递增 1。row-number 变量被递增后，  
while 循环的测试表达式重新测试这个计数器的值是否依然小于或者等于  
number-of-rows 的值。如果是，在循环中将 row-number 变量的新值加到 total 变量  
中。  
  
Emacs Lisp 的内置函数 1+的功能，就是往一个数增加 1，因此 row-number 变量可以  
用下面的表达式递增：  
  
(setq row-number (1+ row-number))  
  
3． 组装完成函数定义  
  
我们已经创建了这个函数定义的各个部分；现在需要将这些部分组装起来。  
  
首先，while 表达式的内容如下所示：  
  
(while (<= row-number number-of-rows)  ;true-or-false-test  
     (setq total (+ total row-number))  
     (setq row-number (1+ row-number))) ;incrementer  
  
这个表达式再加上 let 表达式的变量列表，就已经非常接近于整个函数定义的函数  
体了。但是，还需要一个最后的元素，这有一点微妙。  
  
这最后一个元素就是将变量 total 单独作为一行放在 while 表达式之后。否则，整  
个函数的返回值总是空(nil)。因为，在这种情况下，整个函数的返回值就是 let  

----------------------- Page 115-----------------------

表达式主体中最后一个表达式的值，也就是 while 表达式的返回值，而这个返回值  
总是 nil。因此为了返回求和的总数，需要增加单独的这一行。  
  
这一点初看起来似乎并不明显。看起来，函数的最后一个表达式好像是那个增量  
表达式。但是这个增量表达式是 while 表达式主体的一部分。它是以符号 while 开  
始的列表的最后一个元素。而且，整个 while 循环是 let 表达式主体中的一个列表。  
  
从结构上看，这个函数将是如下所示：  
  
  (defun name-of-function (argument-list)  
    "documentation..."  
     (let (varlist)  
        (while (true-or-false-test)  
          body-of-while...)  
          ...)                      ;Need final expression here.  
  
对 let 表达式求值所返回的结果就是 defun 函数的返回值。这是因为 let 表达式没有  
嵌入到其他列表中，而只是嵌入在函数定义(defun)之中。然而，如果 while 表达  
式是 let 表达式的最后一个元素，这个函数将总是返回一个空值 nil。这并不是我  
们所需要的！确实，我们所需要的是变量 total 的值。只要简单将这个变量作为  
let 表达式的最后一个元素放在其中就行了。在前面的元素求值之后，这个元素被  
求值，这意味着它被正确地赋值后再被求值。  
  
将所有这些元素放在一行中就更容易看明白。这种格式使人明显地看到 varlist 和  
while 表达式是 let 表达式的第二个和第三个元素，而变量 total 则是 let 表达式的  
最后一个元素。  
  
(let (varlist) (while (true-or-false-test) body-of-while...) total)  
  
将所有的表达式组合起来，这个 triangle 函数定义就是如下所示：  
  
(defun triangle (number-of-rows)  ;Version with  
                                   ; incrementing counter.  
    "Add up the number of pebbles in a triangle.  
     The first row has one pebble, the second row tow pebbles,  
     the third row three pebbles, and so on.  
     The argument is NUMBER-OF-ROWS."  
     (let ((total 0)  
           (row-number 1))  
         (while (<= row-number number-of-rows)  
             (setq total (+ total row-number))  
             (setq row-number (1+ row-number)))  
        total))  
  

----------------------- Page 116-----------------------

在你通过对上面的这个函数求值而安装了 triangle 函数之后，你就可以试验这个  
函数了。这里有两个例子：  
  
  (triangle 4)  
  
  (triangle 7)  
  
求值的结果是：前 4 个数的和是 10，前 7 个数的和是 28。  
  
*** 11.1.4 使用减量计数器的循环  
  
编写 while 循环的另外一个通用的方法是在编写测试表达式时根据一个计数器是否  
大于零来决定“真假”值。只有当计数器大于零时，循环才继续下去。当计数器  
等于或者小于零，循环就中止了。为了使这种方法能够工作，这个计数器一定要  
从大于零开始计数，并通过一个不断重复求值的表达式一步一步地变得越来越小。  
  
测试将是这样的一个表达式：(> counter 0)，如果 counter 变量的值大于零，则  
测试返回“真”；如果 counter 变量的值等于或者小于零，测试就返回“假”。使  
计数器变量的值越来越小的表达式可以是一个简单的 setq 表达式，如(setq  
counter (1- counter))，这里 1-函数是 Emacs Lisp 中的一个内置函数，它将其参  
量的值减 1。  
  
使用减量计数器的 while 循环的模板如下所示：  
  
(while (> counter 0)             ;true-or-false-test  
    body...  
     (setq counter (1- counter)))  ;decrementer  
  
1．使用减量计数器的例子  
  
为了演示使用减量计数器的 while 循环，我们将重新编写 triangle 函数，使计数器  
递减到零来控制循环的执行。  
  
这是前面那个函数的对应版本。在这种情况下，为了得到 3 行的三角形是由多少块  
鹅卵石排成的，就要将第三行的鹅卵石数 3 加上第二行的鹅卵石数 2，再加上第一  
行的鹅卵石数 1。  
  
同样，为了得到 7 行的三角形由多少块鹅卵石排成的，就要将第 7 行的鹅卵石数 7 加  
上它前面一行的鹅卵石数 6，再将这两个数之和加上更前面一行的鹅卵石数 5，如  
此等等。就像前面那个例子一样，每一次加法都只是涉及到两个数的相加。已经  
加过的行，其中的鹅卵石数也已经加到总的鹅卵石数中了。将两个数相加的过程  
一次又一次地重复执行，直到所有行都加完。  
  
我们知道从多少块鹅卵石开始：因为最后一行的鹅卵石数就等于它所在的行数。  

----------------------- Page 117-----------------------

如果三角形有 7 行，最后一行的鹅卵石就有 7 块。同样，我们知道前面一行有多少  
块鹅卵石：它比当前行的鹅卵石数少一块。  
  
2． 函数定义的各部分  
  
我们以三个变量开始，它们是：三角形中总的行数、每一行中的鹅卵石数以及要  
计算的总的鹅卵石数。这些变量可以分别取名为：number-of-rows,  
number-of-pebbles-in-row 和 total。  
  
total 变量和 number-of-pebbles-in-row 变量只用在函数内部，它们是用 let 表达  
式声明的。当然，total 变量的初始值应当是零。然而，  
number-of-pebbles-in-row 变量的初始值应当等于三角形中的行数，因为函数是  
从最长的一行开始相加的。  
  
这意味着 let 表达式的开头部分是：  
  
(let ((total 0)  
       (number-of-pebbles-in-row number-of-rows))  
     body...)  
  
鹅卵石的总数能够通过反复地将当前行的鹅卵石数加上已经求和的各行的鹅卵石  
数得到，也就是反复地对下面的表达式求值：  
  
  (setq total (+ total number-of-pebbles-in-row))  
  
在将 number-of-pebbles-in-row 与 total 相加后，number-of-pebbles-in-row 的值  
应该减 1，因为下一次循环时，下一行的鹅卵石数将被加到鹅卵石的总数中。  
  
下一行的鹅卵石数比当前行的鹅卵石数少 1，因此在计算下一行的鹅卵石数时可以  
使用 Emacs Lisp 的内置函数 1-。这可以用下面的表达式完成：  
  
  (setq number-of-pebbles-in-row   
         (1- number-of-pebbles-in-row))  
  
最后，我们知道，当一行中没有鹅卵石时，while 循环应当停止下来。因此 while  
循环中的测试表达式很简单：  
  
  (while (> number-of-pebbles-in-row 0)  
  
3． 组装完成函数定义  
  
将这些表达式组装起来，就有了一个这样的函数定义：  
  
;;;First subtractive version.  

----------------------- Page 118-----------------------

(defun triangle (number-of-rows)  
 "Add up the number of pebbles in a triangle."  
   (let ((total 0)  
         (number-of-pebbles-in-row number-of-rows))  
      (while (> number-of-pebbles-in-row 0)  
          (setq total (+ total number-of-pebbles-in-row))  
          (setq number-of-pebbles-in-row  
               (1- number-of-pebbles-in-row)))  
      total))  
  
就像编写的那样，这个函数可以正常工作了。  
  
然而，其中的一个局部变量 number-of-pebbles-in-row 并不是必需的。  
  
当 triangle 函数被求值时，符号 number-of-pebbles-in-row 被绑定到一个数字  
上，给它赋初始值。在函数体中，这个数可以被当做一个局部变量一样被改变，  
而不用担心这种改变会影响函数之外的变量的值。这是 Lisp 的一个非常有用的特  
性；它意味着变量 number-of-rows 可以用于函数中变量  
number-of-pebbles-in-row 使用的任何地方。  
  
下面就是这个函数的第二个版本，它写得更清楚一点：  
  
  (defun triangle (number) ;Second version.  
   "Return sum of numbers 1 through NUMBER inclusive."  
   (let ((total 0))  
      (while (> number 0)  
          (setq total (+ total number))   
          (setq number (1- number)))  
   total))  
  
简要地说，一个正确的 while 循环将包含三个部分：  
  
1) 一个真假测试表达式，它在循环体执行正确的循环次数之后返回“假”。  
  
2) 一个求值表达式，它在求值完成之后返回用户需要的值。  
  
3) 一个表达式，它用来改变传送给真假测试表达式的值，这样在循环体执行正确  
   的循环次数之后才能返回“假”值给真假测试表达式。  
  
** 11.2 递归  
 | A     | B     | C     |
 | A_1-> | B_1   |       |
 | A_2-> |       | C_1   |
 |       | B_1-> | C_2   |
 | A_3-> | B_1   |       |
 | A_top |       | <-C_2 |
 |       |       |       |
1) 一个真假测试，它决定函数是否继续调用自身，这里称之为 do-again-test。  
  
2) 函数名。  
  
3) 一个表达式，它在函数被重复求值正确的次数之后使条件表达式返回  
    “假”值，称为 next-step-expression。  
递归函数的模板如下所示：  
  
  (defun name-of-recursive-function (argument-list)  
 "documentation..."  
  body...  
   (if do-again-test  
       (name-of-recursive-function  
             next-step-expression)))  
  
递归函数每被求值一次，一个参量就被绑定到 next-step-expression 的值上。这  
个值又用于 do-again-test。设计 next-step-expression 表达式的目的是当函数不  
再需要被重复求值时 do-again-test 测试表达式能够返回“假”。  
  
这个真假测试有时被称为停止条件(stop condition)，因为当它的测试结果为  
 “假”时，就停止循环调用。  
  
*** 11.2.1 使用列表的递归函数  
  
将一个数字列表中的元素打印出来的 while 循环的例子，也能够用递归的方法写出  
来。下面就是它的代码，其中包含一个将变量 animals 的值赋给一个列表的表达式。  
  
这个例子一定要拷贝到草稿缓冲区，并且要在草稿缓冲区中对每一个表达式都求  
值。可以使用 C-u C-x C-e 对(print-elements-recursively animals)表达式求  
值，以使结果打印在缓冲区中；否则 Lisp 解释器将试图把结果压缩到一行中打印  
到回显区中。  
  
同样，要将光标紧紧置于 print-elements-recursively 函数的最后一个括号之后  
(注释之前)。否则，Lisp 解释器将试图对注释求值。  
  
(setq animals '(giraffe gazelle lion tiger))  

----------------------- Page 120-----------------------

  
(defun print-elements-recursively (list)  
 "print each element of LIST on a line of its own.  
 Uses recursion."  
   (print (car list))                ;body  
   (if list                           ;do-again-test  
       (print-elements-recursively   ;recursive call  
         (cdr list))))               ;next-step-expression  
  
  (print-elements-recursively animals)  
  
这个 print-elements-recursively 函数首先打印列表的第一个元素，即列表的  
car。然后，如果列表不是空，这个函数调用它自己，但是传递给函数本身作为其  
参量的不是整个这个列表，而是由列表的第二个元素到最后一个元素组成的列  
表，即原来列表的 cdr。  
  
继续求值时，这个函数首先打印出它接收到的列表的第一个元素(也就是初始列表  
的第二个元素)。之后，if 表达式被求值，当它为“真”时，函数又用其列表的  
cdr 作为参量继续调用自身，这次传送的列表是初始列表的 cdr 的 cdr 了。(这是第  
二次循环)  
  
这个函数每调用自身一次，它都用一个更短的列表作为其参量。最后，这个函数  
在调用自身时使用一个空列表。print 函数将空列表打印为 nil。然后，条件表达  
式测试列表的值。因为这时列表的值是空(nil),if 表达式返回“假”，因而 if 表  
达式的 then 部不被求值。这个函数最终返回一个 nil。因此，当对这个函数求值  
时，你将看到两个 nil。  
  
当你在草稿缓冲区中对表达式(print-elements-recursively animals)求值时，你  
将看到这样的结果：  
  
giraffe   
  
gazelle  
  
lion  
  
tiger  
  
nil  
  
nil  
  
(其中第一个 nil 是打印的最后一个列表的值,第二个 nil 是整个函数的返回值。)  
  

----------------------- Page 121-----------------------

*** 11.2.2 用递归算法代替计数器  
  
在前一节中描述的 triangle 函数，可以用递归算法改写。它看起来就是：  
  
  (defun triangle-recursively (number)  
  "Return the sum of the numbers 1 through NUMBER inclusive.  
  Uses recursion."  
    (if (= number 1)               ;do-again-test  
        1                         ;then-part  
       (+ number                   ;else-part  
          (triangle-recursively    ;recursive call  
              (1- number)))))      ;next-step-expression  
  
(triangle-recursively 7)  
  
对这个函数求值，就能够将它安装到 Emacs 中，并且随后可以尝试对表达式  
(triangle-recursively 7)求值。(记住，将光标紧紧置于函数定义的最后一个括  
号之后、注释内容之前，才能正确安装这个函数。)  
  
为了理解这个函数是如何工作的，让我们考虑当函数被传递了 1、2、3、4 作为其  
参量的值时，在这些不同的情况下将发生什么？  
  
首先，如果参量的值是 1，将发生什么？  
  
这个函数定义中有一个 if 表达式，它紧接在文档字符串后。它测试变量 number 的  
值是否等于 1。如果是等于 1，Emacs 就对 if 表达式的 then 部求值，它将返回 1。1 就  
是函数的值。(只有一行的三角形，只有一块鹅卵石)  
  
然而，假设参量的值是 2。在这种情况下，Emacs 计算 if 表达式的 else 部。  
  
if 表达式的 else 部由一个加法、对 triangle-recursively 函数的递归调用以及一  
个递减表达式组成。就是：  
  
  (+ number (triangle-recursively (1- number)))  
  
当 Emacs 对这个表达式求值时，最内部的表达式首先被求值，然后是其他部分。具  
体步骤如下：  
  
第一步：对最内层的表达式求值。  
  
最内层的表达式是(1- number)，因此 emacs 将变量 number 的值从 2 递减到 1。  
  
第二步：计算 triangle-recursively 函数。  
  

----------------------- Page 122-----------------------

这个函数包含在其自身这一点并不要紧。Emacs 将第一步的结果作为参量传递给  
triangle-recursively 函数的这个实例。  
  
在这种情况下，Emacs 就用 1 作为参量的值对 triangle-recursively 函数求值。这  
意味着，这次求值的结果返回 1。  
  
第三步：计算变量 number 的值。  
  
变量 number 是以+开始的列表的第二个元素，它的值为 2。  
  
第四步：计算+表达式。  
  
这个+表达式接受两个参量，第一个参量的值来自对变量 number 的求值结果(即第  
三步的结果)，第二个参量的值来自对函数 triangle-recursively 求值的结果(即  
第二步的结果)。  
  
这个表达式的结果就是 2 加 1 的和——3，并且 3 这个值将作为函数值返回。即有两行  
的三角形只有 3 块鹅卵石。  
  
参量值为 3 的情况假设。  
  
用参量值为 3 调用 triangle-recursively 函数，此时的情况是：  
  
第一步：计算条件测试表达式。  
  
if 表达式首先被求值。这个条件表达式被求值时返回“假”，因此 if 表达式的  
else 部被求值。(注意，在这个例子中，这个条件测试表达式在结果为“假”时，  
使函数调用它自己，而不是在结果为“真”时调用它自己。)  
  
第二步：对 else 部中最内层的表达式求值。  
  
当 else 部最内层的表达式被求值时，将 3 递减为 2。这就是 next-step-expression  
的表达式(1- number)的作用。  
  
第三步：计算 triangle-recursively 函数。  
  
数 2 被传递给函数 triangle-recursively。通过前面的介绍，我们已经知道这种情  
况下 Emacs 对 triangle-recursively 函数(参量值为 2)求值时将得到什么结果。通  
过执行前面讲述的那些过程，函数返回 3。这就是这一步。  
  
第四步：计算加法表达式。  
  
数 3 将作为参量被传递给加法表达式，并且它将与函数调用时的参量的值 3 相加。  
结果就是 6。  

----------------------- Page 123-----------------------

  
整个函数的返回值，就是 6。  
  
现在，我们知道用 3 作为参量调用 triangle-recursively 函数时将得到什么结果以  
及如何得到的。因此，用 4 作为参量调用这个函数的情况也就很清楚了：  
  
在这个递归调用中，对表达式(triangle-recursively (1- 4))的求值将得到表达  
式(triangle-recursively 3)的值。这个值是 6。这个值与数值 4 在加法表达式的  
第三行相加。因此整个函数的返回值就是 10。  
  
triangle-recursively 函数每一次被求值，它就用比当前参量值小 1 的值调用它本  
身，直到参量值足够小、不能再调用本身为止。  
  
*** 11.2.3 使用 cond 的递归例子  
  
前面讲述的 triangle-recursively 函数，是用 if 特殊表编写的。这个函数也可以  
用另外一个被称为 cond 的特殊表编写。这个特殊表的名字 cond 是单词  
"conditinal"(条件)的缩写。  
  
虽然 cond 特殊表并不像 if 表达式那样在 Emacs Lusp 源代码中频繁使用，但它用得  
也相当多，解释它的使用也是很正当的。  
  
cond 表达式的模板如下所示：  
  
(cond  
   body...)  
  
其中，body 是一系列的列表。  
  
写得更详细些，cond 表达式模板应当如下所示：  
  
      (cond  
       (FIRST-TRUE-OR-FALSE-TEST FIRST-CONSEQUENT)  
       (SECOND-TRUE-OR-FALSE-TEST SECOND-CONSEQUENT)  
       (THIRD-TRUE-OR-FALSE-TEST THIRD-CONSEQUENT)  
       ...)  
  
当 Lisp 解释器对 cond 表达式求值时，它先计算 cond 表达式主体当中的一系列表达  
式中的第一个表达式的第一个元素(也就是这个表达式的 car 或者真假测试表达式)。  
  
如果这个真假测试表达式返回 nil，则这个表达式的其余部分（结果部分)就被忽  
略，而下一个表达式中的真假测试被求值。如果有一个表达式的真假测试结果不  
是 nil，则那个表达式的后续部分就被求值。后续部分可以是一个表达式也可以是  
多个表达式。如果后续部分是多个表达式组成的，则这些表达式被依次求值，并  

----------------------- Page 124-----------------------

且最后一个表达式的值被返回。如果这个表达式只有真假测试表达式而没有后续  
表达式，真假测试表达式的值就作为结果被返回。  
  
如果所有真假测试表达式的值都是“假”，则 cond 函数返回 nil。  
  
用 cond 特殊表来重写 triangle 函数，这个函数就是下面这个样子：  
  
(defun triangle-using-cond (number)  
   (cond ((< number 0) 0)  
         ((= number 1) 1)  
         ((> number 1)  
          (+ number (triangle-using-cond (1- number))))))  
  
在这个例子中，如果变量 number 的值小于或者等于零，cond 表达式就返回 0。如果  
number 的值等于 1，则返回 1。如果 number 大于 1，则计算(+ number  
(triangle-using-cond (1- number)))表达式的值。  
  
** 11.3 有关循环表达式的练习  
  
- 编写一个与 triangle 函数相似的函数，在这函数中，每一行的值等于所在行数  
  的平方。使用 while 循环来编写这个函数。  
  
- 编写一个与 triangle 函数相似的函数，求这些数的积而不是和。  
  
- 用递归的方法重新编写上面这两个函数。然后用 cond 表达式重新编写这两个函  
  数。  
  
- 为 Texinfo 模式编写一个函数，这个函数在每一个以"@dfn"开始的段落创建一个  
  索引入口。(在一个 Texinfo 文件中，"@dfn"标记一个函数定义。关于这方面的  
  详细资料，参见《Texinfo：GNU 文档格式》中关于“标记函数和命令等”的  
  一节。)  
  
* 第 12 章 正则表达式查询  
  
正则表达式查询在 GNU Emacs 中使用很广泛。forward-sentence 和  
forward-paragraph 这两个函数充分展示了如何使用正则表达式进行查询。  
  
在《GNU Emacs 技术手册》中的“正则表达式查询”一节和《GNU Emacs Lisp 技  
术手册)中的“正则表达式”一节都有正则表达式查询的有关内容。在编写这一章  
时，假定读者对正则表达式已经有所了解。要记住的最重要的一点是，正则表达  
式允许按一定的模式查询，也允许完全按照字符串字面意义进行查询。例如，  
forward-sentence 函数查询能够标记句子结束的可能的字符模式，并将位点移动  
到句子末尾。  
  

----------------------- Page 125-----------------------

在展示 forard-sentence 函数代码之前，分析什么肯定是标记句子结束的模式是值  
得的。这个模式在下一节讨论，随后的一节是对这个正则表达式查询函数  
re-search-forward 的描述。再后面一节描述 forward-sentence 函数。最后，在这  
一章的最后一节将讲解整个 forward-paragraph 函数。forward-paragraph-end 函  
数是一个复杂的函数，其中引入了 Emacs Lisp 函数的几个新特征。  
  
** 12.1 查询 sentence-end 的正则表达式  
  
符号 sentence-end 被绑定到标记句子结束的模式上。这个正则表达式应是怎样的  
呢？  
  
很清楚，一个句子可以以一个句点、一个问号或者一个感叹号结束。确实，只有  
当一个从句以上面三个符号之一结束才应被认为是一个句子的结束。这意味着，  
这个模式应当包括下面这个字符集：  
  
[.?!］  
  
然而，我们不希望 forward-sentence 函数仅仅移动到句点、问号或者感叹号之  
后，因为这样的字符可能出现在句子当中。例如，句点被用于缩写之后。因此，  
这种查询还需要其他信息。  
  
根据惯例，在每个句子之后空上两个空格，在句子当中的句点、问号和感叹号之  
后仅空一个空格。因此，句点、问号和感叹号后有两个空格的话，这就是标记一  
个句子结束的一个好的指示器。然而，在一个文件中，两个空格可能用 TAB 键或者  
换行符代替了。这意味着，这个正则表达式应当包含这三种情况。这组可选方案  
就是：  
  
\\($\\| \\|  \\)  
       ^   ^^  
      TAB  SPC  
  
其中，"$"符号表示一行的结束。在上面的例子中已经指出 TAB 键和两个空格插入  
到表达式中的情形。这两种情况都是将实际的字符插入到表达式中。  
  
括号和垂直线之前的两个反斜线"\\"是需要的：在 Emacs 中，第一个反斜线引用第  
二个反斜线；第二个反斜线指出后续的字符(即括号或垂直线)是特殊字符。  
  
而且，一个句子可以后接一个或者多个回车符，就像这样：  
  
[  
]*  
  
就像制表符(TAB 键)和空格一样，回车符(<RET>键)也是直接插入到正则表达式中  
的。上面这个星号表示回车符重复了零次或者多次。  

----------------------- Page 126-----------------------

  
但是一个句子结束并不仅仅是由句点、问号、感叹号及其后接的适当的空格组成  
的：空格之前可能还有一个右引号或者一个大右括号。确实，在空格之前可以有  
多于一个这样的引号或者大括号。这种情况需要下面的表达式：  
  
[]\"')}]*  
  
在这个表达式中，第一个"]"是这个表达式的第一个字符。第二个字符是“"”，  
它之前有一个“\”字符以告诉 Emacs 这个“"”字符不是特殊字符。最后三个字符  
是”'”，“)”和“}”。  
  
所有这些表示与一个句子结束相匹配的正则表达式应当是什么样的。确实，  
如果对 sentence-end 函数求值的话，将发现它返回下面这样的值：  
  
 sentence-end  
       => "[.?!][]\"')}]*\\($\\|  \\|  \\)[  
]*"  
  
  
 【Emacs 22 版以后对 sentence-end 求值是 nil。为了处理多种语言的断句问题，  
Emacs 采用了  (sentence-end) 函数。可以用 C-x C-e 对其求值，返回一个正则表  
达式。——Chiron 注】  
  
** 12.2 re-search-forward 函数  
  
re-search-forward 函数与 search-forward 函数非常相似。(参见 8.1.3 节，  
"search-forward 函数")。  
  
re-search-forward 函数查询一个正则表达式。如果查询成功，它就紧接在最后的  
目标字符后面设置位点。如果查询是朝后进行的，就在第一个目标字符之前设置  
位点。可以告诉 re-search-forward 函数在查询成功时返回“真”(t)。(移动位点  
只是这个函数的一个附带效果。)  
  
就像 search-forward 函数，这个 re-search-forward 函数也有四个参量：  
  
1) 第一个参量是函数要查询的正则表达式。这个正则表达式是一对引号之间的字  
   符串。  
  
2) 第二个参量是可选的，这个参量限制函数查询的范围；它是在缓冲区中指定一  
   个位置的约束值。  
  
3) 第三个参量是可选的，它告诉函数如何对查询失败作出响应：如果第三个参量  
   是 nil,函数在查询失败时产生一个错误消息；如果第三个参量是其他值，函数  
   在查询失败时返回 nil,查询成功时返回 t。  

----------------------- Page 127-----------------------

  
4) 第四个参量也是可选的，它是一个重复计数。一个负的重复计数使  
   re-search-forward 函数向后查询。  
  
re-search-forward 函数的模板是：  
  
(re-search-forward "regular-expression"  
                   limit-of-search  
                   what-to-do-if-search-fails  
                   repeat-count)  
  
第二、第三和第四个参量是可选的。然而，如果要给最后两个参量或者最后两个  
参量的任意一个参量传递一个值，必须要给其他前面的参量传递相应的值。否  
则，Lisp 解释器将不知道要将值传递给哪一个参量。  
  
在 forward-sentence 函数中，正测表达式将是变量 sentence-end 的值，也就是：  
  
"[.?!][]\"')}]*\\($\\|  \\|  \\)[  
]*"  
  
查询的范围至段落的末尾(因为一个句子不会超过一段)。如果查询失败，这个函  
数将返回 nil,重复计数将由函数 forward-sentence 的参量提供。  
  
** 12.3 forward-sentence 函数  
  
将光标移动到一个句子之后的命令，是展示如何在 Emacs Lisp 中使用正则表达式  
查询的简单例子。确实，这个函数看起来比它实际的更长、更复杂，这是因为这  
个函数设计成既可以朝前也可以朝后移动，作为可选项，也可以移过多个句子。  
这个函数通常绑定到命令键 M-e 上。  
  
下面是 forward-sentence 函数的代码：  
  
(defun forward-sentence (&optional arg)  
  "Move forward to next `sentence-end'.  With argument, repeat.  
With negative argument, move backward repeatedly to `sentence-beginning'.  
Sentence ends are identified by the value of sentence-end  
treated as a regular expression.  Also, every paragraph boundary   
terminates sentences as well."  
   (interactive "p")  
   (or arg (setq arg 1))  
   (while  (< arg 0)  
     (let ((par-beg  
        (save-excursion (start-of-paragraph-text) (point))))  
       (if (re-search-backward  

----------------------- Page 128-----------------------

        (concat sentence-end "[^ \t\n]") par-beg t)  
       (goto-char (1-  (match-end 0)))  
     (goto-char par-beg)))  
     (setq arg (1+ arg)))  
   (while (> arg 0)  
     (let ((par-end  
        (save-excursion (end-of-paragraph-text) (point))))  
       (if (re-search-forward sentence-end par-end t)  
       (skip-chars-backward " \t\n")  
     (goto-char par-end)))  
     (setq arg (1- arg))))  
  
 【这个函数的代码在 Emacs 23.2 版已经有些变化。——Chiron 注】  
  
这个函数初看起来很长，因此最好先来看看这个函数的骨架结构，然后再分析其  
 “肌肉”——具体的内容。这个函数的骨架结构由最靠左边的几个表达式组成：  
  
  (defun forward-sentence (&optional arg)  
  "documentation..."  
    (interactive "p")  
    (or arg (setq arg 1))  
    (while (< arg 0)  
      body-of-while-loop  
    (while (> arg 0)  
      body-of-while-loop  
  
这看起来简单多了。这个函数定义包含了文档、一个 interactive 表达式、一个  
or 表达式和两个 while 循环。  
  
让我们依次来分析这几个部分。  
  
文档部分是详尽的，也很容易理解。  
  
这个函数有一个交互的声明：(interactive "p")。这意味着，如果有前缀参量，  
就将其作为这个函数的参量传递给函数(这个参量将是一个数)。如果没有传递参  
量(参量是可选的)给这个函数，参量 arg 就被绑定到数值 1。当函数  
forward-sentence 是无参量、非交互调用时，arg 绑定到 nil。  
  
or 表达式处理前缀参量。它所做的，要么是保持 arg 的原值(仅当 arg 被绑定到一个  
值时),要么将 arg 的值设定为 1(在 arg 被绑定到 nil 的情况下)。  
  
1. while 循环  
  
在 or 表达式之后跟着两个 while 循环。第一个 while 循环有一个真假测试表达式，  

----------------------- Page 129-----------------------

当传递给 forward-sentence 函数的前缀参量是一个负数时，这个测试表达式结果  
为“真”。这是为朝后查询设置的。这个循环的主体与第二个 while 从句的循环体  
很相似，但是并不完全一样。我们将跳过这个 while 循环而首先关注第二个 while  
循环。  
  
第二个 while 循环完成将位点前移的工作。它的骨架结构是这样的：  
  
  (while (> arg 0)           ;true-or-false-test  
     (let varlist  
       (if (true-of-false-test)  
          then-part  
        else-part  
      (setq art (1- arg)))) ;while loop decrementer  
  
这个 while 循环是使用减量计数器的那一种循环(参见 11.1.4 节，“使用减量计数  
器的循环”。)它有一个真假测试表达式，只要计数器(在这里是变量 arg)的值大  
于零，测试的结果就为“真”。它同时有一个递减器，在每一次循环中将计数器  
的值减 1。  
  
如果没有前缀参量被传递给 forward-sentence 函数(这也是这个函数最常使用的方  
式),这个 while 循环只运行一次，因为变量 arg 的值在这种情况下默认为 1。  
  
while 循环体包含一个 let 表达式，这个 let 表达式创建并绑定一个局部变量。let  
表达式中又有一个作为 let 表达式主体的 if 表达式。  
  
这个 while 循环体如下所示：  
  
(let ((par-end  
        (save-excursion (end-of-paragraph-text) (point))))  
   (if (re-search-forward sentence-end par-end t)  
       (skip-chars-backward " \t\n")  
       (goto-char par-end)))  
  
其中，let 表达式创建并绑定局部变量 par-end。就像将要看到的，这个局部变量  
是为了给正则表达式查询提供一个边界和限制而设计的。如果查询没能在段落结  
束时找到正确的句子，它将在段落末尾停止查询工作。  
  
但是首先，要检查一下变量 par-end 是如何绑定到段落结束处的。这是 let 表达式  
在 Lisp 解释器完成对下面的表达式求值之后将其返回值赋给变量 par-end 来完成的。  
  
(save-excursion (end-of-paragraph-text) (point))  
  
在这个表达式中，(end-of-paragraph-text)将位点移动到段落末尾，(point)返  
回位点的值，然后 save-excursion 恢复位点当初的值。因而，let 表达式将  

----------------------- Page 130-----------------------

save-excursion 的返回值(也就是段落结束的位置)赋给变量 par-end。  
 （(end-of-paragraph-text)函数使用了 forward-paragraph 函数，在后面将对这  
个函数作简短的介绍。）  
  
Emacs 下一步计算 let 表达式主体，也就是下面的 if 表达式：  
  
(if (re-search-forward sentence-end par-end t) ;if-part  
     (skip-chars-backward " \t\n")              ;then-part  
   (goto-char par-end))                         ;else-part  
  
这个 if 表达式测试它的第一个参量是否为“真”。如果为“真”，就对它的 then  
部求值，否则 Emacs Lisp 解释器就对 else 部求值。if 表达式中的真假测试是一个  
正则表达式查询。  
  
看起来也许奇怪，这个正则表达式查询像 forward-sentedce 函数的“实际工  
作”，但是这是这种操作在 Lisp 中实现的常用方法。  
  
2． 正则表达式查询  
  
re-search-forward 函数查询句子的结束，也就是查询由正则表达式  
sentence-end 定义的模式。如果找到了这个模式——找到了句子的结束标  
志——re-search-forward 函数将完成两件事情：  
  
1) re-search-forward 函数完成一个附带效果，将位点移动到当前找到的句子结  
   束处。  
  
2) re-search-forward 函数返回一个“真”值。这是一个由 if 函数接收的值，它  
   意味着查询成功。  
  
这个函数的附带效果——移动位点——是在 if 函数被递交由查询的成功结束所返回的  
值之前被完成的。  
  
当 if 函数从对 re-search-forward 的成功调用中接收到返回的“真”值时，就对  
then 部，也就是表达式(skip-chars-backward " \t\n")求值。这个表达式朝后移  
动并忽略所有空格、制表符(tab 键)以及回车符，直到找到一个印刷字符为止，并  
将位点设置在这个字符之后。因为位点已经移动到标记句子结束的正则表达式模  
式末尾，这个动作就是将位点紧紧置于句子的结束打印字符之后，它通常就是一  
个句点。  
  
另一方面，如果 re-search-forward 函数没能找到表示句子结束的相应模式，则函  
数返回“假”。查询失败使 if 函数对它的第三个参量，也就是对表达式  
(goto-char par-end)求值，即将位点移动到段落的结尾。  
  
正则表达式查询特别有用，由 re-search-forward 说明的查询模式也随处可见。在  

----------------------- Page 131-----------------------

re-search-forward 中，查询就是通过 if 表达式的真假测试完成的。你将经常看到  
这个正则表达式，或编写包括这个正则表达式模式的代码。  
  
** 12.4 forward-paragraph：函数的金矿  
  
forward-paragraph 函数将位点朝前移动到段落末尾。它一般绑定到 M-}上。这个  
函数使用了大量很重要的函数，包括 let*、match-beginning 和 looking-at 函数。  
  
forward-paragraph 函数的定义比 forward-sentence 的函数定义长得多，因为它是  
查询一个段落。段落的每一行都可能以一个填充前缀开始。  
  
一个填充前缀由一个字符串组成，这个字符串在每一行开始处重复出现。例如，  
在 Lisp 代码中，对于一个成段的注释，习惯上用“;;;”开始。在文本模式中，4  
个空格组成另外一个通用的填充前缀，用于创建一个缩排段落。(详细情况参见  
 《GNU Emacs 手册》中的“填充前缀”一节。)  
  
填充前缀的存在，意味着除了能够找到从最左边一列开始的段落的结束处之外，  
forward-paragraph 函数还一定能够找到缓冲区中所有或许多行都是以填充前缀开  
始的段落的结束处。  
  
而且，有时实际上要忽略已经存在的填充前缀，特别是当空白行分割不同段落时。  
这是一个额外的复杂性。  
  
在此不将 forward-paragraph 函数的所有代码打印出来，只是打印其中的一些部分。  
如果读代码前未做任何准备，这个函数将使你望而生畏。  
  
从骨架结构上看，这个函数是这样的：  
  
(defun forward-paragraph (&optional arg)  
  "documentation..."  
   (interactive "p")  
   (or  arg (setq arg 1))  
   (let*  
      varlist  
     (while (< arg 0)        ;backward-moving-code  
      ...  
       (setq arg (1+ arg)))  
     (while (> arg 0)        ;forward-moving-code  
      ...  
       (setq arg (1- arg)))))  
  
这个函数的前面部分是通常的样子：函数的参量列表由一个可选参量组成，后面  
跟着函数文档。  
  

----------------------- Page 132-----------------------

interactive 中小写的"p"意味着，如果有前缀参量，就将其传递给这个函数。这  
个前缀参量是一个数，是关于要移动多少段落位点的重复计数。后面一行中的 or  
表达式处理没有前缀参量传递给函数的情况，这种情况可能发生在这个函数被其  
他代码调用而不是交互地调用之中。这种情况在前面已经讲到过(参见 12.3 节，  
 “forward-sentence 函数”)，这里就不再重复。好了，到现在为止，这个函数中  
熟悉的部分都已讲完了。下面介绍其中的一些新东西。  
  
1. let* 表达式  
  
forward-paragraph 函数的后续一行开始于一个 let*表达式。这是一种与我们前面  
接触过的表达式不同的表达式。符号 let*不是 let!  
  
除了 Emacs 将变量依次赋值之外，let*特殊表与 let 相似。let*表达式中，变量列  
表中后面的变量可以使用前面的变量已经由 Emacs 设置的值。  
  
在这个函数的 let*表达式中，Emacs 绑定了两个变量：fill-prefix-regexp 和  
paragraph-separate。其中变量 paragraph-separate 的值依赖于变量  
fill-prefix-regexp 的值。  
  
让我们逐个来看一看。符号 fill-prefix-regexp 被设置为对下面的列表求值所返  
回的值：  
  
(and fill-prefix  
      (not (equal fill-prefix ""))  
      (not paragraph-ignore-fill-prefix)  
      (regexp-quote fill-prefix))  
  
这个表达式的第一个元素是 and 函数。  
  
and 函数不停地对它的参量求值，直到遇到一个返回值为 nil 的参量为止。这时  
and 表达式的返回值就是 nil。然而，如果没有一个参量的值是 nil，则最后一个参  
量的值作为表达式的值被返回。(因为这个值不是 nil，它在 Lisp 中被认为是  
 “真”。)换句话说，一个 and 表达式只有当它的所有参量的值都是“真”的时  
候，才返回“真”值。  
  
在这个例子中，只有当下面四个表达式都产生一个“真”值(如非空值)时，变量  
fill-prefix-regexp 才被绑定到一个非空值上；否则这个变量就被绑定到 nil。  
  
- fill-prefix  
  
  当这个变量被求值时，填充前缀的值被返回。如果没有填充前缀，这个变量返  
  回 nil。  
  
-  (not (equal fill-prefix "")  

----------------------- Page 133-----------------------

  
  这个表达式检查填充前缀是否是一个空白字符串(即没有字符的字符串)。空白  
  字符串是没有什么用处的填充前缀。  
  
-  (not paragraph-ignore-fill-prefix)  
  
  当变量 paragraph-ignore-fill-prefix 已经被赋值为一个“真值”(如 t)之后，这  
  个表达式返回 nil。  
  
-  (regexp-quote fill-prefix)  
  
  这是 and 函数的最后一个参量。如果所有的参量都是“真”值，对这个表达式  
  求值的结果将作为 and 表达式的返回值返回，这个返回值被绑定到变量  
  fill-prefix-regexp。  
  
对 and 表达式的成功求值，就使变量 fill-prefix-regexp 绑定到 fill-prefix 的值  
上。这个值由 regexp-quote 函数修改。regexp-quote 函数所做的就是读入一个字  
符串并返回一个精确匹配这个字符串的正则表达式。这意昧着，如果填充前缀存  
在，fill-prefix-regexp 将被设置为与填充前缀精确匹配的值。否则，这个变量  
被设置为 nil。  
  
let*表达式中的第二个局部变量是 paragraph-separate。它被绑定到对下面的表  
达式求值所返回的值上：  
  
(if fill-prefix-regexp  
     (concat paragraph-separate  
     "\\|^" fill-prefix-regexp "[ \t]*$")  
    paragraph-separate)))  
  
这个表达式解释了为什么使用 let*表达式而不是使用 let 表达式。if 表达式的真假  
测试依赖于变量 fill-prefix-regexp 的值是 nil 还是其他值。  
  
如果变量 fill-prefix-regexp 没有值(即它为 nil)，Emacs 对 if 表达式的 else 部求  
值，并将变量 paragraph-separate 绑定到它的局部值上。(paragraph-separate 是  
一个正则表达式，是用于匹配分离的段落的正则表达式模式。)  
  
但是如果 fill-prefix-regexp 变量确实有一个值(非空值)，Emacs 就计算 if 表达式  
的 then 部，并将 paragraph-separate 绑定到一个正则表达式上，这个正则表达式  
包含 fill-prefix-regexp 作为模式的一部分。  
  
特别地，paragraph-separate 被设置成匹配分离的段落的正则表达式的初始值，  
并在其后追加一个可供选择的表达式，这个追加的表达式由 fill-prefix-regexp  
加上一个空行组成。其中的“^”符号表示 fill-prefix-regexp 必须是一行的开  
始，行末的可选空格由"[ \t]*$"定义。"\\|"则定义了分离的段落的另外一种匹  

----------------------- Page 134-----------------------

配方式。  
  
现在进入 let*表达式的主体。这个 let*表达式主体的第一部分处理当这个函数被  
赋一个负参量并因此使位点朝后移动时的情况。我们的讨论将跳过这一部分。  
  
2. 朝前查询的 while 循环  
  
let*表达式主体的第二部分处理位点的朝前移动。它是一个 while 循环。只要变量  
arg 的值大于零，这个循环就不停地重复下去。在使用这个函数的绝大多数情况  
下，arg 变量的值是 1，因此这个 while 循环体正好被求值 1 次，光标向前移动一个  
段落。  
  
这部分代码处理三种情况：当位点处于两个段落之间时；当位点处于一个有填充  
前缀的段落当中时；当位点处于一个没有填充前缀的段落当中时。  
  
while 循环看起来是这样的：  
  
(while (> arg 0)  
    (beginning-of-line)  
  
   ;;between paragraphs  
   (while (prog1 (and (not (eobp))  
                      (looking-at paragraph-separate))  
           (forward-line 1)))  
  
   ;;within paragraphs, with a fill prefix  
   (if fill-prefix-regexp  
      ;;There is a fill prefix; it overrides paragraph-start.  
     (while (and (not (eobp))  
                 (not looking-at paragraph-separate))  
            (looking-at fill-prefix-regexp))  
      (forward-line 1))  
  
   ;;within paragraphs, no fill prefix  
   (if (re-search-forward paragraph-start nil t)  
       (goto-char (match-beginning 0))  
     (goto-char (point-max))))  
  
  (setq arg (1- arg)))  
  
我们能够立即看出，这是一个使用减量计数器的 while 循环，它使用表达式(setq  
arg (1- arg))作递减计数操作。循环体由三个表达式组成：  
  
;;between paragraphs  

----------------------- Page 135-----------------------

(beginning-of-line)   
(while  
     body-of-while)  
  
;; within paragraphs, with fill prefix  
   (if true-or-false-test  
      then-part  
  
;; within paragraphs, no fill prefix  
    else-part  
  
当 Emacs Lisp 解释器对 while 循环体求值时，第一件事情就是计算表达式  
(beginning-of-line)的值，并将位点移动到这一行的开始。随后，函数中有一个  
内层的 while 循环。这个 while 循环是为将光标移出段落之间的空白处而设计的，  
如果光标碰巧正好在段落之间的空白处，就需要用到这个 while 循环。最后，有一  
个 if 表达式，这个表达式完成真正将位点移动到段落末尾的操作。  
  
3. 在段落之间的情况  
  
首先，看看内层的 while 循环。这个循环处理位点处于段落之间的情况。它使用三  
个新函数：prog1、eobp 和 looking-at。  
  
- prog1 函数与 progn 函数类似。不同之处在于 prog1 函数依次对它的参量求值并  
  将其第一个参量的值作为整个表达式的值返回(progn 函数将它最后一个参量的  
  值作为这个表达式的值返回)。prog1 的第二个和第三个参量只是作为附带效果  
  被求值的。  
  
- eobp 是"End of Buffer P"(缓冲区的末尾)的缩写。当位点处于这个缓冲区末  
  尾时，这个函数返回“真”。  
  
- 当紧跟在位点之后的文本与传递给 looking-at 函数作为其参量的正则表达式匹  
  配时，looking-at 函数返回“真”。  
  
现在学习的这个 while 循环看起来是这样的：  
  
(while (prog1 (and (not (eobp))  
                    (looking-at paragraph-separate))  
               (forward-line 1)))  
  
这是一个没有循环体的 while 循环。循环的真假测试就是待计算的表达式：  
  
(prog1 (and (not (eobp))  
             (looking-at paragraph-separate))  
        (forward-line 1)))  

----------------------- Page 136-----------------------

  
prog1 函数的第一个参量是 and 表达式。在其内部有一个关于位点是否在缓冲区末  
尾的测试表达式，以及关于位点后的模式是否与分隔段落的正则表达式匹配的测  
试。  
  
如果光标不在缓冲区的末尾，并且如果光标后面的宇符表示两个分离的段落，则  
and 表达式为“真”。对 and 表达式求值之后，Lisp 解释器对 prog1 表达式的第二个  
参量 forward-line 求值。这个表达式使位点向前移动一行。然而，prog1 函数的返  
回值是其第一个参量的值，因此只要位点不在缓冲区的末尾而在两个段落之间  
时，while 循环将继续执行下去。最后，当位点被移动到一个段落时，and 表达式  
的值为“假”。然而要注意，forward-line 命令仍然要执行，这意味着，当位点  
从两个段落之间移动到一个段落当中时，它处于这个段落第二行的开头位置。  
  
4. 在段落当中的情况  
  
外层 while 循环的下一个表达式就是 if 表达式。当 fill-prefix-regexp 变量是一个  
非空值时，Lisp 解释器执行 if 表达式的 then 部。当 fill-prefix-regexp 变量的值  
是 nil 时(也就是没有填充前缀时)，Lisp 解释器执行 if 表达式的 else 部。  
  
5. 没有填充前缀的情况  
  
在没有填充前缀的情况下，代码是最简单的。这部分代码也由另一个内层 if 表达  
式组成，就像下面这样：  
  
(if (re-search-forward paragraph-start nil t)  
     (goto-char (match-beginning 0))   
   (goto-char (point-max)))  
  
这个表达式完成的工作实际上是 forward-paragraph 命令应当完成的主要工作：正  
则表达式查询，这个查询一直持续到下一段落的开始处。如果查询成功，则将位  
点移动到那里。但是，如果没有找到下一个段落的开始位置，它将位点移动到缓  
冲区中可访问区域的末尾。  
  
这部分代码中你唯一不熟悉的部分就是 match-beginnning 的使用。这是另外一个  
新函数。match-beginning 函数最终返回一个数，这个数指定与最后一个正则表  
达式查询匹配的文本的开始处的位置。  
  
因为这是一个具有代表性的查询过程，因此在这里使用了 match-beginning 函数。  
一个成功的朝前查询，不论它是一个普通的查询还是一个正则表达式查询，都将  
位点移动到找到的文本末尾。在这个例子中，一个成功的查询，会将位点移动到  
paragraph-start 正则表达式模式末尾。这是下一段落的开始而不是当前段落的结  
束。  
  
然而，我们的目的是要将位点置于当前段落的末尾，而不是将位点置于下一段落  

----------------------- Page 137-----------------------

的开始。这两个位置是不同的，因为可能有几个空行在段落之间。  
  
当给 match-beginning 函数传递参量 0 时，这个函数返回最近与正则表达式匹配的  
下一个段落的开始位置。在这个例子中，最近的正则表达式查询就是查询  
paragraph-start，因此 match-beginning 函数返回这个正则表达式模式的开始位  
置，而不是这个模式的末尾位置。开始的位置就是段落的末尾。  
  
(顺便提一下，当给 match-beginning 传递一个正数作为参量时，这个函数将使位  
点置于最后一个正则表达式中带括号的表达式处。这是一个很有用的函数。)  
  
6. 有填充前缀的情况  
  
刚才讨论的内层 if 表达式是外层 if 表达式的 else 部。这个 if 表达式判断是否存在  
填充前缀。如果有填充前缀，这个 if 表达式的 then 部被求值。就像下面这样：  
  
(while (and (not (eobp))  
             (not (looking-at paragraph-separate))  
             (looking-at fill-prefix-regexp))  
   (forward-line 1))  
  
只要下面三种条件都为真，这个表达式就将位点向前一行一行地移动：   
  
1) 位点不在缓冲区的末尾。  
  
2) 位点后面的文本不分隔段落。  
  
3) 位点之后的模式是有填充前缀的正则表达式。  
  
除非你记得在 forward-paragraph 函数中位点被移动到一行的开始位置，否则最后  
这个条件可能使人疑惑。这意味着如果文本有填充前缀，looking-at 函数就将发  
现它。  
  
7. 小结  
  
总的来说，当朝前移动时，forward-paragraph 函数完成下面的工作：  
  
- 将位点移动到一行的开始位置。  
  
- 跳过段落之间的空行。  
  
- 检查是否有填充前缀，如果有：  
   
  - 只要不是分隔段落的空行，就要一行一行地向前移动。  
  

----------------------- Page 138-----------------------

- 但是，如果没有填充前缀：  
  
  - 查询下一个段落开始的模式。  
  
  - 移动到下一个段落开始模式处，这将是前一个段落的末尾。  
  
  - 否则移动到缓冲区中可访问区域的末尾。  
  
  
为复习方便，下面列出的是刚才讨论过的代码。为清楚起见，用缩进的方式将它们排列起来：  
  
(interactive "p")  
(or arg (setq arg 1))  
(let* (  
        (fill-prefix-regexp  
     (and fill-prefix (not (equal fill-prefix ""))  
          (not paragraph-ignore-fill-prefix)  
          (regexp-quote fill-prefix)))  
  
        (paragraph-separate  
     (if fill-prefix-regexp  
         (concat paragraph-separate  
            "\\|^"  
            fill-prefix-regexp  
            "[ \t]*$")  
      paragraph-separate)))  
  backward-moving-code (omitted)...  
  
   (while (> arg 0)         ;forward-moving-code  
     (beginning-of-line)  
  
     (while (prog1 (and (not (eobp))   
                (looking-at paragraph-separate))  
          (forward-line 1)))  
  
     (if fill-prefix-regexp  
     (while (and (not (eobp))   ;then-part  
             (not (looking-at paragraph-separate))  
             (looking-at fill-prefix-regexp))  
       (forward-line 1))  
                     ;else-part:the inner-if  
       (if (re-search-forward paragraph-start nil t)  
       (goto-char (match-beginning 0))  
     (goto-char (point-max))))  

----------------------- Page 139-----------------------

  
     (setq arg (1- arg)))))              ;decrementer  
  
forward-paragraph 函数的完整定义，不仅包含这些朝前移动的代码，而且包含朝  
后移动的代码。  
  
如果你在 GNU Emacs 中阅读这份文档，并且你想要看一看 forward-paragraph 函数  
的完整代码，可以键入 M-. (find-tag)并在提示符下输入函数名来查看。如果  
find-tag 函数首先问你"TAGS" 表的文件名，就输入你的"emacs/src"目录中  
"TAGS"文件的文件名，这是一个类似"/usr/local/lib/emacs/19.23/src/TAGS"的  
路径名。("emacs/src"目录的确切路径由你的 Emacs 拷贝安装的方式和位置决定。  
如果不知道路径，有时能用 C-h I 命令进入 Info，然后键入 C-x C-f 来查看  
"emacs/info"的实际路径。"TAGS"文件的路径对应着"emacs/src"的路径。然而，  
有时 Info 文件存放在其他地方。)  
  
如果尚没有"TAGS"(标签文件)，你也能够创建自己的"TAGS"文件。  
  
** 12.5 创建自己的"TAGS"文件  
  
你能够创建自己的"TAGS"文件来帮助你访问源代码。例如，如果你有大量的文件  
在你的"~/emacs" 目录中(就像我这样，我有 127 个.el 文件，而我希望载入 17 个)，  
你将发现如果创建了自己的"TAGS"文件，即使你使用 grep 命令或者别的命令来查  
找特定的函数，也能很容易地找到特定的函数。  
  
你能够通过调用 etags 程序来创建自己的"TAGS"文件。这个程序是作为 Emacs 发行  
版本的一部分发行的。通常，etags 程序在 Emacs 安装时就会被编译和安装。  
(etags 不是 Emacs Lisp 的一个函数或者 Emacs 的一部分，它是一个 C 语言函数。)  
  
要创建一个"TAGS"文件，首先要切换到需要创建这个"TAGS"文件的目录。在  
Emacs 中，可以用 M-x cd 命令来切换到指定的目录，或者通过访问该目录下的一个  
文件，或者通过 C-x d(dired)命令列出这个目录下的文件，来达到切换目录的目  
的。然后输入：  
  
M-! etags *.el  
  
来创建一个"TAGS"文件。etags 程序接收所有常用的 shell 的通配符。例如，如果  
需要为两个不同的目录创建一个共同的"TAGS"文件，输入以下这样一个命令就可  
以了，其中"../elisp/"是第二个目录：  
  
M-! etags *.el ../elisp/*.el  
  
输入  
  
M-! etags --help  

----------------------- Page 140-----------------------

  
则可以列出 etags 程序能够接受的所有选项的列表。  
  
这个 etags 程序能处理 Emacs Lisp、common Lisp、Scheme、C、Fortran、Pascal、  
LaTeX 以及大部分汇编语言。这个程序对不同的语言没有什么特殊的开关选项，它  
根据文件名以及文件的内容来识别文件所属的语言类型。  
  
同样，当你自己编写函数代码并且希望参考自己已经编写好的函数时，etags 程序  
就很有用。只要你在编写新的函数时不时地运行 etags 程序，就可以将这些新编写  
的函数变成"TAGS"文件的一部分。  
  
** 12.6 回顾  
  
以下是最近介绍的函数的简要总结。  
  
- while  
  
  只要表达式主体的第一个元素的测试为“真”，这个表达式的主体就被不断地  
  重复求值。最后返回 nil。(其中的表达式只是作为它的附带效果而被求值的。)  
  
  例如：  
  
   (let ((foo 2))  
     (while (> foo 0)  
       (insert (format "foo is %d.\n" foo))   
       (setq foo (1- foo))))  
    
    =>   foo is 2.  
         foo is 1.  
         nil   
    
   (insert 函数的工作就是在位点处插入它的参量。而 format 函数的作用就是以其  
  参量的格式返回一个字符串，就像 message 函数一样，\n 产生一个新行。)  
  
- re-search-forward  
  
  查询一种模式，并且如果找到这种模式，就将位点移动到那个位置。  
    
  同 search-forword 函数一样，这个函数也接受四个参量：  
    
  1) 一个指定要查找的模式的正则表达式。  
    
  2) 可选的参量，即查询限制范围。  
    

----------------------- Page 141-----------------------

  3) 可选参量，如果查询失败，返回 nil 值或者产生错误消息。  
    
  4) 可选参量，重复查询的次数；如果这个参量的值为负，表示查询朝后进行。  
    
  
- let*  
  
  将局部变量绑定到指定的值上，然后对剩余的变量求值，它的返回值是最后一  
  个参量的值。在绑定局部变量时，如果有的话就使用已经绑定的局部变量的值。  
  
  例如：  
  
   (let* ((foo 7)  
         (bar (* 3 foo)))  
      (message "'bar' is %d." bar))  
        => 'bar' is 21.  
    
- match-beginning  
  
  返回由最后一个正则表达式查询所找到的文本的开始位置。  
  
- looking-at  
  
  如果位点后的文本与正则表达式匹配，就返回“真”(t)。  
  
- eobp  
  
  如果位点是缓冲区的可访问区域的末尾，就返回“真”(t)。如果变窄没有开  
  启，缓冲区中可访问区域的末尾就是缓冲区的末尾；如果变窄开启，它就是变  
  窄部分的末尾。  
  
- prog1  
  
  依次对其每一个参量求值，然后返回第一个参量的值。  
  
  例如：  
  
   (prog1 1 2 3 4)  
       =>1  
  
** 12.7 练习：使用 re-search-forward  ·  
  
- 编写一个函数，这个函数通过一个正则表达式来查询两个或者更多的连续空行。  
  

----------------------- Page 142-----------------------

- 编写一个函数，用来查询重复的单词，如"the-the"。关于如何编写一个正则表  
  达式来匹配由两个相同部分组成的字符串，可以参见《GNU Emacs 手册》中的  
   “正则表达式句法”一节。你能为此设计出几个正则表达式，一些比另一些更  
  好。我使用的这个函数以及几个正则表达式附在附录 A"the-the 重复单词函数"  
  中。  
  
* 第 13 章 计数：重复和正则表达式  
  
重复和正则表达式查询是你在 Emacs Lisp 中编写代码时经常使用的功能强大的工  
具。这一章介绍在用 while 循环和递归方法构造的单词计数命令中正则表达式查询  
的使用情况。  
  
在 Emacs 的标准发行版本中，包含了对一个区域内所有行进行计数的函数。然而，  
却没有对其中的单词进行计数的相应函数。  
  
某些写作需要对单词进行计数。因而，如果你撰写一篇随笔，篇幅可以限制在  
800 字之内；如果你撰写一篇小说，可以规定自己一天撰写 1000 字。Emacs 竟然缺  
少一个单词计数命令，这令我很奇怪。也许，人们使用 Emacs 的目的主要是编写代  
码或者那些不需要进行单词计数的文档，或者也许他们只是使用操作系统的单词  
计数命令。这个命令将文档中的字符数除以 5 得到单词数。无论如何，这里有一些  
单词计数命令。  
  
** 13.1 count-words-region 函数  
  
一个单词计数命令可以对一行、一个段落、一个区域或者一个缓冲区进行计数。  
这个命令应当包含哪些内容呢？你应当设计一个命令来对整个缓冲区中的单词进  
行计数。然而，Emacs 的传统鼓励程序富有弹性——即可以只对一节中的单词计数，  
而不是对一个缓冲区中的单词计数。因此，编写一个对一个区域计数的命令更有  
意义。一旦有一个 count-words-region 命令，如果愿意的话，也能够用 C-x h  
(mark-whole-buffer)键序列对整个缓冲区中的单词计数。  
  
很清楚，对单词计数是一个重复的动作：从这个区域的头部开始，对第一个单词  
开始计数，然后是第二个、第三个……等等，直到这个区域的末尾。这意味着单  
词计数使用递归的方法或者 while 循环是很理想的。  
  
首先，将用 while 循环实现这个单词计数命令，然后用递归的方法实现这个命令。  
当然，这个命令将是交互的。  
  
一个交互函数定义的模板总是这样的：  
  
(defun name-of-function (argument-list)  
  "documentation..."  
   (interactive-expression...)  
  body...)  

----------------------- Page 143-----------------------

  
现在需要做的就是往其中填入适当的内容。  
  
函数名应当直接表明自己的用途而无需另加说明，并且应当与已有的  
count-lines-region 函数名相似。这可以使函数名易于记住。因此  
count-words-region 是单词计数函数名的一个好选择。  
  
这个函数对一个区域中的单词计数。这意味着参量列表一定要包含绑定到两个位  
置的符号，这两个位置就是该区域的开始位置和结束位置。这两个位置可以分别  
被叫做"beginning"和"end"。文档的第一行应当是一个完整的句子，因为像  
apropos 这样的命令将只打印函数说明文档的第一行。交互表达式的形式将是  
 “(interactive "r")”，因为这将使 Emacs 将计数区域的开始位置和结束位置作  
为参量传递给这个函数。所有这些都是按部就班的。  
  
需要编写函数体以使其完成这样三件任务：首先建立 while 循环的条件，其次是  
while 循环，最后是发送一个消息给用户。  
  
当用户调用 count-words-region 函数时，位点可能是在指定区域的开始，也可能  
是在末尾。然而，计数过程必须从区域的开始位置开始。这意味着，如果位点原  
来并不在指定区域的开始处，就要使位点移动到那里。执行(goto-char  
beginning)可以达到这个目的。当然，当函数执行完之后，要将位点返回到调用  
这个函数时的位置。为了这个原因，函数体必须包含在一个 save-excursion 表达  
式中。  
  
函数体的中心部分由一个 while 循环组成，在这个循环中，一个表达式使位点一个  
单词一个单词地往前移动，另外一个表达式对移动的次数计数。只要位点还要继  
续往前移动，while 循环的真假测试结果应当为“真”，当位点到达指定区域的末  
尾时，真假测试结果为“假”。  
  
将使用(forward-word 1)作为表示向前一个单词一个单词地移动位点的表达式，  
但是如果使用一个正则表达式查询，就更容易看到 Emacs 是如何区分一个单词的。  
  
正则表达式查询不仅查找一个模式，而且在找到之后将位点移动到其后。这意味  
着，一系列成功的正则表达式查询将使位点一个单词一个单词地向前移动。  
  
实际的问题是，我们想要正则表达式查询直接跳过单词之间的空格和标点符号，  
就像跳过单词本身一样。一个拒绝跳过单词之间空格的正则表达式永远不会跳过  
多于一个的单词。这就是说，如果有空格和标点符号，正则表达式应当包含单词  
之后的这些空格和标点符号，把它们当做单词本身一样处理。(一个可能的情况  
是，一个单词可能结束一个缓冲区，而没有任何空格或者标点符号在其后，因此  
正则表达式的这个部分是可选的。)  
  
因而，我们需要的这个正则表达式是一个模式，它定义一个或多个单词构词要素  
以及其后(可选的)的一个或多个不是单词构词要素的其他字符。这个正则表达式  

----------------------- Page 144-----------------------

就是：  
  
\w+\W*  
  
缓冲区语法表决定了哪些字符是单词的构词要素而哪些字符不是单词的构词要素。  
(有关语法的更多内容参见本书的 14.2 节，“单词或者符号是由什么构成的？”。  
同时，还可参见《GNU Emacs 手册》的“语法表”一节以及《GNU Emacs Lisp 技  
术手册》的“语法表”一节)。  
  
查询表达式是这样：  
  
(re-search-forward "\\w+\\W*")  
  
(注意在"w"和"W"之前的成对的反斜线。对 Emacs Lisp 解释器来说，单个反斜线是  
有特殊意义的。它指后续的字符以不同于平常的方式被解释。例如，字符"\n"代  
表"newline" (即换行)，而不是一个反斜线和一个字母"n"。一行中两个连续的反  
斜线则代表一个通常的没有特殊意义的反斜线。)  
  
需要一个计数器来对单词个数进行计数。这个变量必须首先设置为 0，然后 Emacs  
每循环一次，这个计数器就加 1。这个递增表达式很简单：  
  
(setq count (1+ count))  
  
最后，想要告诉用户在这个区域中有多少单词。message 函数就适合于用来向用户  
发出这种消息。这个消息必须是一个短语的形式，这样不管其中究竟有多少单  
词，它读起来总是正确的。我们不要这样的句子"there are 1 words in the  
region"(有英文语法错误)。单数和复数之间的冲突是不符合英文语法规则的。用  
一个条件表达式根据这个区域中单词数目的不同给英文出不同的消息就能够解决  
这个问题。这里有三种可能：没有单词，一个单词，多于一个单词。这意味着在  
这里使用 cond 特殊表很合适。  
  
所有这些综合起来就是下面这个函数定义：   
  
      ;; First version; has bugs!  
      (defun count-words-region (beginning end)  
       "Print number of words in the region.  
     Words are defined as at least one word-constituent character followed  
     by at least one character that is not a word-constituent.  The buffer's  
     syntax table determines which characters these are."  
        (interactive "r")  
        (message "Counting words in region ... ")  
  
      ;;; 1. Set up appropriate conditions.  
        (save-excursion  

----------------------- Page 145-----------------------

          (goto-char beginning)  
          (let ((count 0))  
  
      ;;; 2. Run the while loop.  
            (while (< (point) end)  
              (re-search-forward "\\w+\\W*")  
              (setq count (1+ count)))  
  
      ;;; 3. Send a message to the user.  
            (cond ((zerop count)  
                   (message "The region does NOT have any words."))  
                  ((= 1 count) (message "The region has 1 word."))  
                  (t (message "The region has %d words." count))))))  
  
就像写着的那样，这个函数可以正常工作，但是它并没有涵盖所有的情况。  
  
count-words-region 中的空格 bug  
  
前一节描述的 count-words-region 函数命令中有两个 bug，或一个 bug 的两种表现。  
第一，如果你标记的那个区域只有在某些文本当中包含空格，那个函数就会告诉  
你这个区域只包含一个单词。第二，如果你标记的区域只有在缓冲区的末尾或者  
在变窄的缓冲区的可以访问区域的末尾处包含一些空格，这个命令会显示一条这  
样的错误消息：  
  
Search failed: "\\w+\\W*"  
  
如果你是在 GNU Emacs 的 Info 中阅读这份文档，你可以自己测试这些 bug。  
  
首先，以通常方式对上面那个函数定义求值以安装它。  
  
如果愿意的话，你也可以通过对下面这个表达式求值来安装这个绑定键：  
  
(global-set-key "\C-c=" 'count-words-region)  
  
为了测试第一个 bug，在下面这一行的开始和末尾设置标记和位点，然后键入  
C-c= (如果你没有绑定 C-c=，就使用 M-x count-words-region 命令):  
  
    one two three  
  
 【注：在 org-mode 里 C-c = 被绑定到 org-table-eval-formula 函数。所以如果在  
org-mode 里阅读本文档，应使用 M-x count-words-region 方式。——Chiron 注】  
  
Emacs 将正确地告诉你这个区域有三个单词。  
  

----------------------- Page 146-----------------------

重复这个测试，这次将标记置于这一行的开始，而将位点紧紧置于单词“one”之  
前。再一次键入 C-c= (或者 M-x count-words-region)。这时 Emacs 应当告诉你这  
个区域没有任何单词，因为它仅仅是由这一行的开始部分的空格组成的。但  
是，Emacs 会告诉你这里有一个单词!  
  
再来进行第三次测试，将这一行拷贝到“*scratch*”缓冲区的末尾，然后在这一  
行的末尾输入几个空格。将标记置于单词“three”之后，并将位点置于这一行的  
末尾(也就是缓冲区的末尾)。再像前面那样键入 C-c= (或者 M-x  
count-words-region)，这时 Emacs 也应当告诉你这个区域没有任何单词，因为它  
只有这一行末尾的几个空格而已。但是，Emacs 显示一个错误消息："search  
failed"。  
  
这两个 bug 源自同样一个问题。  
  
首先，考虑这个 bug 的第一个表现。在这里，命令告诉你位于一行开始处的空格包  
含了一个单词。这是因为，M-x count-words-region 命令将位点移动到了区城的  
开始处。while 循环测试位点的这个值是否小于 end 的值，这个测试为“真”。相  
应地，正则表达式查找并找到第一个单词。Emacs 将位点置于这个单词之后，  
count 变量被设置为 1。while 循环继续循环，但是这一次位点的值大于 end 变量的  
值，退出循环。简单地说，正则表达式查询查找并找到一个被标记的区域之外的  
单词。  
  
在 bug 的第二种表现中，指定的区域是缓冲区末尾的空格。Emacs 发出"Search  
fai1ed"的消息。这是因为，while 循环的真假测试值为“真”，因此查询表达式  
被求值，但是由于这个区域没有单词，因此查询失败。  
  
在这个 bug 的两种表现当中，前一种是查询范围扩大了，后一种是试图到指定区域  
之外查询。  
  
解决办法是限制查询的区域——这个动作相当简单，但是就像你将要看到的，它的  
实现方式实际上并非你想象的那么简单。  
  
就像我们已经看到的，re-search-forward 函数接受一个查询模式作为它的第一个  
参量。但是除了这个强制性的参量之外，它还接受三个可选参量。可选的第二个  
参量限定查询范围。可选的第三个参量，如果是 t，就使函数在查询失败时返回  
nil 而不是发出一个错误消息。可选的第四个参量是一个重复计数器。(在  
Emacs 中，你能够用 C-h f 加上函数名和回车符(RET 键)得到一个函数的说明文档。)  
  
在 count-word-region 函数定义中，指定区域的末尾的值是由变量 end 存放的，这  
个值作为一个参量传递给函数。因而，能够将 end 作为一个参量加入到正则表达式  
的查询表达式中：  
  
(re-search-forward "\\w+\\W*" end)  
  

----------------------- Page 147-----------------------

然而，如果你仅在 count-words-region 的函数定义中做了这样的改变，并在一组  
空格上继续测试这个新版函数定义，你将得到一个错误消息声明查询失败：  
"Search fai1ed"。  
  
出现这样问题的原因在于：查询被限制在这个区域中，而这其中没有组成单词的  
字符。因为查询失败，我们得到一个错误消息。但是我们不希望在这种情况下得  
到这样的一个错误消息。我们希望得到的消息是："The region does NOT have  
any words"。  
  
这个问题的解决方法是为 re-search-forward 提供第三个参量 t，这使得函数当查  
询失败时返回 nil，而不是一个错误消息。  
  
然而，如果你做出这样的改动并测试它，你将看到信息"Counting words in  
region..."，并将一直看到这个消息，直到键入 C-g (keyboard-quit)为止。  
  
这是因为，就像前面一样，查询被限制在指定区域，由于这个区域没有单词构词  
要素字符，因此查询就像希望的那样失败了。相应地，re-search-forward 表达式  
返回 nil，什么也没有做。特别是，它没有移动位点，这原本是作为找到查询目标  
的一个附带效果实现的。在 re-search-forward 表达式返回 nil 之后，while 循环中  
的下一个表达式被求值，这个表达式使计数器递增 1。然后循环继续下去。while  
循环中的真假测试结果一直为“真”，因为位点的值一直小于 end 的值(因为位点  
没有移动)，循环一直进行下去。这就是你所看到的结果。  
  
count-words-region 函数需要另外一种改进，使 while 循环中的真假测试在查询失  
败时测试值为假。这时可以采用另外的方法，即要同时满足两种条件再对计数器  
做递增计算：位点必须还在指定区域中，并且查询表达式必须找到要计数的一个  
单词。  
  
因为第一种和第二种条件必须同时为“真”，所以这两个表达式——区域测试表达  
式和查询表达式——能够用一个 and 函数结合成单独一个表达式，并嵌入到 while 循  
环作为其真假测试表达式，就像这样：  
  
(and (< (point) end) (re-search-forward "\\w+\\W*" end t))  
  
(关于 and 函数的有关信息，参见 12.4 节“forward-paragraph：函数的金矿”。)  
  
如果查询成功，re-search-forward 表达式返回 t，作为其一个附带效果，位点也  
移动到相应的位置。因此，在找到单词的同时，位点从指定区域中一一移过。当  
查询表达式没能找到下一个单词，或者位点已经是指定区域的末尾时，真假测试  
结果为“假”，随即退出 while 循环，count-words-region 函数显示其消息。  
  
做了这些最终的修改之后，count-words-region 函数就没有 bug 了(或者至少我没  
有发现它的 bug 了)。下面就是这个函数定义的完整代码：  
  

----------------------- Page 148-----------------------

  
      ;;; Final version: `while'  
      (defun count-words-region (beginning end)  
       "Print number of words in the region."  
        (interactive "r")  
        (message "Counting words in region ... ")  
  
      ;;; 1. Set up appropriate conditions.  
        (save-excursion  
          (let ((count 0))  
            (goto-char beginning)  
  
      ;;; 2. Run the while loop.  
            (while (and (< (point) end)  
                        (re-search-forward "\\w+\\W*" end t))  
              (setq count (1+ count)))  
  
      ;;; 3. Send a message to the user.  
            (cond ((zerop count)  
                   (message  
                   "The region does NOT have any words."))  
                  ((= 1 count)  
                   (message  
                   "The region has 1 word."))  
                  (t  
                   (message  
                   "The region has %d words." count))))))  
  
** 13.2 用递归的方法实现单词计数  
  
与前面用 while 循环的函数类似，可以用递归的方法编写对单词计数的函数。下  
面，来看一看这是如何实现的。  
  
首先，需要认识到 count-words-region 函数有三个任务：建立适当的计数条件，  
在指定的区域对单词计数，向用户发送消息告诉他们指定区域内有多少单词。  
  
如果编写单独一个递归函数来完成所有的事情，那么将在每一次递归调用时都得  
到一个消息。如果这个区域有 13 个单词，就将得到 13 条消息，一个接着一个。实  
际上，我们不需要这样。相反，我们必须编写两个函数来完成这个工作，其中一  
个函数(递归函数)将在另外一个函数内部使用。一个函数将建立测试条件以及显  
示消息，另一个函数将返回单词计数。  
  
让我们先从显示消息的函数入手。同时将继续称这个函数为 count-words-region。  
  

----------------------- Page 149-----------------------

这是用户将要调用的一个交互函数。确实，除了它将调用  
recursive-count-words 函数来确定指定区域中有多少单词之外，它与这个函数的  
前面一个版本非常相似。  
  
基于这个函数前面的版本，能够容易地构造出这个函数的模板：  
  
;;Recursive version; uses regular expression search  
  
(defun count-words-region (beginning end)  
 "documentation..."  
  (interactive-expression...)  
  
  ;;;1. Set up appropriate conditions.  
  (explanatory message)  
  (set-up functions...  
  
  ;;;2. Count the words.  
     recursive call  
  
  ;;;3. Send a message to the user.  
    message providing word count))  
  
除了由递归调用返回的计数必须被传递给显示单词计数的消息这一点之外，这个  
定义看起来很直接。稍微思考一下就可以知道，这可以用 let 表达式实现：能够将  
let 表达式的变量列表中的一个变量绑定到指定区域的单词数上，这个数值是由递  
归调用返回的；然后 cond 表达式就可以根据绑定的值向用户显示特定的消息。  
  
人们常常认为 let 表达式中的这种绑定作用是这个函数的“第二位”的工作。但  
是，在这个例子中，你所认为的函数的“第一位”的工作——对单词计数，就是在  
let 表达式中完成的。  
  
使用 let 表达式，这个函数定义如下所示：  
  
      (defun count-words-region (beginning end)  
       "Print number of words in the region."  
        (interactive "r")  
  
      ;;; 1. Set up appropriate conditions.  
        (message "Counting words in region ... ")  
        (save-excursion  
          (goto-char beginning)  
  
      ;;; 2. Count the words.  
          (let ((count (recursive-count-words end)))  

----------------------- Page 150-----------------------

  
      ;;; 3. Send a message to the user.  
            (cond ((zerop count)  
                   (message  
                   "The region does NOT have any words."))  
                  ((= 1 count)  
                   (message  
                   "The region has 1 word."))  
                  (t  
                   (message  
                   "The region has %d words." count))))))  
  
下面，需要编写递归计数函数。  
  
一个递归函数至少有三个部分：一个测试表达式、一个 next-step 表达式和递归调  
用。  
  
测试表达式决定函数是否要再调用。因为是在一个指定区域中对单词计数，并且  
可以使用一个单词接一个单词地朝前移动位点的函数，所以测试表达式能够检查  
位点是否还在指定区域中。测试表达式应当找到位点的值并决定位点是在指定区  
域的末尾之前、正在末尾或者在末尾之后。能够用 point 函数来确定位点的值。很  
清楚，必须将指定区域的末尾的值作为一个参量传递给递归计数函数。  
  
除此之外，测试表达式应当也能测试是否找到一个单词。如果没有找到单词，这  
个函数就不应当再调用它本身了。  
  
next-step 表达式要改变一个值，以使当递归函数应当停止调用它本身时就可以停  
下来。更准确地说，next-step 表达式改变一个值以使之能在正确的时候使测试表  
达式让递归表达式停止调用函数本身。在这个例子中，next-step 表达式可以是一  
个单词接一个单词地朝前移动位点的表达式。  
  
递归函数的第三部分就是递归调用。  
  
在某处，我们也需要一个真正完成函数“工作”的那部分代码，也就是完成计数  
的代码。一个真正有用的部分！  
  
但是，我们已经有了一个递归计数函数的骨架：  
  
      (defun recursive-count-words (region-end)  
       "Documentation..."  
        do-again-test  
        next-step-expression  
        recursive call)  
  

----------------------- Page 151-----------------------

现在需要填满充实这个骨架。让我们首先从最简单的情况开始：如果位点在指定  
区域的末尾或者超出了指定区域的末尾，就没有任何单词了。因此这时函数应当  
返回零。同样，如果查询失败，也没有任何单词计数，因此函数也应当返回零。  
  
另一个方面，如果位点在指定的区域之内，查询也是成功的，函数应当继续调用  
本身。因而，测试表达式应当是：  
  
(and (< (point)  region-end)  
      (re-search-forward "\\w+\\W*" region-end t))  
  
注意，查询表达式是测试表达式的一部分——如果查询成功，函数返回 t；如果查询  
失败，则返回 nil。(有关 re-search-forward 函数如何工作的解释，参见 13.1 节中  
的"count-words-region 中的空格 bug"小节。)  
  
这个测试表达式是 if 函数的一个真假测试表达式。很清楚，如果测试表达式为  
 “真”,if 从句的 then 部应当再一次调用函数；但是如果它为“假”,if 从句的  
else 部应当返回零，因为不管位点是在指定区域之外或者查询失败，总之是没有  
别的单词了。  
  
但是在考虑递归调用之前，需要先考虑 next-step 表达式。它是什么？有趣的是，  
它是测试表达式的查询部分。  
  
除了为测试表达式返回 t 或者 nil 之外，re-search-forward 函数在查询成功时还将  
位点向前移动，这是这个函数的一个附带效果。这个动作改变了位点的值，以使  
递归函数在位点完全移动到指定区域之外时，停止调用自身。因而，这个  
re-search-forward 表达式就是 next-step 表达式。  
  
从结构骨架上说，recursive-count-words 函数体如下所示：  
  
  (if do-again-test-and-next-step-combined  
      ;;then  
     recursive-call-returning-count  
      ;;else  
   return-zero)  
  
那么它如何与计数的部分协作呢？  
  
如果你不习惯编写递归函数，类似这样的问题可能会困扰你。但是它能够、也应  
当被系统地解决。  
  
我们知道，计数的方法应当通过某种途径与递归调用结合起来。确实，因为  
next-step 表达式将位点朝前移动一个单词，并且因为一个递归调用是对每一个单  
词都进行的，所以计数的方法必须是一个表达式，它将由  
recursive-count-words 调用返回的值增 1。  

----------------------- Page 152-----------------------

  
考虑下面几种情况：  
  
- 如果在指定区域中有两个单词，当函数对第一个单词计数时，函数应当返回的  
  值是 1 加上这个函数对区域中剩余的单词计数的结果(在这种情况下就是 1)。  
  
- 如果指定区域中只有一个单词，当函数对那个单词计数时，函数应当返回的值  
  是 1 加上这个函数对区域中剩余的单词计数的结果(在这种情况下就是 0)。  
  
- 如果指定区域中没有单词，则函数应当返回零。  
  
  
从这个草案中，我们可以看到：在没有单词的情况下 if 表达式的 else 部将返回零。  
这就是说，if 表达式的 then 部必须返回一个值，这个值是这个函数对剩余的单词  
计数的结果加 1 得到的。  
  
这个表达式写在下面，其中 1+是一个对其参量加 1 的函数。  
  
(1+ (recursive-count-words region-end))  
  
而其中的 recursive-count-words 函数如下所示：  
  
(defun recursive-count-words (region-end)  
 "documentation..."  
  
;;; 1.do－again-test  
  (if (and (< (point) region-end)  
           (re-search-forward "\\w+\\W*" region-end t))  
  
;;; 2. then-part:the recursive call  
      (1+ (recursive-count-words region-end))  
  
;;;3. else-part  
   0))  
  
让我们检查一下这个函数是如何工作的：  
  
如果在指定的区域内没有单词，if 表达式的 else 部被求值，从而这个函数返回零。  
  
如果指定区域中有一个单词，位点的值小于 region-end 变量的值，查询也是成功  
的。在这种情况下，if 表达式的测试结果为“真”，因此 if 表达式的 then 部被求  
值，也就是计数表达式被求值。这个表达式返回一个值(这也将是整个函数的返回  
值)，这个值是 1 与递归函数调用返回的值之和。  
  

----------------------- Page 153-----------------------

同时，next-step 表达式已经使位点跳过第一个单词(并且在这种情况下也只有一  
个单词)。这意味着，当(recursive-count-words region-end)表达式第二次被求  
值时，作为递归调用的返回值，这时位点的值将等于或者大于 region-end 变量的  
值。因此，这时 recursive-count-words 函数将返回零。零将被增大到 1，并且前  
一个递归调用 recursive-count-words 函数将返回 1 加 0，也就是 1，这就是正确的  
答案。  
  
很明显，如果在指定区域中有两个单词，第一次调用 recursive-count-words 函数  
返回 1，加上对剩余区域作递归调用的 recursive-count-words 函数所返回的值——  
也就是 1 加 1，即 2，这就是正确的答案。  
  
类似地，如果在指定区域中有 3 个单词，recursive-count-words 函数的第一次调  
用返回 1 加上对剩余的两个单词的区域作递归调用的 recursive-count-words 函数  
所返回的值——如此重复下去。  
  
在此基础上加上完整的函数文档，这两个函数代码就完整地列于下面：  
  
      (defun recursive-count-words (region-end)  
       "Number of words between point and REGION-END."  
  
      ;;; 1. do-again-test  
        (if (and (< (point) region-end)  
                 (re-search-forward "\\w+\\W*" region-end t))  
  
      ;;; 2. then-part: the recursive call  
            (1+ (recursive-count-words region-end))  
  
      ;;; 3. else-part  
         0))  
  
用这个递归函数的函数是：  
  
      ;;; Recursive version  
      (defun count-words-region (beginning end)  
       "Print number of words in the region.  
  
     Words are defined as at least one word-constituent  
     character followed by at least one character that is  
     not a word-constituent.  The buffer's syntax table  
     determines which characters these are."  
        (interactive "r")  
        (message "Counting words in region ... ")  
        (save-excursion  
          (goto-char beginning)  

----------------------- Page 154-----------------------

          (let ((count (recursive-count-words end)))  
            (cond ((zerop count)  
                   (message  
                   "The region does NOT have any words."))  
                  ((= 1 count)  
                   (message "The region has 1 word."))  
                  (t  
                   (message  
                   "The region has %d words." count))))))  
  
** 13.3 练习：统计标点符号的数量  
  
用 while 循环编写一个函数，它对一个指定区域中的标点符号进行计数。标点符号  
包括句点、逗号、分号、冒号、感叹号、问号。另外，再用递归的方法编写一个  
这样的函数。  
  
* 第 14 章 统计函数定义中的单词数  
  
下一个项目是在一个函数定义中实现对单词数量的计数。很明显，这个任务能够  
用 count-word-region 函数的某个变种来实现。参见第 13 章，“计数：重复和正则  
表达式”。如果只是要在一个函数定义中实现单词计数，用 C-M-h (mark-defun)  
命令来标记这个函数定义，然后调用 count-word-region 函数，就可以轻易地做到  
这一点。  
  
然而，我还有更大的野心：即要对所有的 Emacs 源代码中的函数定义的单词和符号  
计数，并打印一个图形，来显示不同长度的函数定义各有多少：有多少包含了  
40~49 个单词或者符号，有多少包含 50~59 个单词或者符号，如此等等。我经常很  
好奇，一个典型的函数究竟有多长？这个函数将告诉我们这一点。  
  
用一个短语来描述的话，这个柱型图项目是令人生畏的；但是我们将它分成许多  
小的步骤，每一次解决一个步骤，这个项目就变得不可怕了。让我们首先看一看  
这个项目应当有那些步骤：  
  
- 第一，要编写一个函数对单个函数定义计数。这个函数既要处理单词也要处理  
  符号。  
  
- 第二，编写一个函数将函数定义中的单词数目列出来写进一个文件中。这个函  
  数能够使用第一步编写的 count-words-in-defun 函数。  
  
- 第三，要编写一个函数列出每一个文件中的每个函数中的单词数。它自动地查  
  找不同的文件，切换到这些文件，并对其中的函数定义进行统计计数。  
  
- 第四，要编写一个函数将在第三步产生的数变换成一个表，这个表要适合作为  
  一个图形打印出来。  

----------------------- Page 155-----------------------

  
- 第五，编写一个函数将结果作为一个图形打印出来。  
  
** 14.1 计数什么？  
  
当我们第一次考虑如何对一个函数定义进行单词统计计数时，首先遇到的一个问  
题就是(或者应该是)要对什么东西计数？当我们在涉及 Lisp 函数定义而说到“单  
词”一词时，大部分情况下我们实际上是在说“符号”。例如，下面的  
multiply-by-seven 函数包含了 5 个符号：defun、multiply-by-seven、NUMBER、  
*和 7。另外，在函数文档字符串中，它包含了 4 个单词："Multiply"、"NUMBER"、  
"by"和"seven"。符号 number 是重复的，因此这个函数定义实际上总共包含了 10 个  
单词和符号。  
  
(defun multiply-by-seven (number)  
 "Multiply NUHBER by Seven."  
  (* 7 number))  
  
然而，如果将 multiply-by-seven 函数用 C-M-h (mark-defun)打上标记，并调用  
count-words-region 函数，将发现 count-words-region 指出这个函数定义有 11 个  
单词，而不是 10 个。这中间肯定发生了一些错误！  
  
错误是双重的：其一，count-words-region 没有将“*”符号当做一个单词来处  
理，而是将其当做一个符号来处理，因此 multiply-by-seven 包含了 3 个单词。其  
二，其中的连字符"-"被当做单词之间的间空而不是单词之间的连字  
符："multiply-by-seven"被当做"multiply by seven"。  
  
产生这种混乱的原因是：count-words-region 中的正则表达式查询是一个单词一  
个单词地向前移动的。在 count-words-region 函数的正式版本中，正则表达式是：  
  
"\\w+\\W*"  
  
这个正则表达式定义了这样一种模式：一个或者多个构词要素(字符)之后可能跟  
着一个或者多个非构词要素。所谓的构词要素要根据语法来定义，这一点值得在  
下面单独介绍。  
  
** 14.2 单词或者符号是由什么构成的？  
  
Emacs 根据不同的语法分类来处理不同的字符。例如，正则表达式"\\w+"是指定一  
个或者多个构词要素字符的一种模式。构词要素字符是一种语法分类的成员。其  
他语法分类包括标点符号字符类(如句点和逗号)，以及空白字符类(如空格和制表  
符)。(关于这方面更详细的资料，请参见《GNU Emacs 技术手册》和《GNU  
Emacs Lisp 技术手册》的“语法表”一节。)  
  
语法表定义了哪些字符是属于何种类别的。通常，连字符不是一个构词要素字符。  

----------------------- Page 156-----------------------

相反，它被定义为是符号名的一部分但不是单词的字符类。这意味着，  
count-words-region 函数像处理单词之间的空格一样，用同样的方式处理连字符  
 “-”，这就是为什么 count-words-region 函数将“multiply-by-seven”计为 3 个  
单词的原因。  
  
有两种方式使 Emacs 将"multiply-by-seven"当做一个符号来计算：改变语法表或  
者改变正则表达式。  
  
可以将连字符重新定义为一个构词要素字符。这是通过改变 Emacs 为每一种模式设  
置的语法表来实现的。这种改变能够实现我们的目的，只不过，连字符仅仅是最  
常用的非常规构词要素字符。当然也还有其他这类字符。  
  
另外，能够重新定义 count-words-region 函数中使用的正则表达式，以使之正确  
识别这些符号。这个过程的优点是清楚明了，但是稍微有点复杂。  
  
第一部分是相当简单的：必须至少与一个构词要素字符匹配，因而正则表达式必须是：  
  
    "\\(\\w\\|\\s_\\)+"  
  
"\\("这个分组结构的第一部分。这个分组结构包含"\\w"或者它的替代项"\\s_"。  
它们由"\\|"分开。其中的"\\w"与所有的构词要素字符匹配，而"\\s_"则与作为  
符号名的一部分而不是构词要素的字符匹配。其后的"+"号表示构成单词或者符号  
的字符必须至少匹配一次。  
  
然而，这个正则表达式的第二部分更加难以设计。我们所需要的是在第一部分的  
基础上追加一个或者多个非构词要素字符(这种字符是可选的)。开始的时候我认  
为我可以将它设计为下面这种样子：  
  
    "\\(\\W\\|\\S_\\)*"  
  
大写的“W”和“S”字符用于与既不是构词要素的字符也不是构成符号的字符匹  
配。不幸的是，这个表达式与任何一个不是构词要素的字符匹配或者与任何一个  
不是构成符号的字符匹配。它匹配所有的字符！  
  
然后我注意到，在我的测试区域中，每个单词或符号都跟着空白(或者是空格，或  
者是制表符，或者是换行符)。因此我试图设计一个与单个或者多个空白匹配的模  
式，这个模式跟在与一个或者多个构词要素或者是构成符号的字符匹配的模式之  
后。这也失败了。单词或符号经常是被空格分隔开的，但是在实际的代码中，括  
号可能跟随在符号之后，标点符号可能跟随在单词之后。因此，最后我设计了一  
个模式，在这个查询模式中，构词要素的字符或者构成符号的字符之后跟上可选  
的除了空白之外的字符，然后再跟上数目不定的空白。  
  
这就是整个正则表达式：  
  

----------------------- Page 157-----------------------

"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"  
  
** 14.3 count-words-in-defun 函数  
  
我们已经看到，有许多种方法可以用来编写 count-words-in-defun 函数。要编写  
一个 count-words-in-defun 函数，仅仅需要采用其中的一种就行了。  
  
使用 while 循环编写的函数很容易理解，因此我将采用这种方案来编写这个函数。  
因为 count-words-in-defun 将是一个更为复杂的程序的一部分，所以它无需是交  
互的，也无需显示消息，而只要返回计数值就行了。这些考虑稍微简化了这个函  
数的定义。  
  
另外一个方面，count-words-in-defun 函数将被用于一个包含函数定义的缓冲区  
内。因而，有理由要求这个函数决定当位点处于一个函数定义当中时这个函数是  
否被调用。如果是，则返回这个函数定义的计数。这给 count-words-in-defun 函  
数的设计增加了复杂性，但是却使我们无需传递参量给这个函数了。  
  
基于这样的考虑，下面的函数定义模板是合适的：  
  
(defun count-words-in-defun ()  
 "documentation..."  
  (set up...  
     (while loop...)  
   return count)  
  
像平常那样，我们的任务就是填充模板中的这些空缺。  
  
首先，建立适当的环境。  
  
我们假定这个函数将在一个包含了函数定义的缓冲区内被调用。位点要么在一个  
函数定义当中，要么不在其中。为了使 count-words-in-defun 函数正常工作，位  
点必须移动到函数定义的开始，计数器必须从零开始。计数循环必须在位点到达  
函数定义的末尾时停止。  
  
beginning-of-defun 函数朝后查询某一行开始处的起始定界符（如“(”）并将位  
点移动到那个位置，或者移动到这个函数查询的边界。实际上，这意味着  
beginning-of-defun 函数将位点移动到一个函数定义的开始，否则的话就移动到  
缓冲区的开始处。我们可以使用 beginning-of-defun 函数将位点移动到我们需要  
的地方。  
  
while 循环需要一个计数器来跟踪要计数的单词或者符号。let 表达式能够被用于  
创建一个这样的局部变量，并将它绑定到零。  
  
end-of-defun 函数与 beginning-of-defun 函数类似，它将位点移动到函数定义的  

----------------------- Page 158-----------------------

末尾。end-of-defun 函数也可以用作一个决定位点是否是函数定义末尾的表达式  
的一部分。  
  
count-words-in-defun 函数很快就有模有样了：首先将位点移动到函数定义的开  
始处，然后创建一个局部变量来存放计数值，最后记录函数定义末尾的位置，这  
样 while 循环就可以知道何时将停止循环。  
  
函数代码就像这样：  
  
(beginning-of-defun)  
(let ((count 0)  
       (end (save-excursion (end-of-defun) (point))))  
  
这些代码很简单。其中稍微复杂一点的是 end：它被绑定到函数定义末尾的位置，  
这个值是由 save-excursion 表达式返回的，这个表达式所返回的值是通过调用  
end-of-defun 函数使位点暂时地移动到函数定义的末尾并记录下它的值而得到的。  
  
完成基本环境的设置之后，count-words-in-defun 函数的第二部分就是 while 循环。  
  
这个循环必须包含这样一个表达式，它将位点一个单词接一个单词、一个符号接  
一个符号地往前移动。还要有另外一个表达式对移动次数计数。只要位点继续往  
前移动，while 循环中的真假测试表达式应当测试为“真”；当位点移动到函数定  
义末尾时，测试结果为“假”。我们已经重新定义了一个满足这种要求的正则表  
达式，因此这个 while 循环就很直截了当了：  
  
(while (and (< (point) end)  
             (re-search-forward  
             "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*" end t)  
   (setq count (1+ count)))  
  
这个函数定义的第三部分返回对单词和符号的计数值。这个部分是 let 表达式主体  
中的最后一个表达式，很简单，就是局部变量 count。这个表达式被求值时就返回  
这个变量的值。  
  
将这些组合起来，count-words-in-defun 函数定义就是：  
  
(defun count-words-in-defun ()  
       "Return the number of words and symbols in a defun."  
        (beginning-of-defun)  
        (let ((count 0)  
              (end (save-excursion (end-of-defun) (point))))  
          (while  
              (and (< (point) end)  
                   (re-search-forward  

----------------------- Page 159-----------------------

                   "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"  
                   end t))  
            (setq count (1+ count)))  
         count))  
  
如何测试这个函数？这个函数不是交互的，但是很容易将它包装一下使其成为交互的函数。  
可以使用与 count-words-region 函数同样的代码：  
  
      ;;; Interactive version.  
      (defun count-words-defun ()  
       "Number of words and symbols in a function definition."  
        (interactive)  
        (message  
        "Counting words and symbols in function definition ... ")  
        (let ((count (count-words-in-defun)))  
          (cond  
           ((zerop count)  
            (message  
            "The definition does NOT have any words or symbols."))  
           ((= 1 count)  
            (message  
            "The definition has 1 word or symbol."))  
           (t  
            (message  
            "The definition has %d words or symbols." count)))))  
  
让我们再使用 C-c=组合键绑定到这个函数定义上：  
  
(global-set-key "\C-c=" 'count-words-defun)  
  
现在，我们能够试一试 count-words-defun 函数了：将 count-words-in-defun 函数  
和 count-words-defun 函数都安装好，并设置好绑定的键，然后将光标置于下面这  
个函数定义当中：  
  
(defun multiply-by-seven (number)  
 "Multiply NUMBER by seven."  
  (* 7 number))  
   => 10  
  
万事大吉！这个函数定义有 10 个单词和符号。  
  
下一个问题就是对一个文件中的几个函数定义中的单词和符号进行计数。  
  
** 14.4 在一个文件中统计几个函数定义的单词数  

----------------------- Page 160-----------------------

  
一个文件(如"simple.el")可以存放 80 个或者更多的函数定义。我们的长远目标  
是计算许多文件的统计结果，但是第一步，首要目标就是收集一个文件的统计信  
息。  
  
这些统计信息是一系列的数字，每一个数就是一个函数定义的长度。可以将这些  
数储存在一个列表中。  
  
我们知道，我们将把从这个文件中得到的信息与从另外的文件中得到的信息进行  
整合；这意味着，对文件中所有的函数定义进行单词计数的函数，只需返回这些  
长度的列表，而无需也不应当显示其他信息。  
  
单词计数命令包含一个将位点一个单词一个单词朝前移动的表达式，以及另外一  
个对移动的次数进行计数的表达式。这些计算函数定义长度的函数，也可以用同  
样的方式工作，用一个表达式使位点一个函数定义一个函数定义地朝前移动，而  
另一个表达式来构造长度列表。  
  
对问题的这种描述，使之成为编写函数定义的基础。很明显，将从文件的开始处  
进行计数统计，因此这个函数的第一个命令将是：(goto-char (point-min))。其  
次，要开始一个 while 循环，这个循环中的真假测试可以是一个正则表达式查询，  
它查询下一个函数定义——只要查询成功，位点将朝前移动，然后这个循环体被求  
值。循环体需要一个表达式来构造长度列表。cons 这个列表构造命令能够被用于  
创建这个长度列表。这就是所有要做的工作。  
  
下面是这部分代码片断：  
  
(goto-char (point-min))  
(while (re-search-forward "^(defun" nil t)  
  (setq lengths-list  
     (cons (count-wards-in-defun) lengths-list)))  
  
我们剩下的任务就是查找包含函数定义的文件。  
  
在前面的例子中，我们要么使用这份文档(Info 文件)，要么在一些缓冲区(如草稿  
缓冲区)之间来回切换。  
  
查找一个文件是一个我们迄今为止还没有讨论的新过程。  
  
** 14.5 查找文件  
  
要在 Emacs 中查找一个文件，可以使用 C-x C-f (find-file)命令。这个命令几乎  
就是为长度问题设计的，但并不完全这样。  
  
让我们看一看 find-file 函数定义的源代码(可以使用 find-tag 命令来找到一个函  

----------------------- Page 161-----------------------

数的源代码):  
  
(defun find-file (filename)  
 "Edit file FILENAME.  
Switch to a buffer visiting file FILENAHE,  
creating one if none already exists."  
  (interactive "FFind file:")  
  (switch-to-buffer (find-file-noselect filename)))  
  
这个函数定义具有简短但是完整的文档说明。当你交互地使用这个函数时，其中  
的交互表达式提示你输入一个文件名。函数定义的主体包含两个函  
数：find-file-noselect 和 switch-to-buffer。  
  
根据由 C-h f (describe-function 命令)命令得到的函数定义的说明文  
档，find-file-noselect 函数将文件读入一个缓冲区并返回到原来的缓冲区。然  
而，这个缓冲区没有被选中。Emacs 并不切换到读入文件的那个缓冲区。这就是  
switch-to-buffer 函数所要完成的任务：它将 Emacs 关注的缓冲区切换到另外一个  
缓冲区，井将后面这个缓冲区在当前窗口中显示。我们已经讨论过缓冲区的切换  
的问题。(参见 2.3 节，“切换缓冲区”。)  
  
在这个柱型图项目中，当程序在确定文件中的函数定义的长度时，确实不需要在  
屏幕上显示每一个文件。除了使用 switch-to-buffer 函数之外，我们能使用  
set-buffer 函数，这个函数将计算机程序的关注焦点重新定向到另外一个缓冲  
区，但是并不将这个缓冲区显示在屏幕上。因此，我们必须编写自己的表达式，  
而不是调用 find-file 命令来完成我们的任务。  
  
完成这项任务很简单，就是使用 find-file-noselect 和 set-buffer 函数。  
  
** 14.6 lengths-list-file 函数详解  
  
lengths-list-file 函数的核心是一个 while 循环，这个循环包含将位点从一个函  
数定义不断地移动到下一个函数定义的函数，以及计算每一个函数定义中的单词  
和符号数的函数。这个核心部分，必须在完成其他相关任务(比如查找一个文件)  
的函数内部，以确保位点从文件的开始移动。这个函数定义是：  
  
      (defun lengths-list-file (filename)  
       "Return list of definitions' lengths within FILE.  
     The returned list is a list of numbers.  
     Each number is the number of words or  
     symbols in one function definition."  
        (message "Working on `%s' ... " filename)  
        (save-excursion  
          (let ((buffer (find-file-noselect filename))  
                (lengths-list))  

----------------------- Page 162-----------------------

            (set-buffer buffer)  
            (setq buffer-read-only t)  
            (widen)  
            (goto-char (point-min))  
            (while (re-search-forward "^(defun" nil t)  
              (setq lengths-list  
                    (cons (count-words-in-defun) lengths-list)))  
            (kill-buffer buffer)  
           lengths-list)))  
  
----------------------------------------------------------------------  
Chiron 注：  
  
由于在 while 循环的那一行有  
  
"^(defun"   
  
如果在 org-mode 中阅读本文档，光标将无法正确匹配上述函数中左右括号的配对。  
请不要以为最后一行的右括号少了一个。  
  
----------------------------------------------------------------------  
  
这个函数有一个参量，就是对其进行统计计数的文件名。这个函数定义中有四行  
说明文档，但是没有交互表达式。因为人们担心在他们看不到任何事情正在运转  
的时候计算机就崩溃了，因此函数体的第一行就输出一条消息。  
  
函数定义中的下面一行，包含一个 save-excursion 函数，这个函数将 Emacs 的注意  
力在函数执行完之后返回到当前的缓冲区。当你将这个函数嵌入在另外一个函数  
当中，并假设位点保存在原来的缓冲区中时，这是很有用的。  
  
在 let 表达式的变量列表中，Emacs 找到文件并将局部变量 buffer 绑定到存放这个  
文件的缓冲区。同时，Emacs 创建局部变量 lengths-list。  
  
接下来，Emacs 将它的注意力切换到那个缓冲区。  
  
随后，Emacs 使这个缓冲区成为只读的。在理想的情况下这一行是不需要的。对函  
数定义中的单词或者符号进行计数的这些函数都不应当改变缓冲区的内容。另  
外，即使它被改变，这个缓冲区也将不被保存。这一行完全是为了安全小心起见。  
其理由是，这个函数以及它调用的那些函数的处理对象是 Emacs 源代码，如果这些  
源代码不经心地被改变了，那将是很麻烦的事情。我可以告诉你，当我在一次试  
验当中改变了我的 Emacs 源代码后发生的事情，才使我意识到这一行的必要性。  
  
再后面是一个增宽命令，如果缓冲区变窄开启，这个命令就起作用了。这个函数  
通常是不需要的——如果缓冲区不存在，Emacs 将创建一个新的缓冲区；但是当一个  

----------------------- Page 163-----------------------

缓冲区正在访问这个文件，Emacs 就返回这个缓冲区。在这种情况下，这个缓冲区  
可能变窄开启了，因此需要增宽。如果要使这个函数实现完全的“用户友好”，  
应该安排好保存这些原来的设置以及位点的位置，但是我们不要这样做。  
  
(goto-char (point-min))表达式将位点移动到缓冲区的开始。  
  
然后是一个 while 循环，在这个循环中完成这个函数的主要任务。在这个循环  
中，Emacs 确定每一个函数定义的长度并构造一个长度列表来保存这些信息。  
  
Emacs 在完成计数统计之后删除这个缓冲区，这是为了节省 Emacs 的空间。我的  
Emacs 第 19 版中包含了超过 300 个有意思的源文件，对于每一个函数要逐一使用  
lengths-list-file 进行计数。如果 Emacs 访问所有这些文件而不删除任何一个缓  
冲区，我的计算机将用完它的虚拟内存。  
  
最后，let 表达式中的最后一个表达式是 lengths-list 变量，它的值是作为整个函  
数的返回值而返回的。  
  
你可以通过用通常的办法安装这个函数来试一试它。将光标置于下面的表达式后  
并键入 C-x C-e (eval-last-sexp)即可：  
  
(lengths-list-file "../lisp/debug.el")  
  
(你可能需要改变这个文件的路径，如果这个 Info 文件和 Emacs 源文件都在邻近的  
地方(如/usr/local/emacs/info 和/usr/local/emacs/lisp)，这里列出的这个路  
径是起作用的。要改变这个表达式，只需将它拷贝到“*scratch*”缓冲区并编辑  
它，然后对它求值就行了。)  
  
在我的那个版本的 Emacs 中，我的计算机花了 7 秒钟才产生“debug.el”文件的长  
度列表。它是这样的一个列表：  
  
(75 41 80 62 20 45 44 68 45 12 34 235)  
  
注意，文件中最后一个函数定义的长度在列表的开始位置。  
  
** 14.7 在不同文件中统计几个函数定义的单词数  
  
在前面的章节，创建了一个返回单个文件中所有函数定义的单词和符号长度的列  
表。现在，要定义一个计算一系列文件中函数定义的长度列表的列表。  
  
对文件列表中每一个元素的处理都是重复的，因此能用 while 循环来处理，也能用  
递归调用的方法来处理。  
  
常规的方法是使用 while 循环。传递给函数的参量是一个文件列表。就像我们前面  
看到的(参见 11.1 节，"while 循环和列表")，你能够编写一个 while 循环，如果这  

----------------------- Page 164-----------------------

样一个文件列表包含了元素，这个循环的循环体就被求值；但是如果这个文件列  
表中没有元素，就退出循环体。为了使这个设计能够正常工作，循环体必须包含  
一个表达式，这个表达式使文件列表每当循环体执行一次就减少一个元素，因此  
最终列表就成了一个空列表。常用的技术就是每次循环体被求值时，将列表的值  
设为这个列表的 cdr 的值。  
  
这部分代码的模板是：  
  
(while test-whether-list-is-empty  
  body...  
  set-list-to-cdr-of-list)  
  
而且，我们记得，while 循环将返回 nil(也就是测试表达式的值)，而不是其循环  
体中任何表达式的值。(循环体中表达式的求值是作为附带效果而被完成的。)然  
而，设置长度列表的表达式是循环体的一部分——这是我们要作为整个函数的返回  
值的。为了实现这一点，我们将 while 表达式放在 let 表达式中，并使 let 表达式的  
最后一个元素包含了长度列表。(参见 11.1.3 节中“使用增量计数器的例子”小  
节。)  
  
基于上面的考虑，可以直接写出如下函数定义：  
  
      ;;; Use `while' loop.  
      (defun lengths-list-many-files (list-of-files)  
       "Return list of lengths of defuns in LIST-OF-FILES."  
        (let (lengths-list)  
  
      ;;; true-or-false-test  
          (while list-of-files  
            (setq lengths-list  
                  (append  
                  lengths-list  
  
      ;;; Generate a lengths' list.  
                   (lengths-list-file  
                    (expand-file-name (car list-of-files)))))  
  
      ;;; Make files' list shorter.  
            (setq list-of-files (cdr list-of-files)))  
  
      ;;; Return final value of lengths' list.  
         lengths-list))  
  
expand-file-name 函数是一个内置函数，它将一个文件名转换成文件的绝对的长  
路径形式。因而文件  

----------------------- Page 165-----------------------

  
debug.el  
  
变成  
  
/usr/local/emacs/lisp/debug.el  
  
这个函数定义中，仅有的一个新元素就是至今没有学习过的 append 函数，这个函  
数值得用一个小节专门讲述。  
  
append 函数  
  
append 函数将一个列表追加到另外一个列表之后，因而，  
  
(append '(1 2 3 4) '(5 6 7 8))  
  
就产生下面这个列表  
  
(1 2 3 4 5 6 7 8)  
  
这就是为什么要将由 lengths-list-file 产生的两个列表连接起来组成一个列表的原  
因。这个结果与 cons 函数正好形成对照：  
  
(cons '(1 2 3 4) '(5 6 7 8))  
  
这个表达式将其第一个参量当做一个元素插入到其第二个参量列表中，形成一个新的列表：  
  
((1 2 3 4) 5 6 7 8)  
  
** 14.8 在不同文件中递归地统计单词数  
  
除了 while 循环之外，可以用递归的办法处理文件的每一个列表。  
lengths-list-file 函数的递归实现更短、更简单。  
  
递归函数通常有这样几个部分："do-again-test"真假测试表达式，"next-step"  
表达式，以及递归调用。其中真假测试表达式决定函数是否继续调用自身，如果  
list-of-files 列表仍包含有剩余的元素，就继续调用函数自身(即递归调用)；  
"next-step"表达式将 list-of-files 列表重置为这个列表的 cdr，因此最终这个列  
表就变空了；而递归调用则在更短的列表上调用自身。整个函数比上面描述的更  
简短。  
  
      (defun recursive-lengths-list-many-files (list-of-files)  
       "Return list of lengths of each defun in LIST-OF-FILES."  
        (if list-of-files                     ; do-again-test  

----------------------- Page 166-----------------------

            (append  
             (lengths-list-file  
              (expand-file-name (car list-of-files)))  
             (recursive-lengths-list-many-files  
              (cdr list-of-files)))))  
  
简言之，这个函数返回 list-of-files 列表中第一个元素的长度列表，并将这个列  
表追加到对 list-of-files 列表中剩余元素的递归调用的结果上。  
  
下面是对这个递归函数 recursive-lengths-list-many-files 的测试，并给出了  
lengths-list-file 函数对每一个文件的统计结果(做比较用)。  
  
将 recursive-lengths-list-many-files 和 lengths-list-file 两个函数安装好，  
如果需要，然后对下面的表达式求值。你可能需要改变其中的文件的路径，当这  
个 Info 文件以及 Emacs 源文件在它们通常的位置，下面的表达式是能够正常工作的。  
要改变这些表达式，就将它们拷贝到“*scratch*”缓冲区，编辑它们，然后对它们  
求值。  
  
求值的结果用“=>”符号表示(这些结果是对 Emacs 第 18.57 版而言的，其他版本的  
Emacs 的结果可能与此不同)。  
  
(lengths-list-file  
  "../lisp/macros.el")  
       =>(176 154 86)  
  
(lengths-list-file  
  "../lisp/mailalias.el")  
       =>(116 122 265)  
  
(lengths-list-file  
  "../lisp/makesum.el")  
       =>(85 179)  
  
(recursive-lengths-list-many-files  
 '("../lisp/macros.el"  
   "../lisp/mailalias.el"  
   "../lisp/makesum.el"))  
      =>(176 154 86 116 122 265 85 179)  
  
recursive-lengths-list-files 函数产生了我们需要的结果。  
  
下一步就是为以图形的形式显示列表中的数据做准备。  
  
** 14.9 为图形显示准备数据  

----------------------- Page 167-----------------------

   
recursive-lengths-list-many-files 函数返回一个数的列表。其中的每一个数记  
录一个函数定义的长度。现在需要做的工作是将这些数据转换成一个适合图形显  
示的数据列表。这个新的列表将告诉人们有多少函数定义的长度少于 10 个单词和  
符号，有多少函数定义的长度介于 10 和 19 之间，又有多少函数定义的长度介于 20  
和 29 之间，如此等等。  
  
简而言之，需要遍历由 recursive-lengths-list-many-files 函数产生的这个长度  
列表，并计算在每一个长度范围内的函数定义的个数，进而产生一个记录这些数  
据的列表。  
  
基于前面已经完成的工作，我们能够轻松地预测：编写这样一个函数并不太难，  
这个函数只要不断地使用长度列表的 cdr 就可以访问这个列表的每一个元素，并测  
定这个元素属于哪一个长度范围，然后对那个长度范围的计数器加 1。  
  
然而，在开始编写这样的函数之前，应该考虑首先将列表排序的好处。将列表排  
序后，列表中的元素就是从小到大一一排列的。首先，排序将使对每一个范围的  
计数更加简单，因为两个相邻的元素要么在同一个长度范围，要么在相邻的长度  
范围。其次，要检查一个排好序的列表，我们能发现最大和最小的数，因此可以  
决定需要考虑的最大和最小的长度范围。  
  
*** 14.9.1 对列表排序  
  
Emacs 包含了一个对列表中元素排序的函数，这个函数就是 sort 函数(可能你已经  
猜到了)。sort 函数接收两个参量，一个是要被排序的列表，另外一个是一个谓  
词，这个谓词决定目标列表中的第一个元素是否小于第二个元素。  
  
就像前面看到的(参见第 1.8.4 节，“用一个错误类型的数据对象作为参量”)，谓  
词就是一个决定某些特性是否为真的函数。sort 函数将根据谓词使用的情况记录  
一个列表。这就是说，sort 函数能够被用于对非数字列表排序，只要使用适当的  
非数字标准的谓词就行了——例如，它能按字母顺序对一个列表排序。  
  
当对一个数字列表排序时，要使用<函数。例如，  
  
(sort '(4 8 21 17 33 7 21 7) '<)  
  
将产生下面这个列表：  
  
(4 7 7 8 17 21 21 33)  
  
(注意，在这个例子中，sort 函数的两个参量都使用了单引号，因此这些符号在作  
为参量传送给 sort 函数时不应被求值。)  
  
对由 recursive-lengths-list-many-files 函数返回的列表进行排序是直截了当的：  

----------------------- Page 168-----------------------

  
(sort  
   (recursive-lengths-list-many-files  
   '("../lisp/macros.el"  
     "../lisp/mailalias.el"  
     "../lisp/makesum.el"))  
  '<)  
  
将产生：  
  
(85 86 116 122 154 176 179 265)  
  
(注意，在这个例子中，sort 函数的第一个参量没有用单引号，这是因为这个表达  
式必须被求值以产生一个传递给 sort 函数的列表。)  
  
*** 14.9.2 制作一个文件列表  
  
recursive-lengths-list-many-files 函数需要一个文件列表作为其参量。对于我  
们的测试例子，我们手工构建了这样一个文件列表。但是 Emacs Lisp 源代码目录  
太大，以致于我们无法手工构建其中所有文件的列表。确实，我们需要使用  
directory-files 函数来为我们自动构建文件列表。  
  
directory-files 函数接收三个参量：第一个参量是目录名，它是一个字符串；  
非空的第二个参量使函数返回目录中文件的绝对路径；第三个参量是一个可选项。  
如果这个可选项包含了一个正则表达式(而不是空)，则只有路径名与正则表达式  
匹配的文件被返回。  
  
因此，在我的计算机系统中，  
  
(length  
  (directory-files "../lisp" t "\\.el$"))  
  
将告诉我，在我的计算机中的 Emacs 第 19.25 版源代码目录中包含 307 个“.el”的  
文件。  
  
在 recursive-lengths-list-many-files 函数中，这个表达式应当是：  
  
(sort  
   (recursive-lengths-list-many-files  
     (directory-files "../lisp" t "\\.el$"))  
  '<)  
  
我们直接的目标是创建一个列表，这个列表要告诉我们，有多少函数定义包含的  
单词和符号少于 lO 个，有多少函数定义包含的单词和符号介于 10 到 19 之间，又有  

----------------------- Page 169-----------------------

多少函数定义包含的单词和符号介于 20 和 29 之间，如此等等。采用一个排序后的  
数字列表，这就容易多了：计算这个列表中有多少元素小于 10，然后移动到计算  
过的元素之后，再计算有多少元素小于 20，然后移动到这次计算过的元素之后，  
再计算有多少元素小于 30……。每一个数，如 10、20、30、40 等等，都比那个范  
围的值要大。我们称这些数的列表为 top-of-ranges 列表。  
  
如果需要，我们能够自动地产生这个列表，但是人工写出这个列表更简单。下面  
就是：  
  
(defvar top-of-ranges  
'(10 20 30 40 50  
 60 70 80 90 100  
 110 120 130 140 150  
 160 170 180 190 200  
 210 220 230 240 250  
 260 270 280 290 300)  
"List specifying ranges for `defuns-per-range'.")  
  
要改变范围，编辑这个列表就行了。  
  
下一步，需要编写一个函数来创建一个列表，这个列表的每一个元素分别记录落  
在每一个范围内的函数定义的数量。很明显，这个函数必须接收 sorted-lengths  
和 top-of-ranges 列表作为其参量。  
  
defuns-per-range 函数必须不断地完成两件事情：它必须根据当前范围的值计算  
落在这个范围内的函数定义的数量；而且它必须在计算完当前范围中的函数定义  
的数目之后移动到 top-of-ranges 列表中的更高的一个值。因为这两个操作中的任  
何一个都是不断反复的，所以可以使用 while 循环来完成它们。一个循环计算函数  
定义落在由当前值确定的某个范围内的数量，另外一个循环则依次选择每一个值  
(计数范围)。  
  
对于每一个范围，列表 sorted-lengths 中都有几个元素。这意味着处理  
sorted-lengths 列表的循环，将在处理 top-of-ranges 列表的内部，就像一个小齿  
轮在一个大齿轮之中一样。  
  
这个内层循环对某个范围内的函数定义的数目计数。它是一个简单的计数循环，  
我们在前面已经见到过(参见 11.1.3 节，“使用增量计数器的循环”)。这个循环  
中的真假测试表达式判断 sorted-lengths 中的元素值是否小于当前范围的最大值。  
如果是，这个函数对计数器加 1,并测试 sorted-lengths 列表中的下一个元素。  
  
因此这个内层循环如下所示：  
  
(whilel length-element-smaller-than-top-of-range  
    (setq number-within-range (1+ number-within-range))  

----------------------- Page 170-----------------------

    (setq sorted-lengths (cdr sorted-lengths)))  
  
外层的循环必须从 top-of-ranges 列表最小的一个元素开始，然后被依次设置为后  
续更高的一个元素。这可以用下面的一个循环实现：  
  
(while top-of-ranges  
  body-of-loop...  
   (setq top-of-ranges (cdr top-of-ranges)))  
  
将这两个循环连接起来就像下面所示：  
  
      (while top-of-ranges  
  
        ;; Count the number of elements within the current range.  
        (while LENGTH-ELEMENT-SMALLER-THAN-TOP-OF-RANGE  
          (setq number-within-range (1+ number-within-range))  
          (setq sorted-lengths (cdr sorted-lengths)))  
  
        ;; Move to next range.  
        (setq top-of-ranges (cdr top-of-ranges)))  
  
另外，在外层循环的每一次循环中，Emacs 应当在一个列表中记下在当前范围内的  
函数定义的数目(number-within-range)。可以使用 cons 函数来完成这一工作。  
(参见 7.2 节， "cons 函数"。)  
  
cons 函数工作得很好。唯一的不足之处是：最高范围的函数定义的数目在列表的  
开头，而最低范围的函数定义的数目在列表的末尾。这是因为 cons 函数将新元素  
插入到列表的开头，并且两个循环是从长度列表的最低值开始的，  
defuns-per-range-list 将最终以最大值结束(即它以最大值作为其第一个元素)。  
但是我们将要从最小值开始打印柱型图，解决的办法是将  
defuns-per-range-list 反转过来。使用 nreverse 函数可以做到这一点，这个函数  
的作用就是将一个列表中元素的顺序反转过来。  
  
例如，  
  
(nreverse '(1 2 3 4))  
  
产生：  
  
(4 3 2 1)  
  
注意，nreverse 函数是“破坏性的”——也就是它改变了作为其参量的列表；这与  
car 和 cdr 函数形成对照，这两个函数是非破坏性的。在这个例子中，我们不需要  
原来的 defuns-per-range-list 列表，因此这个破坏性的函数对我们来说也没有什  

----------------------- Page 171-----------------------

么问题。(reverse 函数提供一个反转的列表拷贝，而将原始的列表留下来。)  
  
将这些统统整合起来，defuns-per-range 函数就像如下所示：  
  
      (defun defuns-per-range (sorted-lengths top-of-ranges)  
       "SORTED-LENGTHS defuns in each TOP-OF-RANGES range."  
        (let ((top-of-range (car top-of-ranges))  
              (number-within-range 0)  
             defuns-per-range-list)  
  
          ;; Outer loop.  
          (while top-of-ranges  
  
            ;; Inner loop.  
            (while (and  
                    ;; Need number for numeric test.  
                    (car sorted-lengths)  
                    (< (car sorted-lengths) top-of-range))  
  
              ;; Count number of definitions within current range.  
              (setq number-within-range (1+ number-within-range))  
              (setq sorted-lengths (cdr sorted-lengths)))  
  
            ;; Exit inner loop but remain within outer loop.  
  
            (setq defuns-per-range-list  
                  (cons number-within-range defuns-per-range-list))  
            (setq number-within-range 0)      ; Reset count to zero.  
  
            ;; Move to next range.  
            (setq top-of-ranges (cdr top-of-ranges))  
            ;; Specify next top of range value.  
            (setq top-of-range (car top-of-ranges)))  
  
          ;; Exit outer loop and count the number of defuns larger than  
          ;;   the largest top-of-range value.  
          (setq defuns-per-range-list  
                (cons  
                 (length sorted-lengths)  
                defuns-per-range-list))  
  
          ;; Return a list of the number of definitions within each range,  
          ;;   smallest to largest.  
          (nreverse defuns-per-range-list)))  

----------------------- Page 172-----------------------

  
这个函数的其他部分都很明白了，只有一处稍微有点微妙，那就是内层循环中的  
真假测试表达式，这个表达式是：  
  
(and (car sorted-lengths)  
      (< (car sorted-lengths) top-of-range))  
  
而不是：  
  
(< (car sorted-lengths) top-of-range)  
  
这个测试的目的是决定 sorted-lengths 列表中的第一个元素是否小于最大的范围  
值。  
  
其实后面一个测试表达式在 sorted-lengths 列表变成空列表之前工作得也很正确。  
但是在空列表的情况下，(car sorted-lengths)表达式返回 nil，而<函数无法将  
一个数和一个 nil(一个空列表)进行比较，因此 Emacs 将发出一个错误消息并停止  
这个函数的继续运行。  
  
sorted-lengths 列表总是在计数器到达列表末尾时成为一个空列表，这意味着任  
何企图使用那个简单的测试表达式的 defuns-per-range 函数都将失败。  
  
在编写这个函数定义时，我们将(car sorted-lengths)表达式和 and 表达式结合在  
一起来解决这个问题。只要列表中至少还有一个元素，(car sorted-lengths)表  
达式就返回一个非空值；但是只要这个列表是一个空列表，这返回一个空值 nil。  
and 表达式首先计算(car sorted-lengths)表达式，如果这个表达式的值是 nil，  
就不再计算后续的<表达式，并直接返回“假”。但是如果(car  
sorted-lengths)表达式返回一个非空值，and 表达式就计算后续的<表达式，并将  
这个表达式的值作为 and 表达式的值返回。  
  
通过采用这样一种方法，我们避免了一个错误。关于 and 函数的更详细的内容，参  
见 12.4 节"forward-paragraph：函数的金矿"。  
  
下面是一个对 defuns-per-range 函数的简单测试。首先，对下面的表达式求值，  
使之绑定到 top-of-ranges 列表上。然后，绑定 sorted-lengths 列表，最后对  
defuns-per-range 函数求值。  
  
      ;; (Shorter list than we will use later.)  
      (setq top-of-ranges  
      '(110 120 130 140 150  
        160 170 180 190 200))  
  
      (setq sorted-lengths  
           '(85 86 110 116 122 129 154 176 179 200 265 300 300))  

----------------------- Page 173-----------------------

  
      (defuns-per-range sorted-lengths top-of-ranges)  
  
对上面这个表达式求值后返回的列表如下所示：  
  
(2 2 2 0 0 1 0 2 0 0 4)  
  
确实，在 sorted-lengths 列表中有 2 个元素小于 110，有 2 个元素介于 110~119 之间．有 2  
个元素介于 120~129 之间，等等。有 4 个元素等于或大于 200。  
  
* 第 15 章 准备柱型图  
  
我们的目标是构造一个柱型图，用来显示 Emacs Lisp 源代码中各种长度的函数定  
义的数目。  
  
作为一个实际的问题，如果你正在构造一个图，你可能要用一个像 gnuplot 这样的  
程序来完成它。(gnuplot 还被很好地集成在 GNU Emacs 中。)然而，在这个例子  
中，我们要从头创建一个函数，并且在设计这个函数的过程中我们将重新熟悉前  
面已学习过的内容，同时学习更多的东西。  
  
在这一章，将首先编写一个简单的打印图形的函数。这第一个函数定义是一个函  
数原型，这个迅速编成的函数，可以使我们初窥打印图形这一未知的领域。我们  
将发现神龙，或者发现它们是虚构的。对这个领域仔细观察一番之后，我们将感  
到更加自信，然后要增强这个函数的功能使之自动打印坐标轴。  
  
由于 Emacs 的柔性设计以及它能在各种类型的终端(包括字符终端)上很好地工作，  
因此我们将输出的图形用符号打印出来。星号将能完成这一工作。当我们增强打  
印图形的函数的功能时，我们将使用户可以选择他们自己喜爱的符号。  
  
能够调用 graph-body-print 这个函数，它将接收 numbers-list 作为其唯一的参量。  
在这一阶段，将不给出图形的坐标，而仅仅打印图形本身。  
  
graph-body-print 函数根据 numbers-list 列表中的每一个元素插入一个由星号组  
成的垂直列。每一列的高度由 numbers-list 中相应元素的值决定。  
  
插入垂直列的操作是反复执行的，这意味着 graph-body-print 这个函数既可以用  
while 循环完成，也可以用递归方法完成。  
  
第一个挑战是如何打印一个由星号组成的列。通常，在 Emacs 中，我们是在水平方  
向上打印字符的，一行一行地打印。为了打印垂直列，有两种方法可以采纳：编  
写自己的列输出函数，或者是找一个 Emacs 已有的函数。  
  
要看看 Emacs 中是否有这样的一个函数，可以使用 M-x apropos 命令。这个命令很  
像 C-h a (command-apropos)命令，只是后者只查找作为命令的函数。M-x  

----------------------- Page 174-----------------------

apropos 命令则列出与一个正则表达式匹配的所有符号，包括非交互函数。  
  
这里所要查找的是一些打印或插入列符号的命令。很可能这些函数的函数名将包  
括“Print”、“insert”或者“column”这样的单词。因而，能够简单地输入  
M-x apropos RET print\|insert\|column RET 并看一看结果。在我的系统中，这  
个命令的执行需要一定的时间，然后产生一个含有 79 个函数和变量的列表。扫描  
这个列表，只有 insert-rectangle 这个函数看起来比较适合做这项工作。确实，  
这就是我们寻找的那个函数。它的函数说明文档说：  
  
   insert-rectangle:  
   Insert text of RECTANGLE with upper left corner at point.  
   RECTANGLE's first line is inserted at point,  
   its second line is inserted at a point vertically under point, etc.  
   RECTANGLE should be a list of strings.  
  
可以简单地测试一下这个函数，以确定它是否就是我们希望的那个函数。  
  
将光标置于下面的 insert-rectangle 表达式之后并键入 C-u C-x C-e  
(evel-last-sexp)命令，将得到随后的结果。这个函数将字符串“first”、  
 “second”和“third”插入位点以及位点下面的位置。最后这个函数返回 nil。  
  
(insert-rectangle '("first" "second" "third"))  
                         
                         
  
当然，我们不希望将 insert-rectangle 表达式的这些文本内容插入到我们正在打  
印图形的缓冲区中，但是我们将从我们编写的函数中调用这个函数。然而，我们  
将不得不确保位点位于缓冲区中 insert-rectangle 函数将插入字符列的适当位置。  
  
如果你在 Info 中阅读这份文档，将缓冲区切换到诸如“*scratch*”缓冲区等缓冲  
区中，并将位点置于该缓冲区中的适当位置，然后键入 M-: ，在消息缓冲区中的  
提示符下输入 insert-rectangle 表达式并键入回车键，这样你就可以看到这个函  
数是如何工作的了。这样做是使 Emacs 在消息缓冲区中对表达式求值，但是使用了  
 “*scratch*”缓冲区中位点的值。(M-：是 eval-expression 的绑定键。)  
  
我们发现：当我们这样做时，位点最后将位于最后插入的一行的末尾——这就是  
说，作为这个函数的附带效果，这个函数将位点移动了。如果我们这时(位点移动  
到这个位置时)试图重复使用这个函数，下一列将插入到原来插入的列的右下方。  
我们不能这样做！如果我们将要制作一个柱型图，每一列都应当伴着另一列。  
  
因此我们发现：插入列的每一次 while 循环，必须重新将位点置于我们需要的位  
置，而且这个位置必须是一列的顶部而不是底部。而且，我们记得：当打印一个  
图形时并不希望所有的列都是一样高的。这意味着每一列的顶部，可能与前面各  
列的顶部不一样高。因此，不能简单地在每一次循环中将位点置于同一行上……  

----------------------- Page 175-----------------------

  
我们正计划用星号打印柱型图。每一列上星号的数量是由 numbers-list 列表中的  
当前元素确定的。需要构建一个星号的列表，这个列表给出每一列上星号的正确  
数目，供 insert-rectangle 函数调用。如果这个列表仅仅包含所需的星号的数  
目，那么我们将正确定位，给出从打印的图形的底部开始向上究竟每一列占据多  
少行的高度。这是很难的。  
  
另外，如果能够找出一种方法给 insert-rectangle 函数传递一个等长度的列表，  
那么就能将位点置于同一行上，只需朝右移动一列就可以了。然而，如果这样做  
了，传递给 insert-rectangle 函数的列表中的某些元素必须是空格而不是星号。  
例如，如果图形的最大高度是 5，但是这一列的高度是 3，那么 insert-rectangle  
函数就需要这样一个列表：  
  
("" "" "*" "*" "*")  
  
最后这个方案不太难，只要能确定列的高度就行。有两种方法供我们确定某一列  
的高度：一是根据需要确定图形的高度；一是扫描整个数值列表，用其中最大的  
数作为图形的最大高度。如果后面一个方案难以实现，前一个方案将是最简单  
的，但是在 Emacs 中，有一个内置函数可以用来确定一个列表中的最大元素。我们  
可以使用这个函数，这个函数就是 max 函数，它返回其参量中最大的一个值。这个  
函数的参量必须是数字。例如，  
  
(max 3 4 6 5 7 3)  
  
将返回 7。(与 max 函数相对应的一个函数是 min 函数，这个函数返回其参量中最小  
的值。)  
  
然而，我们不能简单地在 number-list 列表上调用 max 函数。max 函数的参量是具体  
的数字，而不是数的列表。因而，下面的表达式，  
  
(max '(3 4 6 5 7 3))  
  
将产生一个错误消息：  
  
Wrong type of argument:integer-or-marker-p '(3 4 6 5 7 3)  
  
需要使用一个函数将参量列表传递给其他函数。这个函数就是 apply。这个函数将  
它的第一个参量(这个参量是一个函数)应用到其余的参量上，最后一个参量是一  
个列表。  
  
例如，  
  
(apply 'max 3 4 7 3 '(4 8 5))  
  

----------------------- Page 176-----------------------

返回 8。  
  
(顺便说一下，我不知道没有书的话你是如何学习类似的函数的。通过猜测其名字  
的一部分，然后使用 apropos 来查找它们，有可能发现其他的函数(如  
search-forward 或者 insert-rectangle)。即使 apply 这个函数名具有明显的喻  
意——将其第一个参量应用到其余参量上——我仍然怀疑一位新手是如何在使用  
apropos 或者其他工具的时候想到这个特定的单词的。当然，我可能错了，毕竟这  
个函数最初是由发明它的那个人命名的。)  
  
这个函数第二个以及后续的参量是可选的，因此可以使用 apply 函数来调用一个函  
数，并将一个列表的元素传递给这个函数。因此像下面这样也将返回 8:  
  
(apply 'max '(4 8 5))  
  
后面这种方法就是我们将使用 apply 函数的方法。  
recursive-lengths-list-many-files 函数返回一个长度列表，对这个列表可以使  
用 max(也可以将 max 函数用于排序后的长度列表，当然列表是否排序在此是无关紧  
要的)。  
  
因此，查找图形的最大高度的表达式就是：  
  
(setq max-graph-height (apply 'max numbers-list))  
  
现在我们能回到如何为图形的每一列创建一个字符列表的问题上了。知道了图形  
的最大高度和在这一列中的星号的数目，函数就应该返回一个供  
insert-rectangle 命令使用的字符串列表了。  
  
每一列都是由星号和空格组成的。因为函数接受的参量是列的最大高度和这一列  
的星号数量,所以空格的数目就是最大高度减去星号的数量。一旦给定了空格和星  
号的数量，用两个 while 循环就能构造 insert-rectangle 函数需要的列表：  
  
      ;;; First version.  
      (defun column-of-graph (max-graph-height actual-height)  
       "Return list of strings that is one column of a graph."  
        (let ((insert-list nil)  
              (number-of-top-blanks  
               (- max-graph-height actual-height)))  
  
          ;; Fill in asterisks.  
          (while (> actual-height 0)  
            (setq insert-list (cons "*" insert-list))  
            (setq actual-height (1- actual-height)))  
  
          ;; Fill in blanks.  

----------------------- Page 177-----------------------

          (while (> number-of-top-blanks 0)  
            (setq insert-list (cons " " insert-list))  
            (setq number-of-top-blanks  
                  (1- number-of-top-blanks)))  
  
          ;; Return whole list.  
         insert-list))  
  
如果安装了这个函数并对下面这个表达式求值，你将看到它返回一个你需要的列  
表：  
  
(column-of-graph 5 3)  
  
返回  
  
  (" " " " "*" "*" "*")  
  
co1umn-of-graph 函数有一个重要问题：图形中各列的空格和星号所用的符号都是  
 “硬编码”(hard-coded)的，在函数中就是空格和星号。对于一个原型函数来  
说，这很好。但是你或者其他用户可能希望使用其他符号。例如，在测试图形函  
数时，你可能希望用一个句点来代替其中的空格，以确保位点每一次都由  
insert-rectangle 函数正确设置。或者你可能希望使用"+"符号或者其他符号来代  
替星号。你甚至可能希望打印出来的图形每一列都占用超过一列的宽度。这个函  
数就应当更具伸缩性和弹性。用其他符号来代替空格和星号的途径是使用两个称  
为 graph-blank 和 grapp-symbol 的变量，并单独定义这两个变量。  
  
而且，函数文档还没有写好。基于这些考虑，我们编写了第二个函数定义：  
  
      (defvar graph-symbol "*"  
       "String used as symbol in graph, usually an asterisk.")  
  
      (defvar graph-blank " "  
       "String used as blank in graph, usually a blank space.  
     graph-blank must be the same number of columns wide  
     as graph-symbol.")  
  
  
(关于 defvar 的详细资料，参见 8.4 节“用 defvar 初始化变量”。)  
  
      ;;; Second version.  
      (defun column-of-graph (max-graph-height actual-height)  
       "Return MAX-GRAPH-HEIGHT strings; ACTUAL-HEIGHT are graph-symbols.  
     The graph-symbols are contiguous entries at the end  
     of the list.  

----------------------- Page 178-----------------------

     The list will be inserted as one column of a graph.  
     The strings are either graph-blank or graph-symbol."  
  
        (let ((insert-list nil)  
              (number-of-top-blanks  
               (- max-graph-height actual-height)))  
  
          ;; Fill in `graph-symbols'.  
          (while (> actual-height 0)  
            (setq insert-list (cons graph-symbol insert-list))  
            (setq actual-height (1- actual-height)))  
  
          ;; Fill in `graph-blanks'.  
          (while (> number-of-top-blanks 0)  
            (setq insert-list (cons graph-blank insert-list))  
            (setq number-of-top-blanks  
                  (1- number-of-top-blanks)))  
  
          ;; Return whole list.  
         insert-list))  
  
如果愿意，我们可以再一次重写 column-of-graph 函数，让用户选择打印一个线型  
图或者柱型图。这一点并不难做到。线型图与柱型图的不同在于柱型图中顶端与  
每一个柱条之间是空白部分。要构造一个线型图的一列，函数首先要构造一个空  
白列表，这个空白列表的长度比当前列的值小 1，然后用 cons 函数在这个列表中增  
加一个图形符号，最后使用 cons 函数往这个列表中增加顶端空白部分。  
  
编写这样一个函数是很容易的，但是由于我们不需要编写这个函数，因此我们不  
会做这份工作。但是这项工作应当被完成，并且如果要编写这样的函数，可以在  
column-of-graph 的基础上进行改写而得到。更为重要的是，值得提醒一下，只要  
做些很小的修改就行了。如果你愿意编写这个函数，更改或者增强的部分是很简  
单的。  
  
现在，最后，我们回到第一个打印图形的实际的函数上来。这个函数打印图形的  
主体部分，但是没有垂直轴和水平轴的坐标，因此可以称这个函数为  
graph-body-print。  
  
** 15.1 graph-body-print 函数  
  
经过前面章节的准备工作之后，graph-body-print 函数就很容易编写了。这个函  
数将一列一列地打印由星号和空格组成的列，每一列都对应着一个长度列表中的  
一个元素，这个列表中的每一个元素定义了该列中星号的数量。这是一个重复的  
动作，这意味着为此我们可以使用一个递减的 while 循环或者递归函数。在这一  
节，我们将编写使用 while 循环的函数定义。  

----------------------- Page 179-----------------------

  
column-of-graph 函数需要图形的高度作为其参量，因此应当确定并用一个局部变  
量记录图形的高度。  
  
这样 graph-body-print 函数的函数定义的模板就像如下所示：  
      (defun graph-body-print (numbers-list)  
       "DOCUMENTATION..."  
        (let ((height  ...  
              ...))  
  
          (while numbers-list  
           INSERT-COLUMNS-AND-REPOSITION-POINT  
            (setq numbers-list (cdr numbers-list)))))  
  
需要往这个函数定义模板中填写相应的代码。  
  
很明显，能够使用(apply 'max numbers-list)表达式来确定图形的高度。  
  
函数中的 while 循环将每次一个地遍历 numbers-list 列表中的每一个元素。每当  
numbers-list 列表由(setq numbers-list (cdr numbers-list))表达式不断地删  
去前面的一个元素而变得越来越短时，这个列表的每个实例的 car 就是传递给  
column-of-graph 的参量的值。  
  
在 while 的每一次循环中，insert-rectangle 函数插入由 column-of-graph 函数返  
回的列表。由于 insert-rectangle 函数将位点移动到插入的矩形的右下方，因此  
我们需要在插入矩形时保存当前位点的位置，在插入矩形之后将位点从矩形的右  
下方移回原来的位置，然后在水平方向上移动到下一个位置。  
  
如果插入的列是一个字符宽的，就像使用空格和星号表示的柱型图那样，重新定  
位位点的位置的表达式就是(forward-char 1)。然而，柱型图中列的宽度可能大  
于一个字符。这意味着重新定位位点位置的表达式应当写成(forward-char  
symbol-width)。变量 symbol-width 本身就是 graph-blank 的长度，并可以用  
(length graph-blank)表达式得到。将 symbol-width 变量绑定到图形列宽度值的  
最佳位置是在 let 表达式的变量列表中。  
  
基于这些考虑，graph-body-print 函数的函数定义就应当如下所示：  
  
      (defun graph-body-print (numbers-list)  
       "Print a bar graph of the NUMBERS-LIST.  
     The numbers-list consists of the Y-axis values."  
  
        (let ((height (apply 'max numbers-list))  
              (symbol-width (length graph-blank))  
             from-position)  

----------------------- Page 180-----------------------

  
          (while numbers-list  
            (setq from-position (point))  
            (insert-rectangle  
             (column-of-graph height (car numbers-list)))  
            (goto-char from-position)  
            (forward-char symbol-width)  
            ;; Draw graph column by column.  
            (sit-for 0)  
            (setq numbers-list (cdr numbers-list)))  
          ;; Place point for X axis labels.  
          (forward-line height)  
          (insert "\n")  
     ))  
  
在这个函数定义中，一个意想不到的表达式是 while 循环中的(sit-for 0)。这个  
表达式使打印图形的操作比其他方式更为有趣。这个表达式使 Emacs “停下来”，  
或者在一段时间内什么也不做，然后重绘屏幕。将这个表达式放在这里，就使  
Emacs 一列一列地显示图形。没有这一个表达式，Emacs 将在函数结束退出时才将  
图形显示出来。  
  
可以用一个简短的数字列表来测试 graph-body-print 函数。  
  
1) 安装 graph-symbol、graph-blank、column-of-graph 和 graph-body-print。  
  
2) 拷贝下面的表达式：  
  
    (graph-body-print '(1 2 3 4 6 4 3 5 7 6 5 2 3))  
  
3) 切换到 “*scratch*”缓冲区，将光标置于需要绘制图形的位置。  
  
4) 键入 M-: (eval-expression)。  
  
5) 在小缓冲区中用 C-y (yank)命令找到 graph-body-print 表达式。  
  
6) 按回车键对 graph-body-print 表达式求值。  
  
  
Emacs 将打印如下图形：  
  
                         *  
                     *   **  
                     *  ****  
                    *** ****  

----------------------- Page 181-----------------------

                   ********* *  
                  ************  
                 *************  
  
** 15.2 recursive-graph-body-print 函数  
  
graph-body-print 函数也可以用递归的方法来编写。在这种情况下，这个函数被  
分成两个部分：外层部分使用 let 表达式来决定几个变量的值，如图形高度的最大  
值等，这些值都是只要开始时定下来就行了；内层的一个函数则递归地打印图形。  
  
外层的函数并不复杂：  
  
      (defun recursive-graph-body-print (numbers-list)  
       "Print a bar graph of the NUMBERS-LIST.  
     The numbers-list consists of the Y-axis values."  
        (let ((height (apply 'max numbers-list))  
              (symbol-width (length graph-blank))  
             from-position)  
          (recursive-graph-body-print-internal  
          numbers-list  
          height  
          symbol-width)))  
  
其中的递归调用部分有点儿复杂。它由四个部分组成：一个“do-again-text”真  
假测试表达式、打印图形的代码、递归调用以及“next-step”表达式。真假测试  
表达式是一个 if 表达式，决定 numbers-list 列表是否还包含有元素，如果有，则  
函数继续打印一列图形，并再次调用自己。这个函数根据“next-step”表达式产  
生的值来递归调用自身。“next-step”表达式产生一个更短的 numbers-list 列表。  
  
      (defun recursive-graph-body-print-internal  
        (numbers-list height symbol-width)  
       "Print a bar graph.  
     Used within recursive-graph-body-print function."  
  
        (when numbers-list  
              (setq from-position (point))  
              (insert-rectangle  
               (column-of-graph height (car numbers-list)))  
              (goto-char from-position)  
              (forward-char symbol-width)  
              (sit-for 0)     ; Draw graph column by column.  
              (recursive-graph-body-print-internal  
               (cdr numbers-list) height symbol-width)))  
  

----------------------- Page 182-----------------------

安装后，就可以测试这个表达式了。下面是一个例子：  
  
(recursive-graph-body-print '(3 2 5 6 7 5 3 4 6 4 3 2 1))  
  
对这个表达式求值就产生下面的打印结果：  
  
                     *  
                    **   *  
                   ****  *  
                   **** ***  
                 * *********  
                 ************  
                 *************  
  
graph-body-print 函数或者 recursive-graph-body-print 函数都只是打印图形的  
主体部分。  
  
** 15.3 需要打印的坐标轴  
  
一个图形总是需要坐标轴的，有了它你才能确定方向。对于一次性的项目，有足  
够的理由使用 Emacs 的图形模式来绘制坐标轴。但是，对于一个图形打印函数而  
言，就需要多次绘制坐标轴。  
  
基于这个原因，我已经编写了对基本的 graph-body-print 函数的功能扩展部分，  
这个部分自动打印垂直与水平坐标轴的坐标。因为坐标轴打印函数没有包含什么  
新的东西和内容，我就将它放在附录 C “带坐标轴的图”中介绍了。  
  
** 15.4 练习  
  
编写一个线型图打印函数。  
  
* 第 16 章 配置你的".emacs"  
  
 “不要只为了喜欢 Emacs 而喜欢它”——这句看似悖论的话其实就是 GNU Emacs 的秘  
密所在。通常的 Emacs 是一个通用的工具。大多数使用它的人都根据自己的要求来  
定制适合自己的 Emacs。  
  
GNU Emacs 的大部分是用 Emacs Lisp 编写的，这意味着通过在 Emacs Lisp 中编写表  
达式，你能够改变或者扩充 Emacs。  
  
也有些人喜欢 Emacs 的默认配置。毕竟，当你编辑一个 C 语言文件时，Emacs 就进入  
C 语言模式；当你编辑一个 Fortran 语言文件时，Emacs 就进入 Fortran 模式；而当  
你编辑一个无格式的文件时，Emacs 就进入基本模式。如果你不知道谁将使用  
Emacs，这种适应性很有意义。有谁知道哪种用户希望用 Emacs 编辑无格式的文件  

----------------------- Page 183-----------------------

呢？Emacs 的基本模式就是针对编辑这种文件的，就像 C 模式是默认针对 C 语言文件  
的一样。但是当你确实知道将使用 Emacs 的人就是你自己时，那么你自己定制  
Emacs 环境就有意义了。  
  
例如，当我编写一个没有特定目的普通文件时，我很少希望进入基本模式，我希  
望进入文本模式。这就是为什么我要定制 Emacs 的原因：使它适合我。  
  
通过编写或者改编“~/.emacs”文件，你就能够定制并扩充 Emacs。这是你个人的  
初始化文件，它的内容是由 Emacs Lisp 编写的，其作用是告诉 Emacs 做些什么。  
  
这一章描述一个简单的“.emacs”文件，关于这个文件的更多信息参见《GNU  
Emacs 技术手册》以及《GNU Emacs Lisp 技术手册》的有关章节。  
  
** 16.1 全站点的初始化文件  
  
除了你个人的初始化文件之外，如果存在全站点初始化文件，Emacs 将自动加载各  
种不同的全站点初始化文件。这些文件的格式与你个人的初始化文件的格式是一  
样的。但是这些文件供所有人加载。  
  
最常见的情况是，"site-load.el"和"site-init.el"两个全站点初始化文件被加  
载到 Emacs 中，然后如果创建了一个转储版本，随后就转储这两个文件。(Emacs 的  
转储版本可以加载得更快，然而，一旦一个文件被加载和转储了，对这个文件的  
改变就不会改变 Emacs，除非你自己来加载这个文件或者重新转储它。参见《GNU  
Emacs Lisp 技术手册》中"建立 Emacs"一节和"INSTALL"文件。)  
  
其他三个全站点初始化文件在你每一次使用 Emacs 时就会被自动地加载(如果这三  
个文件存在的话)。这些文件中，"site-start.el"文件在用户个人的初始化文件  
 “.emacs”加载之前被加载，"default.el"以及终端类型文件都是在用户个人的  
初始化文件“.emacs”加载之后被加载。  
  
用户个人的初始化文件“.emacs”中的设置以及定义将覆盖“site-start.el”文  
件(如果它存在的话)中与之有冲突的设置和定义。但是"default.el"以及终端类  
型文件中的设置和定义将覆盖用户个人的初始化文件中有冲突的设置和定义。(你  
将终端类型文件中的 term-file-prefix 项设置成 nil，就可以避免终端类型文件的  
干扰。参见 16.10 节，"一个简单的功能扩充"。)  
  
Emacs 的发行版本中的“INSTALL”文件描述了“site-init.el”和  
 “site-load.el”这两个文件。  
  
"loadup.el"、"startup.el"以及"loaddefs.el"文件控制 Emacs 初始化文件的加载  
过程。这些文件都位于 Emacs 发行版本的“lisp”目录中，都值得好好研究。  
  
"loaddefs.el"文件包含了许多建议，如你个人的初始化文件中应当放些什么内  
容，或者在一个全站点初始化文件中应当放些什么内容，等等。  

----------------------- Page 184-----------------------

  
** 16.2 为一项任务设置变量  
  
我的 Emacs 第 19.23 版中有 392 个可选项，可以用 edit-options 命令来设置它们。这  
些“可选项”无外乎就是一些变量，与我们前面已经看到的用 defvar 定义的变量  
没有什么两样。  
  
Emacs 判断一个变量是否是可以设置的，是通过观看这个变量的说明文档字符串中  
的第一个字符来决定的；如果说明文档字符串中的第一个字符是一个星号"*"，这  
个变量就是用户可以自行设置的选项。(参见 8.4 节，“用 defvar 初始化变量”。)  
  
edit-options 命令列出了当人们在编写 Emacs Lisp 函数库时 Emacs 中所有可以重新  
设置的变量。它提供了一个易于使用的界面来重新设置这些变最。  
  
另一方面，使用 edit-options 命令来设置的可选项只在你的编辑会话中有效。这  
些新的值并不永久保存供其他会话使用。Emacs 每一次启动，它都读入其源代码中  
的初始定义的变量。要实现在不同会话之间永久地保存一个变化的设置，你需要  
在“.emacs”或者其他初始化文件中使用 setq 表达式来设置。  
  
对我来说，edit-options 命令的主要用法是用来建议哪些变量应当由我自己在初  
始化文件“.emacs”中设置。我强烈要求你仔细浏览一遍这个变量列表。  
  
关于这个问题的更多信息，参见《GNU Emacs 技术手册》中“编辑变量的值”一  
节。  
  
** 16.3 开始改变".emacs"文件  
  
当你启动 Emacs 时，它加载你个人的初始化文件".emacs"，除非你在命令行用  
"-q"参数告诉它不要加载这个文件。( emacs -q 命令使你进入普通模式)。  
  
".emacs"文件包含了 Lisp 表达式。通常，这无非是一些设置变量的表达式，有时  
也有函数定义表达式。  
  
关于初始化文件的简短描述，参见《GNU Emacs 技术手册》中的“初始化文件  
`~/.emacs'”一节。  
  
这一章仔细讲解一些共同的东西，但是会对一个完整的、我长期使用的  
 “.emacs”文件作一个通盘介绍。  
  
这个文件的第一个部分由注释组成：用于提醒自己。现在，当然，我记得这些东  
西，但是当我刚接触 Emacs 时，并不记得这么多。  
  
;;;;Bob's .emacs file  
;Robert J.Chassell  

----------------------- Page 185-----------------------

;26 September 1985  
  
瞧这个日期！我使用这个文件已经有相当长的历史了。我从那时起不断增加其内容。  
  
;Each section in this file is introduced by a  
;line beginning with four semicolons; and each  
;entry is introduced by a line beginning with  
;three semicolons.  
  
这一段描述 Emacs Lisp 中往释的通常惯例。每一个以一个分号开始的行都是一个  
注释行，两个、三个或者四个分号分别是节和小节的标记。(参见《GNU Emacs  
Lisp 技术手册》中的“注释”一节。)  
  
;;;;the Help Key  
;Control-h is the help key;  
;after typing control-h, type a letter to  
;indicate the subject about which you want help.  
;For an explanation of the help facility,  
;type control-h three times in a row．  
  
记住，连续键入 C-h 三次就可得到帮助信息。  
  
;To find out about any mode, type control-h m  
;while in that mode. For example, to find out  
;about mail mode, enter mail mode and then type  
;control-h m.  
  
这是"Mode help"(模式帮助)提示，就像我自己称呼的这样，是非常有用的。通  
常，它告诉你所有你需要知道的东西。  
  
当然，你无需在你自己的初始化文件“.emacs”中加入这样的注释。我将这些注  
释加入到我的初始化文件中是因为我总是忘记模式帮助以及注释的惯例——但是我  
可以记得来这里看一看让自己得到提醒。  
  
** 16.4 文本和自动填充模式  
  
现在开始学习开启"Text mode"(文本模式)和"Auto Fill"(自动填充)模式的部分。  
  
;;;Text mode and Auto Fill mode  
;The next two lines put Emacs into Text mode  
;and Auto Fill mode, and are for writers who  
;want to start writing prose rather than code.  
  
(setq default-major-mode 'text-mode)  

----------------------- Page 186-----------------------

(add-hook 'text-mode-hook 'turn-on-auto-fill)  
  
这是".emacs"文件的第一部分，这一部分没有别的功能，无非是为了提醒一个健  
忘的人而已。  
  
括号中的这两行告诉 Emacs，当找到一个文件时就开启文本模式，除非那个文件应  
当进入别的模式，如 C 模式等。  
  
当 Emacs 读入一个文件时，它查看这个文件名的后缀(如果有后缀的话)。(文件名  
后缀是以“.”开始的那个部分)。如果文件是以“.c”结尾的，或者以“.h”结  
尾，那么 Emacs 就进入 C 模式。同样，Emacs 查看这个文件的第一个不是空白的行，  
如果这一行是“-*-C-*-”，那么 Emacs 也进入 C 模式。Emacs 拥有一个后缀列表并  
自动地使用它。另外，如果缓冲区的最后一页中有一个局部变量列表，Emacs 就查  
看缓冲区最后一页中的这个局部变量列表，根据它的内容来决定进入何种模式。  
  
有关更多的信息，请参见《GNU Emacs 技术手册》中的“如何选择主要的模式”  
一节和“文件中的局部变量”一节。  
  
现在回到初始化文件“.emacs”中。  
  
后面的一行就列在下面，它是如何工作的呢？  
  
    (setq default-major-mode 'text-mode)  
  
这一行很短，但是它确实是一个 Emacs Lisp 表达式。  
  
我们已经熟悉了 setq 函数，它将后续的变量 default-major-mode 设置为  
text-mode。在 text-mode 之前的单引号是告诉 Emacs 直接处理 text-mode 变量，而  
不是其内容。参见 1.9 节“给一个变量赋值”可以得到关于 setq 的资料。值得重提  
的主要的一点是，在“.emacs"文件中设置一个变量的过程与在 Emacs 其他地方设  
置变量的过程没有任何区别。  
  
第二行是：  
  
   (add-hook 'text-mode-hook 'turn-on-auto-fill)  
  
在这一行，add-hook 命令将 turn-on-auto-fill 加到变量 text-mode-hook 之后。而  
turn-on-auto-fill 是一个程序的名字，它启动自动填充模式。  
  
Emacs 每次启动文本模式，它都运行这些命令改变文本模式的某些属性。因  
此，Emacs 每次启动文本模式，Emacs 同时也启动了自动填充模式。  
  
简而言之，当你编辑一个文件时，上面的第一行使 Emacs 进入文本模式，除非这个  
文件的后缀名、文件的第一个非空的行或者局部变量告诉 Emacs 进入其他模式。  

----------------------- Page 187-----------------------

  
其他动作当中的文本模式为用户设置语法表以方便用户。在文本模式中，Emacs 认  
为省略号是单词的一个部分就像构词要素字符一样，但是 Emacs 并不认为句点或者  
一个空格是单词的一个部分。因而，M-f 使你移过“it's”。另一方面，在 C 模式  
下，M-f 则停在“it's”的"t"字母之后。  
  
第二行使 Emacs 在开启文本模式的时候，同时开启自动填充模式。在自动填充模式  
中，Emacs 自动地分行使超出屏幕的过多的文本自动转移到下一行。Emacs 在单词  
之间分行，而不是在单词中分行。  
  
当自动填充模式被关闭时，如果你不断输入字符，它们就不断地接在这行的后  
面，而不换行。根据你设置的 truncate-lines 的值，你输入的单词要么显示在你  
的屏幕之外，要么被显示出来，当然这些单词是以相当难看和难以阅读的格式在  
一个连续行显示的。  
  
** 16.5 邮件别名  
  
下面是一个“开启”邮件别名的 setq 表达式，当然还包括不少提示信息：  
  
;;; Mail mode  
;To enter mail mode, type `C-x m'  
;To enter RMAIL (for reading mail),  
;type `M-x rmail'  
  
(setq mail-aliases t)  
  
这个 setq 表达式设置变量 mail-aliases 的值为 t。因为 t 就是指“真”，这一行意  
思就是说，“对，使用邮件别名。”  
  
使用邮件别名可以很方便地用简短的名字代替很长的邮件地址或者邮件地址列表。  
存放你的邮件别名的文件是“~/.mailrc”。使用别名的方法如下所示：  
  
alias geo george@foobar.wiz.edu  
  
当你给 George 一个消息时，只要指出地址“geo”即可；邮件程序会自动将  
 “geo”别名扩展成它完整的邮件地址。  
  
** 16.6 缩排模式  
  
默认的情况下，如果要格式化一个区域，Emacs 在多个空格的地方插入制表符来代  
替。(例如，可能用 indent-region 命令一次性地缩排多行文本。)在终端屏幕上或  
者普通打印时，使用制表符将是很好的。但是当你使用 TEX 或者 Texinfo 时，由于  
TEX 忽略制表符，因此使用制表符的话将得到错误缩排的输出。  
  

----------------------- Page 188-----------------------

下面的表达式关闭制表符缩排模式：  
  
;;; Prevent Extraneous Tabs  
(setq-default indent-tabs-mode nil)  
  
注意，上面的表达式使用 setq-default 函数而不是前面看到的 setq 函数。  
setq-default 命令只是在缓冲区中设置值而不是为变量设置它自己的局部值。  
  
参见《GNU Emacs 技术手册》中的“制表符和空格”一节以及“文件中的局部变  
量一节”。  
  
** 16.7 一些绑定键  
  
现在该讲讲一些个人的绑定键了：  
  
;;;Compare windows  
(global-set-key "\C-cw" 'compare-windows)  
  
compare-windows 是一个极有用的命令，这个命令将你当前缓冲区中的文本与下一  
个窗口中的文本进行比较。它将位点置于每一个窗口的开始进行比较，只要能够  
匹配就尽可能使位点移过整个缓冲区。我总是使用这个命令。  
  
这个表达式同样显示了如何设置一个全局性的绑定键。这种设置对所有模式都是  
有效的。  
  
设置全局性的绑定键的命令就是 global-set-key。这个命令之后就是绑定键。在  
一个".emacs"文件中，键的绑定是这样完成的：\C-c 代表"control-c"，这是指  
 “同时按下 control 键和 c 键”。其中的 w 是指 “按下 w 键”。绑定键是由双引号包  
围的。在文档中，可以这样写：C-c w。(如果绑定 meta 键(如 M-c)而不是 control  
键，应该这样写：\M-c。)关于这个问题的详细资料，可以参见《GNU Emacs 技术  
手册》中的“在用户初始化文件中重新绑定键”一节。  
  
由这些键激活的命令是 compare-windows。注意，compare-windows 是由一个单引  
号开始的，否则 Emacs 将首先试图对这个符号求值来决定它的值。  
  
双引号、C 字符前的反斜线以及单引号，都是键绑定过程的三个必要的部分，而这  
往往是我经常忘记的。幸运的是，我已经开始记得应当看一看自己的初始化文件，  
并采纳其中的提示。这就是注释的妙处。  
  
对于这个绑定键本身：C-c w，它是由前缀键和一个单字符组成的。在这个例子  
中，前缀键就是 C-c，单字符就是 w。这个键的集合，C-c 和其后的 w 键，是保留给  
用户使用的。如果你编写一个表达式来扩充 Emacs 的功能，请避免使用这些键。你  
可以创建一个类似 C-c C-w 的绑定键。否则，我们将会“用光”留给自己使用的键。  
  

----------------------- Page 189-----------------------

下面是另外一个键绑定及其注释：  
  
;;; Keybinding for `occur'  
; I use occur a lot, so let's bind it to a key:  
(global-set-key "\C-co" 'occur)  
  
其中的 occur 命令显示当前缓冲区中包含了与某个正则表达式匹配内容的所有行。  
匹配的行显示在一个称为“*occur*”的缓冲区中。这个缓冲区是作为一个菜单来  
显示结果的。  
  
要取消一个键的绑定，下面的表达式将告诉你如何做。取消键绑定之后，这些键  
就不再起作用了。  
  
;;; Unbind `C-x f'  
(global-unset-key "\C-xf")  
  
之所以要取消键绑定，是因为我发现当我要键入 C-x C-f 的时候不可避免地键入了  
C-x f。也就是说，当我要查找一个文件的时候，总是不小心设置了不是我所需要  
的文本宽度。因为我几乎从不重新设置默认的文本宽度，因此我简单地取消了这  
个键绑定。  
  
下面的表达式重新绑定一个已经存在的键绑定：  
  
;;; Rebind `C-x C-b' for `buffer-menu'  
(global-set-key "\C-x\C-b" 'buffer-menu)  
  
默认的情况是，C-x C-b 运行了 list-buffer 命令。这个命令在另外一个窗口中列  
出所有的缓冲区。因为我几乎总是要在这个窗口中做点什么，因此我更喜欢  
buffer-menu 命令。这个命令不仅列出所有缓冲区，而且将位点移动到那个缓冲区  
中。  
  
** 16.8 加载文件  
  
GNU Emacs 社团中的许多人已经为 Emacs 编写了大量的扩展功能。随着时间的流逝，这些  
扩展功能经常被包含在新发行的版本之中，例如，Calendar 和 Diary 包现在都是标准的 Emacs  
第 19 版的一部分了。但是它们曾经并不是标准的 Emacs 第 18 版中的一部分。  
  
(calc 是一个计算器，我认为这是 Emacs 的一个重要部分，应该成为 Emacs 的一个标  
准发行版的部分，只是它太大了而成为了一个独立的软件包。)  
  
能够使用 load 命令对一个完整的文件求值，并因此将这个文件中所有函数和变量  
安装到 Emacs 中。例如，  
  
(load "~/emacs/kfill")  

----------------------- Page 190-----------------------

  
对这个表达式求值，即从用户个人目录的“emacs”子目录中加载“kfill.el”文  
件。(或者如果存在的话，加载这个文件的字节编译文件“kfill.elc”速度会更  
快。)  
  
("kfill.el"是 Bob Weiner 从 Kyle E. Jones 的“filladapt.el”包中整理出来  
的，并且它提供从新闻或者邮件消息，以及从 Lisp C++和 PostScript 甚至 shell 注  
释中获得的缩排的、清晰文本的功能。我经常使用它们，也希望它能被打包进入  
标准的发行版本中。)  
  
如果你要加载许多扩充功能包，就像我这样，无需精确指定扩充文件的准确路  
径，只要像上面那样指定它们作为 Emacs 的 load-path 一部分的目录即可。然后，  
当 Emacs 加载一个文件时，它将查询这个目录以及它的默认的目录列表。(默认的  
目录列表是 Emacs 安装时在"paths.h"文件中指定的。)  
  
下面的命令将你的“~/emacs”目录增加到已经存在的加载目录中：  
  
;;; Emacs Load Path  
(setq load-path (cons "~/emacs" load-path))  
  
顺便说一下，load-library 是 load 函数的交互接口，这个函数的完整形式如下所  
示：  
  
(defun load-library (library)  
"load the library named LIBRARY.  
This is an interface to the function `load'."  
   (interactive "sLoad library:")  
   (load library))  
  
这个函数的函数名，load-library，来自于人们使用"library"(库)来作为  
"file"(文件)的同义语。load-library 命令的源代码在"files.el"库中。  
  
有另外一个交互命令与 load-file 命令完成相似的工作。参见《GNU Emacs 技术手  
册》中的“Emacs 的 Lisp 代码库”，可以得到关于 load-library 和 load-file 之间  
差别的信息。  
  
** 16.9  自动加载  
  
除了通过加载包含指定函数的文件来实现函数的加载和安装，以及通过对函数定  
义求值来实现函数的安装之外，你还能够在不真正安装函数代码的情况下使用这  
个函数。这个函数是在它第一次被调用的时候安装的。这称为自动加载。  
  
当你执行一个自动加载函数时，Emacs 自动地对包含这个函数的文件求值，然后调  
用这个函数。  

----------------------- Page 191-----------------------

  
Emacs 使用自动加载函数时执行得更快，因为自动加载函数的函数库不是直接被加  
载的，你在第一次使用这个函数的时候需要稍微等待一会儿，这是因为包含这个  
函数的文件正在被求值。  
  
不常用的函数经常是自动加载的函数。“loaddefs.el”库包含了几百个自动加载  
的函数，从 bookmark-set 到 workstar-mode。当然，你可能经常使用一个“不常  
用”的函数。在这种情况下，你应当在自己的“.emacs”初始化文件中用一个  
load 表达式加载包含这个函数的文件。  
  
在我的 Emacs 第 19.23 版的“.emacs”初始化文件中，我一共加载了 17 个库，这些  
库包含了原本要被自动加载的函数。(实际上，当我创建我的 Emacs 时，我应当将  
它包含在我的“转储” Emacs 中。但是我忘了。关于“转储”的更详细的介绍，  
参见《GNU Emacs Lisp 技术手册》中的“创建 Emacs”一节。)  
  
你也可以将自动加载函数的相关文件包含在你个人的“.emacs”初始化文件的自  
动加载的表达式中。auto1oad 是一个内置的函数，这个函数接收五个参量。其中  
的最后三个是可选的。第一个参量是被自动加载的函数名，第二个参量是被加载  
的文件名。第三个参量是为这个函数编写的文档。而第四个参量是告之这个函数  
是否能被交互地调用。最后一个参量，也就是第五个参量，告诉对象是什么类型  
的——autoload(自动加载)函数可以处理函数也可以处理键图和宏。(默认情况下是  
函数)  
  
下面是一个典型的例子：  
  
(autoload 'html-helper-mode  
 "html-helper-mode" "Edit HTML documents" t)  
  
这个表达式从 html-helper-mode.el 文件中(或者如果存在的话就从  
html-helper-mode.elc 文件中加载)自动加载 html-helper-mode 函数。这个文件必  
须是在由 load-path 定义的一个目录中。函数的文档说，这是一个帮助你用 HTML 语  
言编辑文档的模式。键入 M-x html-helper-mode，你能够交互地调用这个模式。  
(你需要复制自动加载表达式中的函数文档，因为这个函数还没有加载，因此它  
的文档也没有。)  
  
参见《GNU Emacs Lisp 技术手册》的“自动加载”一节，可以得到更多的信息。  
  
** 16.10 一个简单的功能扩充：line-to-top-of-window  
  
这是一个对 Emacs 的简单的功能扩充，这个扩充使某一行的位置移动到窗口的顶端。  
我总是使用这个函数以使文本易于阅读。  
  
你可以将下面的代码放进一个独立的文件中，并从你个人的“.emacs”初始化文  
件中加载它，或者你可以将这个函数包含在你个人的“.emacs”初始化文件中。  

----------------------- Page 192-----------------------

  
下面就是这个函数的定义：  
  
;;; Line to top of window;  
;;; replace three keystroke sequence C-u 0 C-l  
(defun line-to-top-of-window ()  
"Move the line point is on to top of window．"  
  (interactive)  
  (recenter 0))  
  
 【实际上，在我的 Emacs 23.2 版中，实现这个功能可以这样按键：C-0 C-l。（按住  
Ctrl 键不放，按 0 键，松开后再按 l 键，最后同时松开 Ctrl 键和 l 键。）——Chiron 注】  
   
现在就要绑定组合键了。  
  
虽然大部分 Emacs 第 18 版的“.emacs”文件在第 19 版下工作得很好，但是它们之间  
还是有区别的(当然，在第 19 版中有一些新的特性)。  
  
在第 19 版的 Emacs 中，你可以编写这样的函数："[f6]" 【指"[f6]"这种写法代表键  
盘上的功能键 F6。——Chiron 注】。在第 18 版中，你必须由键盘指定键序列。例  
如，对于一个 Zenith29 键盘而言，当我按下它的第六个功能键的时候，键盘发送  
ESC P 键序；对于一个 Ann Arbor Ambassador 型的键盘，则发送一个 ESC O F 键序  
列。这些键序列应被分别写成"\eP"和"\eOF"。  
  
在我的第 18 版的“.emacs”初始化文件中，我将 line-to-top-of-window 绑定到一  
个键上，这个键依赖于终端的类型：  
  
(defun z29-key-bindings ()  
 "Function keybindings for Z29 terminal."  
;;...  
  (global-set-key "\eP" 'line-to-top-of-window))  
  
(defun aaa-key-bindings ()  
 "Function keybindings for Ann Arbor Ambassador"  
;;...  
  (global-set-key "\eOF" 'line-to-top-of-window))  
  
(你可以通过键入功能键来发现各个功能键的键值，然后键入 C-h l  
(view-lossage)来显示最后 100 个键序列的值。)  
   
在定义了绑定键之后，我对一个表达式求值，这个求值是根据我所使用的终端的  
类型从各种键序列中选择出来的。然而，在这样做之前，我关闭了预先定义的、  
与终端类型相关的默认绑定键，因为如果它们冲突的话就会覆盖在“.emacs”中  
定义的键序列。  

----------------------- Page 193-----------------------

  
;;;Turn off Predefined Terminal Keybindings  
  
;The following turns off the predefined  
;terminal-specific keybindings such as the  
;vt100 keybindings in lisp/term/vt1OO.el.  
;If there are no predefined terminal  
;keybindings. or if you like them,  
;comment this out.  
  
(setq term-file-prefix nil)  
  
下面是选择表达式本身：  
  
(let ((term (getenv "TERM")))  
  (cond  
   ((equal term "z29") (z29-key-bindings))  
   ((equal term "aaa") (aaa-key-bindings))  
   (t (message  
    "No binding for terminal type %s."  
    term))))  
  
在第 19 版中，功能键(包括鼠标事件和非 ASCII 字符)都是写在方括号中的，而不要  
引号。将 line-to-top-of-window 绑定到 F6 功能键上：  
  
(global-set-key [f6] 'line-to-top-of-window)  
  
简单多了！  
  
关于绑定键的更详细的信息，参见《GNU Emacs 技术手册》中的“在你的初始化  
文件中重新绑定键”一节。  
  
如果同时运行 Emacs 的第 18 版和第 19 版两个版本，可以用下面的条件表达式选择其  
中之一求值：  
  
(if (string=  
      (int-to-string 18)  
      (substring (emacs-version) 10 12))  
    ;;evaluate version 18 code  
   (progn  
      …)  
    ;;else evaluate version 19 code  
  ...  
  

----------------------- Page 194-----------------------

** 16.11 键图  
  
Emacs 使用键图(keymaps)来记录什么键调用什么命令。特定的模式，如 C 模式或者  
文本模式，都有它们自己的键图。与模式有关的键图将覆盖由所有缓冲区共享的  
全局键图。  
  
global-set-key 函数的功能是绑定、或者重新绑定全局键图。例如，下面的键绑  
定表达式将 C-c C-l 绑定到 line-to-top-of-window 函数：  
  
(global-set-key "\C-c\C-l" 'line-to-top-of-window)  
  
与模式有关的键图是用 define-key 函数绑定的，它接受一个指定的键图、键以及  
命令作为其参量。例如，我的“.emacs”初始化文件包含下面的表达式，这些表  
达式将命令 texinfo-insert-@group 绑定到 C-c C-c g:  
  
(define-key texinfo-mode-map "\C-c\C-cg"  
  'texinfo-insert-@group)  
  
texinfo-insert-@group 函数本身是对 Texinfo 模式的一个小的功能扩充，这个表  
达式将"@group"插入到一个 Texinfo 文件中。我总是用这个命令，而且喜欢键入  
C-c C-c g 而不喜欢键入@group。("@group"和它的对应物"@end group"是将一页  
中的文本组织起来的两个命令，在这本书中许多的多行例子都是由这两个命令  
"@group...@end group"组织起来的。)  
  
下面是 texinfo-insert-@group 函数的定义：  
  
(defun texinfo-insert-@group ()  
 "Insert the string @group in a Texinfo buffer."  
  (interactive)  
  (beginning-of-line)  
  (insert "@group\n"))  
  
(当然，我可以使用缩写模式来节省打字输入，而不是编写一个函数来插入一个单  
词，但是我更喜欢与 Texinfo 模式中的绑定键一致的键序列。)  
  
你将在“loaddefs.el”中看到大量的 define-key 表达式，也将在不同的模式库  
(如"c-mode.el"和"lisp-mode.el"中看到这些表达式)。  
  
关于这方面的更多的信息，参见《GNU Emacs 技术手册》中的“定制键绑定”一  
节和《GNU Emacs Lisp 技术手册》中的“键图”一节。  
  
** 16.12 X11 的颜色  
  
当你在 MIT X Window 系统上使用 Emacs 第 19 版及以上的版本时，你就能够定义屏幕  

----------------------- Page 195-----------------------

显示的颜色。(所有前面的例子既能在第 19 版上运行，也能在第 18 版上运行，但是  
这一节讲述的内容只能在第 19 版上起作用。)  
  
我讨厌自己系统中的默认颜色，因此我要自己指定颜色。  
  
在我的系统中，大部分对颜色的定义放在不同的 X 初始化文件之中。同时我在自己  
的".emacs"初始化文件中做了注释，提醒我自己所做的修改：  
  
;; I use TWM for window manager;  
;; my ~/.xsession file specifies:  
;   xsetroot -solid navyblue -fg white  
  
实际上，X window 系统的根目录根本不是 Emacs 的一部分，但是我喜欢这种提示。  
  
;;My ~/.Xresources file specifies:  
;     XTerm*Background:    sky blue  
;     XTerm*Foreground：    white  
;     emacs*geometry:      =8Ox40+100+0  
;     emacs*background:    blue  
;     emacs*foreground:    grey97  
;     emacs*cursorColor：  white  
;     emacs*pointerColor:  white  
  
下面是在我的“./emacs”初始化文件中的设置这些变量的表达式：  
  
;;;Set highlighting colors for isearch and drag  
(set-face-foreground 'highlight "white")  
(set-face-background 'highlight "slate blue")  
(set-face-background 'region "slate blue")  
(set-face-background  
 'secondary-selection  "turquoise")  
  
;; Set calendar highlighting colors  
(setq calendar-load-hook  
      '(lambda ()  
         (set-face-foreground 'diary-face "skyblue")  
         (set-face-background 'holiday-face "slate blue")  
         (set-face-foreground 'holiday-face "white")))  
  
不同的蓝色阴影使我的眼睛感觉很柔和，并使我避免看到屏幕的闪烁。  
  
** 16.13 V19 中的小技巧  
  
这里列出的是第 19 版中设置的一些小技巧：  

----------------------- Page 196-----------------------

  
1) 自动根据需要改变小缓冲区的大小：  
  
    (resize-minibuffer-mode 1)  
    (setq resize-minibuffer-mode t)  
  
2) 开启对查询字符串的高亮显示：  
  
   (setq search-highlight t)  
  
3) 将每一个框架都设置为显示一个菜单条，并在你的鼠标移动到它上面时弹出菜  
   单：  
  
   (setq default-frame-alist  
        '((menu-bar-lines . 1)  
           (auto-lower . t)  
           (auto-raise . t)))  
  
4) 设置鼠标的形状和颜色：  
  
;cursor shapes are defined in  
;'/usr/include/X11/cursorfont.h';  
;for example, the 'target' cursor is number 128;  
;the 'top_left_arrow' cursor is number 132.  
(let ((mpointer (x-get-resource "*mpointer"  
                                "*emacs*mpointer")))  
;;If you have not set your mouse pointer  
;;then sent it, otherwise leave as is:  
(if (eq mpointer nil)  
     (setq mpointer "132")) ;top_left_arrow  
  (setq x-pointer-shape (string-to-int mpointer))  
  (set-mouse-color "white"))  
  
** 16.14 修改模式行  
  
最后，还有一个特性是我喜欢的：修改模式行。  
  
因为我有时在一个网络系统上工作，因此我经常将平时正常显示在模式行的左边  
部分的"Emacss"用我当时的系统名替代——否则的话，我会忘记自己究竟在使用哪  
一台计算机。另外，我总是列出默认的目录以免不知道自己处于什么位置，并且  
我开启行位点开关，使其显示"Line"值。我的“.emacs”初始化文件如下所示：  
  
(setq mode-line-system-identification  
  (substring (system-name) 0  

----------------------- Page 197-----------------------

             (string-match "\\..+" (system-name))))  
  
(setq default-mode-line-formatq  
  (list ""  
       'mode-line-modified  
       "<"  
       'mode-line-system-identification  
       "> "  
       "%14b"  
       " "  
       'default-directory  
       " "  
       "%[("  
       'mode-name  
       'minor-mode-alist  
       "%n"  
       'mode-lien-process  
       ")%]--"  
       "Line %1--"  
       '(-3 . "%P")  
       "-%-"))  
;;Start with new default.  
(setq mode-line-format default-mode-line-format)  
  
我设置默认的模式行格式以允许不同的模式(如 Info)正常覆盖它。这个列表的许  
多元素的意义都是不言自明的：mode-line-modified 变量告诉缓冲区是否已被修  
改，mode-name 变量告诉模式的名称，等等。  
  
其中的"%14b"显示当前缓冲区的名称(使用我们熟悉的 buffer-name 函数)，其中的  
"14"定义最大显示的字符数是 14。当一个缓冲区的名称的字符数低于 14 个字符  
时，就用空格添满。"%["和"%]"符号使得在每一个递归的编辑层次中使用一对方  
括号。"%n"则在变窄开启时显示"Narrow"。"%P"告诉你在窗口底部之上的部分占  
整个缓冲区的百分比，或者告诉你在"TOP"(顶端)、"Bottom"(底端)或"All"(全  
部)。(小写的"p"字符告诉你，在窗口顶部之上的部分所占的百分比)。"%-"则插  
入足够的破折号来填满一行。  
  
对于 Emacs 第 19 版及其后的版本，可以使用 frame-title-format 来设置一个 Emacs  
框架的标题。这个变量与 mode-line-format 变量有同样的结构。  
  
模式行的格式在《GNU Emacs Lisp 技术手册》中的“模式行格式”一节中有详细  
的描述。  
  
记住，“不要只为了喜欢 Emacs 而喜欢它”——你自己的 Emacs 可以与默认的 Emacs 拥  
有不同的颜色、不同的命令以及不同的绑定键。  

----------------------- Page 198-----------------------

  
另一方面，如果要进入一个没有任何定制的普通 Emacs 环境，键入：  
  
emacs -q  
  
就行了。这个命令将使 Emacs 不加载你个人的“~/.emacs”初始化文件。仅提供一  
个普通的默认的 Emacs，其他什么也没有。  
  
* 第 17 章 调试  
  
GNU Emacs 有两个调试器：debug 和 edebug。第一个调试器 debug 内置在 Emacs 之  
中，并且总是可以供你使用；第二个调试器 edebug 则是 Emacs 的一个扩充，这个调  
试器已经成为 Emacs 第 19 版的标准发行版本中的一个部分。  
  
两个调试器都在《GNU Emacs Lisp 技术手册》中的“调试 Lisp 程序”一节中有详  
尽的描述。在这一章，将分别结合一个简单的例子简要地介绍这两个调试器。  
  
 【在 Emacs 23.2 版中，调试器的内容已有变化，本章内容仅供参考。——Chiron 注】  
  
** 17.1 debug  
  
假设你已经编写了一个函数定义，这个函数将计算数字 1 到一个给定的数字之和，  
并返回这个结果。(这就是前面讲到的 triangle 函数。参见 11.1.4 节中“减量计数  
器的例子”小节的有关讨论。)  
  
然而，你的函数定义有一个 bug。你在输入“1-”的时候错误地输入了“1=”。下  
面是包含了这个错误的函数定义：  
  
(defun triangle-bugged (number)  
"Return sum of numbers 1 through NUMBER inclusive."  
(let ((total 0))  
  (while (> number 0)  
    (setq total (+ total number))  
    (setq number (1= number)))  ;Error here.  
total))  
  
如果你在 Info 中阅读这份文档，可以用通常的方法对这个函数定义求值。你将看  
到 triangle-bugged 出现在回显区中。  
  
现在用参量 4 传送给 triangle-bugged 函数，并对它求值：  
  
(triangle-bugged 4)  
  
你将得到下面的错误消息：  

----------------------- Page 199-----------------------

  
Symbol's function definition is void: 1=  
  
实际上，对于这样的一个简单的 bug，传递这个错误消息的目的是告诉你改正这个  
函数定义所应当知道的内容。然而，假设你对此不确定，那怎么办昵？  
  
你可以通过将 debug-on-error 的值设置成 t 来开始调试：  
  
(setq debug-on-error t)  
  
这个表达式使 Emacs 在它下一次遇到一个错误的时候进入调试器。  
  
通过将这个变量的值设置为 nil 就可以关闭它：  
  
(setq debug-on-error nil)  
  
将 debug-on-error 的值设置为 t，并对下面的表达式求值：  
  
(triangle-bugged 4)  
  
这一次，Emacs 将创建一个称为“*Backtrace*”缓冲区：  
  
     ---------- Buffer: *Backtrace* ----------  
     Signalling: (void-function 1=)  
        (1= number)  
        (setq number (1= number))  
        (while (> number 0) (setq total (+ total number))  
              (setq number (1= number)))  
        (let ((total 0)) (while (> number 0) (setq total ...)  
          (setq number ...)) total)  
       triangle-bugged(4)  
       eval((triangle-bugged 4))  
       eval-last-sexp-1(nil)  
       eval-last-sexp(nil)  
     * call-interactively(eval-last-sexp)  
     ---------- Buffer: *Backtrace* ----------  
  
(我已经将这个例子的格式稍微改动过，调试器不会将长的行折叠过来。)  
  
你可以从这个缓冲区的底部开始往上读，它将告诉你 Emacs 是如何一步一步地遇到  
错误。在这个例子中，Emacs 所做的就是交互地调用了 C-x C-e  
(eval-last-sexp)，这个命令导致对 triangle-bugged 表达式的求值。上面的每一  
行都告诉你后面 Lisp 解释器是如何求值的。  
  

----------------------- Page 200-----------------------

从缓冲区顶部开始的第三行是：  
  
(setq number (1= number))  
  
Emacs 试图对这个表达式求值。为了对这个表达式求值，它先对内部的表达式(1=  
number)求值，这个显示在从缓冲区顶部开始的第二行上。  
  
(1= number)  
  
这就是错误发生的地方，就像缓冲区最顶端的一行所示：  
  
Signalling: (void-function 1=)  
  
现在你能够改正这个错误，然后再对这个函数定义求值，并再一次运行你的测试  
表达式。  
  
如果你正在 Info 中阅读这部分，现在就可以通过将其值设置为 nil 来关闭  
debug-on-error 了：  
  
(setq debug-on-error nil)  
  
** 17.2 debug-on-entry  
  
第二种启动 debug 的方法，是当你调用一个函数的时候进入调试器。调用  
debug-on-entry 就能够实现这一点。  
  
键入：  
  
M-X debug-on-entry RET triangle-bugged RET  
  
现在，对下面的表达式求值：  
  
(triangle-bugged 5)  
  
Emacs 将创建名为“*Backtrace*”的缓冲区，并告诉你它将开始对  
triangle-bugged 函数求值：  
  
     ---------- Buffer: *Backtrace* ----------  
     Entering:  
     * triangle-bugged(5)  
       eval((triangle-bugged 5))  
       eval-last-sexp(nil)  
     * call-interactively(eval-last-sexp)  
     ---------- Buffer: *Backtrace* ----------  

----------------------- Page 201-----------------------

  
在“*Backtrace*”缓冲区中，键入 d。Emacs 将对 triangle-bugged 函数的第一个  
表达式求值，缓冲区内容将是：  
  
     ---------- Buffer: *Backtrace* ----------  
     Beginning evaluation of function call form:  
     * (let ((total 0)) (while (> number 0) (setq total ...)  
              (setq number ...)) total)  
       triangle-bugged(5)  
     * eval((triangle-bugged 5))  
       eval-last-sexp(nil)  
     * call-interactively(eval-last-sexp)  
     ---------- Buffer: *Backtrace* ----------  
  
现在，一次一次地慢慢键入 d，一共键入 8 次。每当你键入一次 d 键，Emacs 将对函  
数定义中的下一个表达式求值。最终，缓冲区内容将是：  
  
     ---------- Buffer: *Backtrace* ----------  
     Beginning evaluation of function call form:  
     * (setq number (1= number))  
     * (while (> number 0) (setq total (+ total number))  
              (setq number (1= number)))  
     * (let ((total 0)) (while (> number 0) (setq total ...)  
              (setq number ...)) total)  
       triangle-bugged(5)  
     * eval((triangle-bugged 5))  
       eval-last-sexp(nil)  
     * call-interactively(eval-last-sexp)  
     ---------- Buffer: *Backtrace* ----------  
  
最后，你再键入两次 d 之后，Emacs 将遇到错误，这时“*Backtrace*”缓冲区顶部  
的两行是：  
  
     ---------- Buffer: *Backtrace* ----------  
     Signnlling: (void-function 1=)  
     * (1= number)  
     ...  
     ---------- Buffer: *Backtrace* ----------  
  
总之，通过键入 d 键，你可以一步一步地测试函数的每一个表达式。  
  
通过键入 q 就可以退出“*Backtrace*”缓冲区，这个命令退出函数调试，但是并  
不取消 debug-on-entry。  
  

----------------------- Page 202-----------------------

要想取消 debug-on-entry，就要调用 cancel-debug-on-entry:  
  
M-x cancel-debug-on-entry RET triangle-debugged RET  
  
(如果你在 Info 中阅读这份文档，现在就可以取消 debug-on-entry。)  
  
** 17.3 debug-on-quit 和(debug)  
  
除了设置 debug-on-error 和调用 debug-on-entry 之外，还有另外两种方法可以启  
动 debug。  
  
通过将变量 debug-on-quit 设置为 t，可以使你无论何时键入 C-g  
(keyboard-quit)都能够启动 debug。这对于调试无限的循环很有用。  
  
或者，你能够在你的代码中需要调试的一行中插入“(debug)"，就像这样：  
  
      (defun triangle-bugged (number)  
       "Return sum of numbers 1 through NUMBER inclusive."  
        (let ((total 0))  
          (while (> number 0)  
            (setq total (+ total number))  
            (debug)                         ; Start debugger.  
            (setq number (1= number)))      ; Error here.  
         total))  
  
有关 debug 函数的详细描述，参见《GNU Emacs Lisp 技术手册》中的“Lisp 调试  
器”一节。  
  
** 17.4 源代码级调试器 edebug  
  
edebug 通常显示你所调试的函数的源代码。对于你当前执行的那一行，edebug 用  
一个箭头在左边进行提示。  
  
你可以一行一行地跟踪整个函数的执行，或者快速运行直到到达一个断点处(在这  
个断点处 Emacs 执行停止)。  
  
edebug 在《GNU Emacs Lisp 技术手册》中的 “edebug”一节中有详细介绍。  
  
这里是用于 triangle-recursive1y 的一个带有 bug 的函数定义。对于  
triangle-recursively 函数定义本身，可以参见 11.2.2 节“用递归算法代替计数  
器”。下面显示的这个例子没有对 defun 这一行进行通常的缩排。【非常奇怪，在  
我的 Emacs 23.2 版 Info 中，下面的代码的 defun 这一行进行了缩排，从而导致在  
Info 中无法使用 edebug-defun.——Chiron 注】  
  

----------------------- Page 203-----------------------

(defun triangle-recursively-bugged (number)  
  "Return sum of numbers 1 through NUMBER inclusive.  
Uses recursion."  
   (if (= number 1)  
      1  
     (+ number  
        (triangle-recursively-bugged  
         (1= number)))))               ; Error here.  
  
通常，将光标置于函数定义的最后一个括号之后并键入 C-x C-e  
(eval-last-sexp)，或者将光标置于函数定义之中并键入 C-M-x (eval-defun)，  
你都能够安装这个函数。(默认情况下，eval-defun 命令仅仅工作在 Emacs Lisp 模式  
或者 Lisp 交互模式中。)  
  
然而，要为 edebug 准备这个函数定义，你必须首先要用另外的命令将这个函数定  
义配置好。在 Emacs 第 19 版中，将光标置于函数定义中并键入下面的命令就可以实  
现这个目的：  
  
M-x edebug-defun RET  
  
这个命令在没有加载 edebug 的情况下使 Emacs 自动地加载 edebug，然后正确地配置  
这个函数。(在加载 edebug 之后，你可以使用它的标准的绑定键，如 C-u C-M-x  
(eval-defun 以及一个前缀参量)，来调用 edebug-defun。)  
  
在 Emacs 第 18 版中，需要自己来加载 edebug。将适当的 load 命令增加到你的  
".emacs"初始化文件中就行了。  
  
如果你在 Info 中阅读这份文档，你能够配置上面显示的这个  
triangle-recursively-bugged 函数。对于函数定义行是缩进的那个函数定  
义，edebug-defun 无法正确定位其边界，因此这个例子没有按通常的缩排方式显  
示。  
  
配置完函数之后，将光标置于下面的表达式后并键入 C-x C-e(eval-last-sexp):  
  
(triangle-recursively-bugged 3)  
  
光标将回退到 triangle-recursively-bugged 函数源代码中，而且光标位于这个函  
数的 if 表达式那一行的开始。同样，你将看到，一个箭头在这一行的左边，就像  
这样：“=>”。这个箭头表示这一行是函数当前运行的那一行。  
  
     =>* (if ( = number 1)  
  
在这个例子中，位点的位置是用一个星号“*”显示(在 Info 中，位点则是以  
 “-!-”显示)。  

----------------------- Page 204-----------------------

  
如果你现在键入空格键(SPC)，位点将移动到下一个执行的表达式，显示是这样的：  
  
 => (if *( = number 1)  
  
当你继续按下空格键的时候，位点将从一个表达式移动到下一个表达式。同时，  
每当表达式返回一个值时，这个值将显示在回显区中。例如，当你将位点移过  
number 之后，你将看到下面的内容：  
  
Result: 3 = C-c  
  
这意味着 number 变量的值是 3，它对应着 ASCll 码的 C-c (CTL-c)。  
  
你可以继续移过代码直到你到达有错误的那一行。在求值之前，这一行是：  
  
=>  *(1= number))))) ;Error here.  
  
当你按下空格键时，你将产生这样一个错误消息：  
  
Symbol's function definition is void:1=  
  
这是程序的一个 bug。  
  
按"q"，键就可以退出 edebug。  
  
要去除一个函数定义的 edebug，只要对它重新求值而不安装即可。例如，你可以  
将光标置于函数定义的最后一个括号之后并键入 C-x C-e 即可。  
  
edebug 完成的工作比仅仅遍历整个函数代码多得多。你可以将它设置成自行运  
行，直到到达有错误的那一行或者在指定的断点才停下来，你可以使它显示表达  
式值的改变；你可以找出一个函数被调用了多少次，等等。  
  
edebug 在《GNU Emacs Lisp 技术手册》中的“edebug”中有详细介绍。  
  
** 17.5 调试练习  
  
- 安装 count-words-region 函数，然后使之在你调用它的时候进入一个内置的调  
  试器。在一个包含两个单词的区域运行这个命令。你将需要按下 d 键很多次。在  
  你的系统中，在这个命令执行完之后，是否有一个"hook"调用？(关于 hook 的更  
  多信息，参见《GNU Emacs Lisp 技术手册》中“命令循环概述”一节。)  
  
- 将 count-words-region 函数拷贝到草稿缓冲区，如果需要，将 defun 一行前面的  
  空格去掉，为 edebug 配置好这个函数，并跟踪它的执行。无需为这个函数制造  
  一个 bug,虽然你完全可以做到这一点。如果一个函数没有 bug，遍历整个函数也  

----------------------- Page 205-----------------------

  是没有任何问题的。  
  
- 在运行 edebug 的时候，键入"?"，看一看 edebug 的命令列表。  
   (global-edebug-prefix 通常绑定到 C-x X，也就是 CTL-x 后接一个大写的 X，使  
  用这个命令前缀可以暂时离开 edebug 的调试缓冲区。)  
  
- 在 edebug 的调试缓冲区中，用 p(edebug-bounce-point)命令看一看  
  count-words-region 函数在区域中的什么位置执行。  
  
- 将位点移动到函数之后，然后键入 h (edebug-goto-here)命令，以使之跳到这  
  个位置。  
  
- 使用 t(edebug-trace-mode)命令以使 edebug 自行跟踪这个函数的执行；使用大  
  写的 T 用于 edebug-Trace-fast-mode，试一试，看结果会是什么？  
  
- 设置一个断点，然后在跟踪模式中运行 edebug 直到它到达停止点。  
  
* 第 18 章 结论  
  
现在到了这本入门教程的末尾了。你已经学习了足够的关于用 Emacs Lisp 中编程  
的知识，如给变量赋值、编写简单的“.emacs”文件，编写简单的功能扩充程序  
等。  
  
现在是该告一段落的时候了。如果你愿意，你现在可以直接独自朝前走了——自学  
吧！  
  
你已经学习了编程的一些基本知识。但是这仅仅是一部分而已。还有大量的易于  
使用的工具我们还没有接触到。  
  
学习更多知识的一个途径，是阅读 GNU Emacs 源代码以及《GNU Emacs Lisp 技术  
手册》中提到的代码。  
  
阅读 Emacs Lisp 源代码是一次冒险。当你阅读这些源代码并遇到一个不熟悉的函  
数或者表达式时，你需要弄清它的功能是什么。  
  
去看看那本《GNU Emacs Lisp 技术手册》吧。它对 Emacs Lisp 作了完全的、且易  
于阅读的描述。它不仅是为专家编写的，同时也是为像你这样的读者编写的(这本  
技术手册随着 GNU Emacs 的标准发行版本发行，并且是一个 Texinfo 源文件，因此  
你能够在线阅读它，或者打印出来阅读)。  
  
GNU Emacs 的另外一个在线帮助系统是所有函数的在线帮助文档以及帮助你阅读这  
些源代码的命令——find-tags。  
  
下面是我阅读源代码的一个例子。很久以前，我总是根据文件的名字首先查看  

----------------------- Page 206-----------------------

"simple.el"文件。当我阅读这个文件中的函数定义时，碰巧在这个文件中有一些  
函数很复杂，或者至少初看起来很复杂。例如，第一个函数看起来就很复杂。这  
个函数是 open-line 函数。  
  
你可以慢慢地阅读这个函数，就像我们处理 forward-sentence 函数那样(参见  
12.3 节)。或者你希望跳过这个函数阅读下一个函数，比如 split-line。其实，你  
无需阅读所有这些函数。根据 count-words-in-defun 函数，split-line 函数包含  
27 个单词和符号。  
  
虽然这个函数很短，但是它包含四个我们没有学到的函数：skip-chars-forward、  
indent-to、insert 和"?\n"。  
  
先来考虑 insert 函数(这个函数曾经出现在第 12 章的回顾部分)。在 Emacs 中，你能  
够通过键入 C-h f(describe-function)以及这个函数名，来找到关于这个函数的  
更多信息——打印出函数文档。你也可以用 find-tag 来阅读函数定义的源代码，这  
个命令绑定到 M-.(在这个例子中，这个命令并不很有用，因为这是一个用 C 语言编  
写的基本函数)。最后，你还可以找到技术手册中关于这个函数的说明。你可以在  
Info 中键入 i (Info-index)以及函数名来访问技术手册中关于这个函数的内容，  
或者在一份打印的手册中根据索引来查阅 insert 这个函数。  
  
类似地，你可以找到"?\n"的含义。你可以尝试用 Info-index 来查找相关信息。对  
于这个函数这样做毫无帮助，但是不要放弃。如果在索引中仅仅查询"\n"而不查  
找"?"，你将直接到达手册中的相关章节(参见《GNU Emacs 技术手册》中的“字  
符类型”一节。"?\n"代表换行符)。  
  
你可能已经猜测到 skip-chars-forward 和 indent-to 函数的功能了，否则你可以仔  
细看一看。(顺便提一下，describe-function 函数本身在“help.el”文件中，它  
是那些较长但是好理解的函数中的一种。它的函数定义说明了如何不用标准的控  
制字符来定制 interactive 表达式，并且显示了如何建立一个临时缓冲区。)  
  
其他有趣的源代码包含在“paragraphs.el”、“loaddefs.el”以及  
 “loadup.el”文件中。其中“paragraphs.el”文件中包含了短的、易于理解的  
函数，也有个别长的。“loaddefs.el”文件中包含许多标准的自动加载函数以及  
许多键图。我从来没有全部阅读完这个文件中的所有函数，仅仅阅读了一部分。  
 “loadup.el”文件加载 Emacs 的标准部分，它告诉你如何构建 Emacs 的许多知识  
(详细情况参见《GNU Emacs 技术手册》)。  
  
就像我所说的，你已经学习了一些简单的、但是却是非常重要的知识。我们几乎  
没有触及编程的主要部分，除了使用预先定义的 sort 函数之外，我没有说过任何  
关于信息分类的事情。我没有提到如何编写用来“编写程序”的程序。这是其他  
层次较深的书的主题。那是另外一种学习进阶。  
  
阅读完本书，你所做的是学习了足够的使用 Emacs 的实际知识，你已经入门了。这  
本入门教程到此结束。  

----------------------- Page 207-----------------------

* 附录 A the-the 函数  
  
有时候，当用 Emacs 写文章的时候，要重复单词——就像在这个句子开头的“you  
you”一样[fn:7]。最经常重复"the"这个单词，因此将用于查找重复单词的函数  
称为"the-the"函数。  
  
第一步，可以使用下面的正则表达式来查找重复的单词：  
  
\\(\\w+[ \t\n]+\\)\\1  
  
这个正则表达式，与后接一个或多个空格、制表符以及换行符的单个或多个构词  
要素字符相匹配。然而，它不能查到在不同行上面的重复单词，因为第一个单词  
的末尾是一行的结束，而第二个单词的末尾是一个空格，这是不同的。(关于正则  
表达式的更加详细的信息，请参见本书第 12 章“正则表达式查询”, 《GNU Emacs  
技术手册》中“正则表达式的句法”一节，以及《GNU Emacs Lisp 技术手册》中  
 “正则表达式”一节。)  
  
你可能会想仅仅通过查找重复的构词要素字符来寻找重复的单词，但是这行不  
通，因为这可能匹配任意两个重复的并非单词的构词字符串——如在"with the"中  
两次出现了"th"。  
  
另外一个可能的正则表达式，是查找后面跟着非构词字符的重复的构词字符。这  
里， "\\w+"与一个或者多个构词字符匹配，而"\\W*"则与零个或者多个非构词字  
符匹配。  
  
\\(\\(\\w+\\)\\W*\\)\\1  
  
同样，这个正则表达式也不符合我们的要求。  
  
下面介绍一个我使用的正则表达式。这个正则表达式虽然并不完美，但是已经完  
全够用。其中，  “\\b”与空字符串匹配，因为空字符串在一个单词的开始或者  
末尾出现。“[^@ \n\t］+”则与一次或者多次出现的除了@符号、空格、换行符和  
制表符之外的其他字符匹配。  
  
     \\b\\([^@ \n\t]+\\)[ \n\t]+\\1\\b  
  
也可以写出更加复杂的正则表达式，但是我发现这个正则表达式已经完全够用，  
因此我就使用它。  
  
下面就是 the-the 函数，我将它放在我的“.emacs”文件中，并与一个方便的全局  
键绑定在一起：  
  
      (defun the-the ()  

----------------------- Page 208-----------------------

       "Search forward for for a duplicated word."  
        (interactive)  
        (message "Searching for for duplicated words ...")  
        (push-mark)  
        ;; This regexp is not perfect  
        ;; but is fairly good over all:  
        (if (re-search-forward  
            "\\b\\([^@ \n\t]+\\)[ \n\t]+\\1\\b" nil 'move)  
            (message "Found duplicated word.")  
          (message "End of buffer")))  
  
      ;; Bind `the-the' to  C-c \  
      (global-set-key "\C-c\\" 'the-the)  
  
下面是一个测试文本：  
  
  
     one two two three four five  
     five six seven  
  
可以用其他的正则表达式替代上面这个函数中使用的正则表达式，看一看用它们  
来处理这个测试文本时有什么不同。  
  
 【在 org-mode 里 C-c \ 已被绑定到其他命令，请使用 M-x the-the 方式调用，或  
者暂时切换到其他模式中。实际上，在本文档中连续使用这个命令查找几次就会  
发现这个正则表达式也匹配形如：  
  
    t" "a  
  
这样的字符串中的" "。我使用"\\b\\(\\w+\\)[ \n\t]+\\1\\b"这种写  
法。——Chiron 注】  
  
* 附录 B kill 环的处理  
  
kill 环是一个列表，这个列表可以通过使用 rotate-yank-pointer 函数被转化为一  
个环。yank 和 yank-pop 命令使用了 rotate-yank-pointer 函数。本附录描述了  
rotate-yank-pointer 函数，同时也介绍了 yank 和 yank-pop 命令。  
  
** B.1 rotate-yank-pointer 函数  
  
rotate-yank-pointer 函数的作用，就是在 kill 环中改变  
kill-ring-yank-pointer 变量所指的元素。例如，它能够将原本指向环中第二个  
元素的 kill-ring-yank-pointer 改为指向环中第三个元素。  
  

----------------------- Page 209-----------------------

下面是 rotate-yank-pointer 函数的代码：  
  
(defun rotate-yank-pointer (arg)  
  "Rotate the yanking point in the kill ring."  
   (interactive "p")  
   (let ((length (length kill-ring)))  
      
     (if (zerop length)  
  
       ;;then-part  
     (error "Kill ring is empty")  
       ;;else-part  
       (setq kill-ring-yank-pointer  
         (nthcdr (% (+ arg  
                (- length  
                   (length  
                   kill-ring-yank-pointer)))  
               length)  
            kill-ring)))))  
  
这个函数看起来很复杂，但是就像平常一样，这个函数是可以被一层一层地拆开  
而进行分析理解的。首先，来看一看总体结构：  
  
(defun rotate-yank-pointer (arg)  
  "Rotate the yanking point in the kill ring."  
   (interactive "p")  
   (let varlist  
    body...)  
  
这个函数接收一个参量，即 arg。这个函数同时有一个简短的文档说明字符串，而  
且它是交互的，其中的“p”意味着函数的参量必须是一个前缀参量，这个参量值  
是一个数。  
  
函数体是一个 let 表达式。这个 let 表达式本身有一个变量列表和表达式主体。  
  
let 表达式声明了一个变量，这是在这个函数内能够使用的唯一一个变量。这就是  
length 变量。这个变量的值等于 kill 环中元素的个数。给这个变量赋值的是  
length 函数。(注意，这个函数与变量 length 有相同的名字，但是一个是函数名，  
一个是变量名，两者是截然不同的。这就像一个说英语的人，可以区分下面两个  
句子中“ship”一词的不同意思一样： "I must ship this package  
immediately."和"I must get aboard the ship immediately."。)  
  
length 函数给出一个列表中元素的个数，因此(length kill-ring)表达式返回  
kill 环中元素的个数。  

----------------------- Page 210-----------------------

  
rotate-yank-pointer 函数体  
  
rotate-yank-pointer 函数体是一个 let 表达式，而 let 表达式的主体是一个 if 表达  
式。  
  
这个 if 表达式的作用，是判断 kill 环中是否有内容(元素)。如果 kill 环是一个空  
列表，则 error 函数使整个函数停止求值并在回显区输出一条消息。另一方面，如  
果 kill 环中有内容(不是一个空列表)，函数就执行它的任务。  
  
下面是 if 表达式的 if 部和 then 部：  
  
(if (zerop length)               ;if-part  
     (error "Kill ring is empty") ;then-part  
  
如果 kill 环中没有元素，是一个空列表，它的长度值 length 必定是零，这样就会  
在回显区中输出一条消息："Kill ring is empty"。这个 if 表达式中使用了  
zerop 函数，当它测试的参量的值为零时，这个函数返回“真”。当这个 zerop 函  
数返回“真”时，if 表达式的 then 部被执行。这个 if 表达式的 then 部是一个以  
error 函数开始的列表。其中的 error 函数与 message 函数类似，它也在回显区输出  
一行消息。然而，除了输出一行消息之外，error 函数还使调用它的整个函数停止  
执行。在这个例子中，这就意味着，如果 kill 环长度为零的话，这个函数的其余  
部分就不再被求值了。  
  
(就我的观点来看，用 error 作为函数名是有点误导性的，至少对人而言是如此。  
一个更好的名字可能是"cancel"。当然，你无法指向一个空列表，更不用说使  
一个指针在一个空列表上来回移动。从计算机的角度严格地说，"error"一词又是  
正确的。但是，如果仅仅是找出 kill 环是否为空的话，人还是希望尝试这种事情。  
这是一次探索)。  
  
(即使是在计算机世界里，从人的角度来说，这次探索也并不是一种错误，因此不  
应当用"error"一词来表示。Emacs 中的代码暗示着，在探索中追求完美的人正在  
制造错误。这是不好的。即使计算机在完成同样的事情时，如果出现了一个  
"error"，像"cancel"这样的词也更能体现当时的情况。)  
  
1. if 表达式的 else 部  
  
这个 if 表达式的 else 部，当 kill 环不是一个空列表时，完成  
kill-ring-yank-pointer 的赋值工作。这部分代码是：  
  
(setq kill-ring-yank-pointer  
      (nthcdr (% (+ arg  
                 (- length  
                    (length kill-ring-yank-pointer)))  

----------------------- Page 211-----------------------

               length)  
               kill-ring)))))  
  
这部分需要解释一下。很明显，在这里，用前面介绍的 nthcdr 函数将  
kill-ring-yank-pointer 设置成等于 kill 环的 n 次 CDR 一个值。(参见  
8.5 节，"copy-region-as-kill"。)但是这究竟是如何实现的呢？  
  
在分析这部分代码的细节之前，让我们首先考虑一下 rotate-yank-pointer 函数的  
作用。  
  
rotate-yank-pointer 函数改变 kill-ring-yank-pointer 的指向。如果  
kill-ring-yank-pointer 开始时指向列表的第一个元素，调用一次  
rotate-yank-pointer 函数就使它指向第二个元素。如果  
kill-ring-yank-pointer 指向的是第二个元素，调用 rotate-yank-pointer 函数一  
次就使它指向第三个元素(而且，如果 rotate-yank-pointer 被给予一个大于 1 的参  
量，它就使指针一次跳过多个元素)。  
  
rotate-yank-pointer 函数使用 setq 函数来重置 kill-ring-yank-pointer 指向的位  
置。如果 kill-ring-yank-pointer 指向 kill 环的第一个元素，那么在最简单的情  
况下，rotate-yank-pointer 函数必定使它指向第二个元素。换一种方式来  
说，kill-ring-yank-pointer 必须重置为等于 kill 环的 CDR 的一个值。  
  
即，在这些情况下，  
  
(setq kill-ring-yank-pointer  
    '("some text" "a different piece of text" "yet more text"))  
  
(setq kill-ring  
    '("some text" "a different piece of text" "yet more text"))  
  
下面的代码将完成同样的事情：  
  
(setq kill-ring-yank-pointer (cdr kill-ring))  
  
结果，kill-ring-yank-pointer 将是这个样子：  
  
kill-ring-yank-pointer  
  => ("a different piece of text" "yet more text")  
  
在讨论的这个函数中，实际的 setq 表达式使用 nthcdr 函数来完成这件事情。  
  
就像前面已经看到的(参见 7.3 节"nthcdr"),nthcdr 函数反复地取一个列表的 CDR  
——即一个列表的 CDR 的 CDR 的 CDR……。  
  

----------------------- Page 212-----------------------

下面两个表达式产生同样的结果：  
  
(setq kill-ring-yank-pointer (cdr kill-ring))  
  
(setq kill-ring-yank-pointer (nthcdr 1 kill-ring))  
  
然而，在 rotate-yank-pointer 函数中，nthcdr 函数的第一个参量是一个看起来相  
当复杂的表达式，这个表达式中有不少数学内容：  
  
(% (+ arg  
    (- length  
        (length kill-ring-yank-pointer)))  
  length)  
  
如常所示，需要首先分析其中最内层的表达式，然后以常用的方式分析外层的表  
达式。  
  
最内层的表达式是(length kill-ring-yank-pointer)。这个表达式计算  
kill-ring-yank-pointer 的当前长度(记住，kill-ring-yank-pointer 是一个变量  
的名字，这个变量的值是一个列表)。  
  
对长度的测量是在下面这个表达式中完成的：  
  
(- length (length kill-ring-yank-pointer))  
  
在这个表达式中，第一个 length 是一个变量，这个变量是 kill 环的长度，它的值  
在这个函数的开始就用 let 语句设置好了。(如果这个变量名用  
length-of-kill-ring 来表示，就会更加清楚一些。但是，如果通篇阅读整个函  
数，而不要像现在这样将函数分成一小片一小片来分析，就会发现即使用这么短  
的一个变量名也是不会混淆的。)  
  
因此，(- length (length kill-ring-yank-pointer))给出 kill 环的长度与  
kill-ring-yank-pointer 指向的那个列表的长度之间的差值。  
  
要弄清它们是如何在 rotate-yank-pointer 中工作的，让我们从分析当  
kill-ring-yank-pointer 像 kill-ring 变量那样指向 kill 环的第一个元素时的情况  
开始，来看一看当 rotate-yank-pointer 用参量 1 调用时的情况。  
  
在这种情况下，变量 length 和表达式(length kill-ring-yank-pointer)的值将是  
相同的，因为变量 length 就是 kill 环的长度，而这时 kill-ring-yank-pointer 也  
指向整个 kill 环。因此，下面这个表达式的值将是零。  
  
(- length (length kill-ring-yank-pointer))  
  

----------------------- Page 213-----------------------

因为参量 arg 的值将是 1，这意味着下面这个表达式也为 1。  
  
(+ arg (- length (length kill-ring-yank-pointer)))  
  
最终，nthcdr 接收的参量就是下列表达式的值。  
  
(% 1 length)  
  
2. %余函数  
  
要理解表达式(% 1 length)，需要首先理解%函数。根据这个函数定义的文档说明  
(这可以通过键入 C-h f %得到),%函数返回它的第一个参量被第二个参量除之后的  
余数。例如，5 被 2 除之后的余数是 1。(5 中有两个 2，余数为 1。)  
  
对于不经常进行算术运算的人来说，理解一个小的数能被一个更大的数除并得到  
余数会很别扭。在刚才使用的例子中，是 5 被 2 除。可以将它反过来，并问 2 被 5 除  
会怎样？如果会使用分数的话，答案是 2/5 或者 0.4。但是如果你只会使用整数，  
结果就会两样了。很明显，5 不是 2 的任何整数倍，但是余数是什么？要回答这个  
问题，看一看小时候熟悉的例子：  
  
5 被 5 除得 1，余数是 0;  
  
6 被 5 除得 1，余数是 1;  
  
7 被 5 除得 1，余数是 2。  
  
类似地，10 被 5 除得 2，余数是 0;  
  
11 被 5 除得 2，余数是 1;  
  
12 被 5 除得 2，余数是 2。  
  
这样考虑的话，就会得到：  
  
O 被 5 除得 0，余数是 0;  
  
1 被 5 除得 O，余数是 1;  
  
2 被 5 除得 0，余数是 2;  
  
等等。  
  
因此，在这个函数定义中，如果 length 的值是 5，则表达式就相当于  
  

----------------------- Page 214-----------------------

(% 1 5)  
  
其值是 1(将光标置于表达式之后并键入 C-x C-e 就得到这个结果。确实，1 打印在  
回显区中)。  
  
3． 在 rotate-yank-pointer 中使用%  
  
当 kill-ring-yank-pointer 指向 kill 环的开始时，传递给 rotate-yank-pointer  
的参量值是 1，则%表达式返回 1:  
  
(- length (length kill-ring-yank-pointer))  
  => 0  
  
因此，  
  
(+ arg (- length (length kill-ring-yank-pointer)))  
  =>1  
  
从而，不管 length 的值是多少，下面的表达式总是返回 1。  
  
(% (+ arg (- length (length kill-ring-yank-pointer)))  
   length)  
   =>1  
  
根据这个表达式的结果，setq kill-ring-yank-pointer 表达式简化为：  
  
(setq kill-ring-yank-pointer (nthcdr 1 kill-ring))  
  
现在这个表达式就容易理解了。最初指向 kill 环第一个元素的  
kill-ring-yank-pointer 变量现在则指向了第二个元素。  
  
很明显，如果传递给 rotate-yank-pointer 的参量值为 2，那么  
kill-ring-yank-pointer 被设置为(nthcdr 2 kill-ring)；对于不同的参量值，  
都有不同的指向。  
  
类似地，如果 kill-ring-yank-pointer 是从第二个元素开始的，那么它的长度比  
kill 环的长度短 1，因此计算得到的余数就基于表达式(% (+ arg 1) length)。这  
意昧着，如果传递给 rotate-yank-pointer 的参量值是 1，则  
kill-ring-yank-pointer 就从 kill 环的第二个元素移动到第三个元素。  
  
4． 指向最后一个元素  
  
最后一个问题是，如果 kill-ring-yank-pointer 指向最后一个元素，会发生什么  
事情？这时调用 rotate-yank-pointer 函数是否意味着不能从 kill 环中得到任何东  

----------------------- Page 215-----------------------

西呢？答案是否定的。这时发生的事情很复杂，并且也很有  
用——kill-ring-yank-pointer 指向了 kill 环的第 1 个元素。  
  
让我们看一看这是怎么一回事。假设，kill 环的长度是 5，传递给  
rotate-yank-pointer 的参量值是 1。当 kill-ring-yank-pointer 指向 kill 环的最  
后一个元素的时候，它的长度是 1。代码就变成：  
  
(% (+ arg (- length (length  kill-ring-yank-pointer))) length)  
  
当用各个变量的值来取代这些变量之后，上面这个表达式就是：  
  
(% (+ 1 (- 5 1)) 5)  
  
这个表达式从最内层的表达式开始，一步一步向外求值后得到：(- 5 1)的值是  
4;(+ 1 4)的值是 5；5 被 5 除的余数是 0。因此 rotate-yank-pointer 将要完成的就  
是：  
  
(setq kill-ring-yank-pointer (nthcdr 0 kill-ring))  
  
这个表达式将使 kill-ring-yank-pointer 指向 kill 环的开始。  
  
因此，连续调用 rotate-yank-pointer 函数的结果就是将 kill-ring-yank-pointer  
从指向 kill 环中的第一个元素开始，一步一步地移动，直到指向最后一个元素；  
然后再跳回到第一个元素。这也就是为什么 kill 环被称为环的原因，即通过跳回  
到第一个元素，就好像这个列表没有终点一样！(环就是没有终点的)。  
  
** B.2 yank 函数  
  
在学习了 rotate-yank-pointer 函数之后，再学习 yank 函数代码就相当容易了。这  
个函数中只有一处有些小技巧，就是计算传递给 rotate-yank-pointer 函数的参量  
值。  
  
这部分代码是：  
  
      (defun yank (&optional arg)  
       "Reinsert the last stretch of killed text.  
     More precisely, reinsert the stretch of killed text most recently  
     killed OR yanked.   
     With just C-u as argument, same but put point in front  
      (and mark at end).  With argument N, reinsert the Nth most  
     recently killed stretch of killed text.  
     See also the command \\[yank-pop]."  
      (interactive "*P")  
      (rotate-yank-pointer (if (listp arg) 0  

----------------------- Page 216-----------------------

                              (if (eq arg '-) -1  
                                (1- arg))))  
      (push-mark (point))  
      (insert (car kill-ring-yank-pointer))  
      (if (consp arg)  
          (exchange-point-and-mark)))  
  
稍微看一眼这个函数定义的代码，就能够轻易地理解最后几行。这几行的功能  
是：记录标记的位置；然后 kill-ring-yank-pointer 指向的第一个元素(CAR)被插  
入到缓冲区；再之后，如果传递给函数的参量是 cons 原胞，就交换位点和标记的值以  
使位点置于插入文本的开始处而不是末尾。这个可选参量在说明文档中有所解释。  
另外，函数本身是被交互调用的，使用了“*P”参量。这意味着它不能在一个只  
读缓冲区中使用，而且传递给函数的参量是一个未经处理的前缀参量。  
  
1．传递参量  
  
yank 函数中最困难的部分是理解关于传递给它的参量的有关计算。幸运的是，它  
并不是初看起来的那么困难。  
  
这部分代码是两个 if 表达式，对这两个(或者其中的一个)if 表达式求值的结果，  
将产生一个数，并且这个数将成为传递给 rotate-yank-pointer 的参量。  
  
加上注释，函数代码是：  
  
(if (listp arg)       ;if-part  
    0                 ;then-part  
     (if (eq arg '-)   ;else-part,inner if  
        -1            ;inner if's then-part  
        (1- arg))))    ;inner if's else-part  
  
这部分代码由两个 if 表达式组成，其中一个 if 表达式是另外一个 if 表达式的 else  
部。  
  
第一个或者外层的 if 表达式，测试传递给 yank 函数的参量是否是一个列表。很奇  
特的是，如果不带参量调用 yank 函数，这个测试总将返回“真”——这是因为这时  
nil 将被作为可选参量传递给 yank 函数，而(listp nil)总是返回“真”(因为 nil  
是一个空列表)。因此，如果没有参量传递给 yank，那么传递给  
rotate-yank-pointer 的参量就是零。这意味着，就像我们希望的那样，这个指针  
不移动，而且 kill-ring-yank-pointer 当初指向的第一个元素被插入到缓冲区中。  
类似地，如果传递给 yank 的参量是 C-u，这将被读作一个列表，因此传递给  
rotate-yank-pointer 函数的参量同样也是零。(C-u 产生一个未经处理的前缀参量  
(4)，这是一个只有单个元素的列表)。同时，在函数的后面部分，这个参量将被  
读作一个 cons 原胞，因此位点将被置于插入文本的开始，标记将被置于插入文本  
的末尾。(interactive 中的 P 参量就是为这种情况设置的，即当没有提供可选参量  

----------------------- Page 217-----------------------

或可选参量是 C-u 时提供这些值。)  
  
外层 if 表达式的 then 部，处理没有可选参量或者可选参量是 C-u 的情况，而 else 部  
处理其他情况。外层 if 表达式的 else 部本身又是另外一个 if 表达式。  
  
内层的 if 表达式测试参量是否是一个负号。(这是通过同时按下 META 和-键或者同  
时按下 Esc 和-键得到的。)在这种情况下，就将-1 作为一个参量传递给  
rotate-yank-pointer 函数。这使 kill-ring-yank-pointer 朝后移动，这正是用户  
所期望的。  
  
如果内层 if 表达式的真假测试结果为“假”(也就是参量不是一个负号)，这个表  
达式的 else 部被求值。这就是表达式(1- arg)。由于这两个 if 表达式的存在，因  
此这种情况只能发生在参量是一个正数或者一个负数的时候(而不仅仅是一个负  
号)。表达式(1- arg)所做的就是对参量值减 1，并返回其结果。(1-函数的作用是  
从其参量中减去 1。)这意味着．如果传递给 rotate-yank-pointer 的参量是 1，它  
就被减至零，这就是说 kill-ring-yank-pointer 指向的第一个元素被插入缓冲  
区，正像用户所期望的那样。  
  
2．传递一个负参量  
  
最后，如果传递一个负的参量值给余函数%和 nthcdr 函数，会发生什么情况？它们  
还能正常运转吗？  
  
答案可以通过一个快速测试给出。当(% -1 5)被求值时，就返回一个负值，如果  
用一个负值调用 nthcdr 函数，它给出的结果就像是用一个零作为第一个参量来调  
用一样。这可以通过对下面的代码求值得到。  
  
这里“=>”表示前面代码求值后产生的结果。求值可以以通常方式进行，将光标  
置于代码之后并键入 C-x C-e (eval-last-sexp)。如果在 GNU Emacs 的 Info 中阅读  
这份文档，就可以直接这么做。  
  
(% -1 5)  
  =>-1  
  
(setq animals '(cats dogs elephants))  
    =>(cats dogs elephants)  
  
(nthcdr 1 animals)  
  =>(dogs elephants)  
  
(nthcdr 0 animals)  
  =>(cats dogs elephants)  
  
(nthcdr -1 animals)  

----------------------- Page 218-----------------------

  =>(cats dogs elephants)  
  
因此，如果一个负号或者一个负的数值被传递给 yank，kill-ring-yank-pointer  
就反向移动直到回到列表的开始。然后它停留在那里。当它从列表末尾移动回列  
表开始时，绕了一圈，它就停下来了，这与其他情况不同。这很有意义，因为你  
经常要重新粘贴最近剪切的那块文本，但是你通常不会想要粘贴 30 次前删除命令  
剪切的文本。因此你需要移动到 kill 环的末尾，但是如果要返回到列表的开始时  
就无需绕一圈了。  
  
顺便提一下，任何传递给 yank 的数之前如果有一个负号，它都将被当做-1 处理。  
这明显地简化了编写程序的工作。你无需朝后一步一步地跳回 kill 环的开始，这  
也比编写一个函数以确定要朝后移动多少元素简单得多。  
  
** B.3 yank-pop 函数  
  
理解 yank 函数之后，再学习 yank-pop 函数就容易了。为了节省篇幅，这里省略了  
函数文档，这个函数定义的代码如下：  
  
(defun yank-pop (arg)  
   (interactive "*p")  
   (if (not (eq last-command 'yank))  
       (error "Previous command was not a yank"))  
   (setq this-command 'yank)  
   (let ((before (< (point)(mark))))  
     (delete-region (point)(mark))  
     (rotate-yank-pointer arg)  
     (set-mark (point))  
     (insert (car kill-ring-yank-pointer))  
     (if before (exchange-point-and-mark))))  
  
这是一个交互函数，使用了“p”参量，因此前缀参量是经过处理才传递给这个函  
数的。这个命令仅能在前一个 yank 函数之后使用，否则就产生一个错误消息。这  
种检查使用了 last-command 函数(这个函数的介绍，参见 8.5 节  
 “copy-region-as-kill”。)  
  
其中，let 表达式根据位点在标记之前或者之后来设置变量 before 的值为“真”或  
者为“假”，然后删除介于位点和标记之间的区域。这个区域就是前一个 yank 命  
令插入的区域，并且这就是要被替代的文本。下一步，kill-ring-yank-pointer  
移动使前面插入过的文本不再被插入。标记被设置到新文本插入的区域的开始，  
而且 kill-ring-yank-pointer 指向的第一个元素被插入到这个区域。在前一次的  
yank 命令执行中，如果位点被置于插入文本之前，现在位点和标记就要交换位  
置，使位点再一次置于新插入的文本的开始。这个函数的所有工作就是如此。  
  
* 附录 C 带坐标轴的图  

----------------------- Page 219-----------------------

  
坐标轴有助于你理解图形的意义。它们表达比例尺的大小。在较早的一章中(参见  
第 15 章，  “准备柱型图”)，编写了打印图形的代码。这里，编写打印图形的水  
平和垂直坐标轴以及图形本身的代码。  
  
由于往缓冲区中插入信息是往右下方进行的，因此新的图形打印函数应该首先打  
印 Y 轴即垂直轴，然后打印图形本身，最后打印 X 轴即水平轴。下面的顺序定下了  
这个函数的主要内容：  
  
1) 建立代码。  
  
2) 打印 Y 轴。  
  
3) 打印图形。  
  
4) 打印 X 轴。  
  
下面是根据这个函数打印出来的一个完整的图形：  
  
         10 -  
                       *  
                       *  *  
                       *  **  
                       *  ***  
          5 -      *   *******  
                 * *** *******  
                 *************  
               ***************  
          1 - ****************  
               |   |    |    |  
              1   5   10   15  
  
在这个图形中，垂直轴和水平轴坐标都是用数字表示的。然而，在有些图形中，  
水平轴坐标是时间，并且用月份来表示更好，如下所示：  
  
          5 -      *  
                 * ** *  
                 *******  
               ********** **  
          1 - **************  
               |    ^      |  
              Jan  June   Jan  
  
确实，只要稍微思考一下，就能够容易地得到不同的垂直轴和水平轴坐标的表示  

----------------------- Page 220-----------------------

方式。我们的任务变得复杂了。但是复杂孕育着混乱。与其允许这种混乱情况的  
出现，不如首先选择简单的坐标表示方式，然后再修改或改进它。  
  
基于这些考虑，可以得出用于 print-graph 函数的下面框架：  
  
      (defun print-graph (numbers-list)  
       "DOCUMENTATION..."  
        (let ((height  ...  
             ...))  
          (print-Y-axis height ... )  
          (graph-body-print numbers-list)  
          (print-X-axis ... )))  
  
下面，将依次解决 print-graph 函数定义的各个部分。  
  
** C.1 prin-graph 函数的变量列表  
  
在编写 print-graph 函数时，第一个任务就是编写 let 表达式中使用的变量列表(在  
此将暂时不考虑如何使这个函数成为一个交互函数以及函数定义的说明文档)。  
  
变量列表应当设置几个值。很明显，垂直轴的最高点必须至少是图形的最大高  
度，这意味着必须得到图形的最大高度这个信息。注意，在 print-graph-body 函  
数中也需要这个信息。因为没有必要在两个不同的地方两次计算图形高度值，因  
此应当改变前面已经定义的 print-graph-body 函数，直接利用这里计算出来的图  
形高度值。  
  
类似地，打印 X 轴的函数和 print-graph-body 函数都需要得到符号的宽度值。可以  
在这里统一进行这种计算，并改变前面章节中定义的 print-graph-body 函数使之  
直接利用这里得到的值。  
  
水平坐标轴的长度必须至少与图形一样长。然而，这个信息只有打印水平坐标轴  
的函数使用，因此无需在变量列表中计算。  
  
基于这些考虑，就可以直接写出 print-graph 函数的 let 表达式中的变量列表：  
  
      (let ((height (apply 'max numbers-list)) ; First version.  
            (symbol-width (length graph-blank)))  
  
就像下面我们将看到的一样，这个表达式是不够的。  
  
** C.2 print-Y-axis 函数  
  
print-Y-axis 函数的任务是为垂直坐标轴打印坐标，如下所示：  
  

----------------------- Page 221-----------------------

         10 -  
  
  
  
  
          5 -  
  
  
  
          1 -  
  
这个函数应当接收图形高度值作为参量，然后应构造并插入适当的数字和标记。  
  
在图中很容易看出，Y 轴坐标应当是什么样的。但是具体说出来并为此编写一个函  
数定义，就不那么简单了。如果说需要一个数和每隔 5 行需要一个短线来表示垂直  
坐标轴，也不很正确：在“1”和“5”之间只有 3 行(第 2、3 和 4 行)，但是在“5”  
和“10”之间有 4 行(第 6、7、8 和 9 行)。更好的说法是需要一个数和一条短线来表  
示基线(数 1)，然后在第 5 行和行数为 5 的整数倍的行用一个数和一条短线来表示坐  
标。  
  
下一个问题，是确定垂直坐标轴应当有多高。假设图形中最高一列的最大高度是  
7，那么 Y 轴上的最大坐标应当是“5-”并且图形应当凸显在坐标上方吗？或者 Y 轴  
上的最大坐标应当是“7-”并且表示图形的顶端吗？或者最大坐标应当是  
 “10-”(这是 5 的整数倍，而又刚好超过图形的最大高度)吗？  
  
后一种选择更好。大多数图形是在长方形的区域中打印出来的。长方形的边是以  
5 为步进距离的，如 5、10、15 等等。但是，一旦决定为垂直坐标轴使用一个步进  
距离，就会发现在变量列表中计算高度的简单表达式是错误的。这个表达式就是  
(apply 'max numbers-list)。这个表达式返回精确的高度值，而不是最大值加上  
与最接近 5 的整数倍的差值。因此，就需要一个更为复杂的表达式。  
  
就像在别的例子中一样，如果将复杂的问题分解成几个小问题，这个问题就变得  
简单了。  
  
首先，考虑当图形的最大高度值正好是 5 的整数倍的情况——即当最大高度值正好是  
5、10、15 等时的情况。在这种情况下，就可以直接使用它作为 Y 轴的高度值。  
  
确定某个数是否为 5 的整数倍的一个相当简单的方法，是将它除以 5，并检查它是  
否有余数。如果没有余数，则这个数就是 5 的整数倍。因而，7 除以 5 余 2，因此 7 不  
是 5 的整数倍。用另外稍微不同的语言来说(这使人回想起小学课堂来),7 中有一个  
5，余下 2。然而，10 中有两个 5，没有余数：10 是 5 的整数倍。  
  
*** C.2.1 题外话：计算余数  
  

----------------------- Page 222-----------------------

在 Lisp 中，计算余数的函数是%。这个函数返回它的第一个参量被其第二个参量除  
之后的余数。在 Emacs Lisp 中，无法用 apropos 来找到%函数：如果键入 M-x  
apropos RET remainder RET，不会得到任何相关的函数。了解%这个函数存在的  
唯一方法是阅读一本关于它的图书，比如这份文档，或者阅读 Emacs Lisp 源代码。  
%函数曾经被用于在附录 B 中描述的 rotate-yank-pointer 函数代码中。  
  
通过对下面两个表达式求值，就能够体验一下%函数：  
  
(% 7 5)  
  
(% 10 5)  
  
第一个表达式返回 2，而第二个表达式返回零。  
  
要测试返回值是否为零或者是别的什么值，可以使用 zerop 函数。如果这个函数的  
参量(这个参量必须是一个数)的值是零，则这个函数返回 t。  
  
(zerop (% 7 5))  
    => nil  
  
(zerop (% 10 5))  
    =>t  
  
因此，如果图形的高度正好被 5 整除，下面的表达式将返回 t。  
  
(zerop (% height 5))  
  
(当然，height 变量的值可以从(apply 'max numbers-list)表达式得到。)  
  
另一个方面，如果 height 变量的值不是 5 的整数倍，需要将其重置为比这个值稍大  
的 5 的整数倍的值。使用一些已经很熟悉的函数就可以直接得到它。首先将  
height 变量的值除以 5 以确定其中有多少个 5。例如，12 中有两个 5。如果将这个商  
加 1，再乘以 5，就将得到最临近的比高度值大而又是 5 的整数倍的数值。12 中有两  
个 5，加 1 后等于 3，3 乘以 5 等于 15，这是比 12 大的 5 的整数倍的数。因此 Lisp 表达式  
就是：  
  
(* (1+ (/ height 5)) 5)  
  
例如，如果对下面的表达式求值，其结果就是 15:  
  
(* (1+ (/ 12 5)) 5)  
  
在所有这些讨论中，都是使用“5”作为 Y 坐标轴坐标间距的，但是也可以使用其  
他的值。为了使程序更通用，应当用一个变量来取代上面的“5”。我所能想到的  

----------------------- Page 223-----------------------

关于这个变量的最好的名字，大概就是 Y-axis-label-spacing 了。使用这个变量  
和 if 表达式，就得到下面的代码：  
  
(if (zerop (% height Y-axis-label-spacing))  
    height  
     ;;else  
     (* (1+ (/ height Y-axis-label-spacing))  
         Y-axis-label-spacing))  
  
如果图形的高度正好是 Y-axis-label-spacing 变量的值的整数倍，这个表达式返  
回 height 变量本身的值，否则就返回稍高于图形高度又是变量  
Y-axis-label-spacing 整数倍的数值。  
  
现在可以将这个表达式放进 print-graph 函数的 let 表达式中(当然首先要设置  
Y-axis-label-spacing 变量的值)。  
  
      (defvar Y-axis-label-spacing 5  
       "Number of lines from one Y axis label to next.")  
  
     ...  
      (let* ((height (apply 'max numbers-list))  
             (height-of-top-line  
              (if (zerop (% height Y-axis-label-spacing))  
                 height  
                ;; else  
                (* (1+ (/ height Y-axis-label-spacing))  
                  Y-axis-label-spacing)))  
             (symbol-width (length graph-blank))))  
     ...  
  
  
(注意 let*函数的使用：图形高度的初始值首先由(apply 'max numbes-list)表达  
式计算出来，然后用 height 变量的结果值计算图形高度的最终值。)  
  
*** C.2.2 构造一个 Y 轴元素  
  
当打印垂直坐标轴时，想要每 5 行插入像“5-”和“10-”这样的字符串。而且，  
要求数字和破折号分别对齐，因此短的数字(只有一位的数字)前面要加上空格。  
例如，如果有些字符串中使用了两位的数字，那么只有一位数字的串必须在数字  
前面加入一个空格。  
  
为了求出数的长度，要使用 length 函数。但是这个函数只能工作在一个字符串  
上，不能对一个数字进行操作。因此必须将这个数字转换成一个字符串。这种转  
换是由 int-to-string 函数实现的。例如，  

----------------------- Page 224-----------------------

  
(length (int-to-string 35))  
     =>2  
  
(length (int-to-string 100))  
    =>3  
  
除此之外，在每一个坐标中，每一个数后面必须加上一个像破折号“-”这样的字  
符串，我们将这个字符串称为 Y-axis-tic 标记。这个变量用 defvar 定义：  
  
(defvar Y-axis-tic " - "  
  "String that follows number in a Y axis label.")  
  
Y 轴坐标的长度等于 Y-axis-tic 标记的长度加上图形顶点的高度值的长度之和。  
  
(length (concat (int-to-string height) Y-axis-tic)))  
  
这个值将由 print-graph 函数在它的变量列表中计算出来，并存放在  
full-Y-label-width 变量中，供其他函数使用(注意当初并没有想到要在变量列表  
中包括这个值)。  
  
要打印一个完整的垂直坐标轴的坐标，就要打印一个数字、一个标记，以及这两  
者之前可能还要根据数字的长度加上一个或者更多的空格。因此坐标包含三个部  
分：(可选的)空格、数字和标记符号。有这样几个参量传递给这个函数：特定行  
的数值，最高一行的宽度值(这是由 print-graph 函数计算的)。  
  
      (defun Y-axis-element (number full-Y-label-width)  
       "Construct a NUMBERed label element.  
     A numbered element looks like this `  5 - ',  
     and is padded as needed so all line up with  
     the element for the largest number."  
        (let* ((leading-spaces  
               (- full-Y-label-width  
                  (length  
                   (concat (number-to-string number)  
                          Y-axis-tic)))))  
          (concat  
           (make-string leading-spaces ? )  
           (int-to-string number)  
          Y-axis-tic)))  
  
这个 Y-axis-element 函数将前导空格(如果有)、数字和标记符号组合起来构成坐  
标。  
  

----------------------- Page 225-----------------------

前导空格的个数，是这个函数将坐标的实际长度——数字长度与标记符号长度之  
和——从需要的坐标总长度中减去而得到的。  
  
空格是用 make-string 函数插入到字符串中的，这个函数接收两个参量：第一个参  
量告诉你字符串的长度应当是多少，第二个参量就是要插入的符号。这个符号是  
用特殊形式表示的。在这个例子中，就是使用问号后接上一个空格表示的“?”。  
关于这个问题的详细资料可以参见《GNU Emacs Lisp 技术手册》。  
  
int-to-string 函数被用在连接字符串的表达式中，它将一个数字转换成一个字符  
串，这个字符串将与前导空格和坐标标记符号连接起来。  
  
*** C.2.3 创建 Y 坐标轴  
  
前面的函数为构造一个特殊函数提供了全部工具，这个特殊函数的作用是为 Y 坐标  
轴产生带有数字、空格和标记符号的坐标。  
  
      (defun Y-axis-column (height width-of-label)  
       "Construct list of Y axis labels and blank strings.  
     For HEIGHT of line above base and WIDTH-OF-LABEL."  
        (let (Y-axis)  
          (while (> height 1)  
            (if (zerop (% height Y-axis-label-spacing))  
                ;; Insert label.  
                (setq Y-axis  
                      (cons  
                       (Y-axis-element height width-of-label)  
                      Y-axis))  
              ;; Else, insert blanks.  
              (setq Y-axis  
                    (cons  
                     (make-string width-of-label ? )  
                    Y-axis)))  
            (setq height (1- height)))  
          ;; Insert base line.  
          (setq Y-axis  
                (cons (Y-axis-element 1 width-of-label) Y-axis))  
          (nreverse Y-axis)))  
  
在这个函数中，从 height 变量的值开始，反复地减去 1。每减去一次，测试这个值  
是否是 Y-axis-label-spacing 的整数倍。如果是，就用 Y-axis-element 函数构造  
一个带数字的坐标；如果不是，就用 make-string 函数构造一个空白坐标。基线是  
由一个数字和一个坐标标记符号组成的。  
  
*** C.2.4 print-Y-axis 函数的最后形式  

----------------------- Page 226-----------------------

  
由 Y-axis-column 函数构造的列表，被传递到 print-Y-axis 函数，后面这个函数将  
一个列表作为一列插入到缓冲区中：  
  
      (defun print-Y-axis  
         (height full-Y-label-width)  
       "Insert Y axis using HEIGHT and FULL-Y-LABEL-WIDTH.  
     Height must be the maximum height of the graph.  
     Full width is the width of the highest label element.  
     Optionally, print according to VERTICAL-STEP."  
      ;; Value of height and full-Y-label-width  
      ;; are passed by `print-graph'.  
        (let ((start (point)))  
          (insert-rectangle  
           (Y-axis-column height full-Y-label-width))  
          ;; Place point ready for inserting graph.  
          (goto-char start)  
          ;; Move point forward by value of full-Y-label-width  
          (forward-char full-Y-label-width)))  
  
print-Y-axis 函数使用 insert-rectangle 函数在一个缓冲区中插入 Y 轴坐标，而这  
个 Y 轴坐标是由 Y-axis-column 函数创建的。除此之外，它随后将位点置于正确的  
位置以便打印图形本身。  
  
可以测试 print-Y-axis:  
  
1) 安装  
  
          Y-axis-label-spacing  
          Y-axis-tic  
          Y-axis-element  
          Y-axis-column  
          print-Y-axis  
  
2) 拷贝下面的表达式：  
   
(print-Y-axis 12 5)  
  
3) 切换到“*scratch*”缓冲区，并将光标置于需要开始打印坐标的位置。  
  
4) 键入 M-: (eval-expression)  
  
5) 键入 C-y (yank)以使表达式(print-Y-axis 12 5)插入到小缓冲区中。  
  

----------------------- Page 227-----------------------

6) 按 RET 键（回车键）对这个表达式求值。  
  
Emacs 将垂直地打印 Y 坐标轴，最上面的一个坐标是“10-”(print-graph 函数将传  
递 height-of-top-line 的值，在这个例子中是 15)。  
  
 【实际上，print-Y-axis 函数和 Y-axis-column 函数在下面还会改进。而原译文中  
此处给出的是 print-Y-axis 函数的最终代码，在此处并不能运行。——Chiron 注】  
  
** C.3 print-X-axis 函数  
  
X 坐标轴的坐标与 Y 坐标轴类似，不同的只是其坐标标记在数字上方，像下面这个样子：  
  
          |   |    |    |  
         1   5   10   15  
  
第一个坐标标记符号在图形第一列的下方，这个标记符号前面有一些空格。这些  
空格是为了打印 Y 轴坐标而产生的。第二、第三和第四个标记符号是等距排列的，  
其间隔根据 X-axis-label-spacing 变量的值确定。  
  
X 轴的第二行是坐标值，第一个数值之前也有空格，各个数值之间的间隔根据  
X-axis-label-spacing 变量的值确定。  
  
变量 X-axis-label-spacing 的值应当以 symbol-width 为单位计算，因为你可能要  
改变图形符号的宽度，而不想改变坐标的形式。  
  
print-X-axis 函数与 print-Y-axis 函数多少有些相似之处，只是它需要打印两  
行：一行是坐标标记符号，一行是坐标值。因此将为这两行分别编写函数来打印  
它们，然后将它们组合在 print-X-axis 函数中。  
  
这个过程分为三步：  
  
1) 编写一个打印 X 轴坐标标记符号的函数：print-X-axis-tic-line。  
  
2) 编写一个打印 X 轴坐标值的函数：print-X-axis-numbered-line。  
  
3) 编写一个名为 print-X-axis 的函数来打印这两行，这个函数使用  
   print-X-axis-tic-line 和 print-X-axis-numbered-line 函数。  
  
X 轴标记符号  
  
第一个函数应当打印 X 轴的标记符号。必须定义这个标记符号以及它们之间的间距：  
  
      (defvar X-axis-label-spacing  
        (if (boundp 'graph-blank)  

----------------------- Page 228-----------------------

            (* 5 (length graph-blank)) 5)  
       "Number of units from one X axis label to next.")  
  
(注意，graph-blank 变量的值是由另外一个变量定义表达式 defvar 定义的。  
boundp 预先检查 graph-blank 变量是否已经设置了初始值；如果没有设置初始值，  
则 boundp 返回 nil。如果 gragh-blank 变量已经取消了绑定，而又没有使用这个条  
件表达式，将接收到一个出错消息："symbol's value as variable is void"。)  
  
(defvar X-axis-tic-symbol  "|"  
"String to insert to point to a column in X axis.")  
  
定义这个变量是为了打印出如下标记：  
  
               |    |    |    |  
  
第一个坐标标记符号是缩进的，因此它位于图形的第一列之下，之所以要缩进是  
为了留出空间打印 Y 轴坐标。  
  
一个 X 轴标记符号元素包含从一个标记符号到另外一个标记符号之间的空格以及这  
个标记符号本身。空格的数目由标记符号本身的宽度和 X-axis-label-spacing 的  
值决定。  
  
这部分的代码就是：  
  
      ;;; X-axis-tic-element  
     ...  
      (concat  
       (make-string  
        ;; Make a string of blanks.  
        (-   (* symbol-width X-axis-label-spacing)  
            (length X-axis-tic-symbol))  
       ? )  
       ;; Concatenate blanks with tic symbol.  
      X-axis-tic-symbol)  
     ...  
  
随后，需要确定第一个标记符号之前需要缩进多少，以确定最初的空格数。这要  
使用由 print-graph 函数传递来的 full-Y-label-width 变量的值。  
  
设置 X-axis-leading-spacing 变量(缩进空格数)的值的代码是：  
  
      ;; X-axis-leading-spaces  
     ...  
      (make-string full-Y-label-width ? )  

----------------------- Page 229-----------------------

     ...  
  
同时也需要确定水平坐标轴的长度(即数字列表的长度)，以及在水平坐标轴上打  
印的坐标标记的个数：  
  
      ;; X-length  
     ...  
      (length numbers-list)  
  
      ;; tic-width  
     ...  
      (* symbol-width X-axis-label-spacing)  
  
      ;; number-of-X-ticks  
      (if (zerop (% (X-length tic-width)))  
          (/ (X-length tic-width))  
        (1+ (/ (X-length tic-width))))  
  
有了上面这部分代码，就可以直接写出用于打印 X 轴标记符号行的函数：  
  
      (defun print-X-axis-tic-line  
        (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)  
       "Print ticks for X axis."  
          (insert X-axis-leading-spaces)  
          (insert X-axis-tic-symbol)  ; Under first column.  
          ;; Insert second tic in the right spot.  
          (insert (concat  
                   (make-string  
                    (-   (* symbol-width X-axis-label-spacing)  
                        ;; Insert white space up to second tic symbol.  
                        (* 2 (length X-axis-tic-symbol)))  
                   ? )  
                  X-axis-tic-symbol))  
          ;; Insert remaining ticks.  
          (while (> number-of-X-tics 1)  
            (insert X-axis-tic-element)  
            (setq number-of-X-tics (1- number-of-X-tics))))  
  
打印坐标数字行的函数也很直接、简单：  
  
首先，创建数字元素，每一个元素都是由一个数字加上其前导空格组成：  
  
      (defun X-axis-element (number)  
       "Construct a numbered X axis element."  

----------------------- Page 230-----------------------

        (let ((leading-spaces  
               (-   (* symbol-width X-axis-label-spacing)  
                   (length (number-to-string number)))))  
          (concat (make-string leading-spaces ? )  
                  (number-to-string number))))  
  
接下来，创建打印坐标数字行的函数，在图形第一列的下面打印坐标"1":  
  
      (defun print-X-axis-numbered-line  
        (number-of-X-tics X-axis-leading-spaces)  
       "Print line of X-axis numbers"  
        (let ((number X-axis-label-spacing))  
          (insert X-axis-leading-spaces)  
          (insert "1")  
          (insert (concat  
                   (make-string  
                    ;; Insert white space up to next number.  
                    (-   (* symbol-width X-axis-label-spacing) 2)  
                   ? )  
                   (number-to-string number)))  
          ;; Insert remaining numbers.  
          (setq number (+ number X-axis-label-spacing))  
          (while (> number-of-X-tics 1)  
            (insert (X-axis-element number))  
            (setq number (+ number X-axis-label-spacing))  
            (setq number-of-X-tics (1- number-of-X-tics)))))  
  
最后，要编写 print-X-axis 函数，这个函数使用 print-X-axis-tic-line 函数和  
print-X-axis-numbered-line 函数。  
  
这个函数必须确定由 print-X-axis-tic-line 函数和  
print-X-axis-numbered-line 函数使用的局部变量的值，然后还必须调用这两个  
函数。同样，这个函数还要在这两行之间输出一个换行符，以分隔这两行的内容。  
  
这个 print-X-axis 函数由一个定义了 5 个局部变量的变量列表以及对上面这两个函  
数的调用组成。  
  
      (defun print-X-axis (numbers-list)  
       "Print X axis labels to length of NUMBERS-LIST."  
        (let* ((leading-spaces  
                (make-string full-Y-label-width ? ))  
             ;; symbol-width is provided by graph-body-print  
             (tic-width (* symbol-width X-axis-label-spacing))  
             (X-length (length numbers-list))  

----------------------- Page 231-----------------------

             (X-tic  
              (concat  
               (make-string  
                ;; Make a string of blanks.  
                (-   (* symbol-width X-axis-label-spacing)  
                    (length X-axis-tic-symbol))  
               ? )  
               ;; Concatenate blanks with tic symbol.  
              X-axis-tic-symbol))  
             (tic-number  
              (if (zerop (% X-length tic-width))  
                  (/ X-length tic-width)  
                (1+ (/ X-length tic-width)))))  
          (print-X-axis-tic-line tic-number leading-spaces X-tic)  
          (insert "\n")  
          (print-X-axis-numbered-line tic-number leading-spaces)))  
  
可以这样测试 print-X-axis 函数：  
  
1) 安装 X-axis-tic-symbol、X-axis-label-spacing、print-X-axis-tic-line 以  
   及 X-axis-element、print-X-axis-numbered-line 和 print-X-axis。  
  
2) 复制下面的表达式：  
  
           (progn  
            (let ((full-Y-label-width 5)  
                  (symbol-width 1))  
              (print-X-axis  
              '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))))  
  
3) 切换到“*scratch*”缓冲区，将光标置于要绘制坐标轴的开始处。  
  
4) 键入 M-: (eval-expression)。  
  
5) 用 C-y (yank)命令将测试表达式粘贴到小缓冲区。  
  
6) 键入 RET 键来对这个表达式求值。  
  
Emacs 将打印下面这样的水平坐标轴：  
  
           |   |    |    |    |  
          1   5   10   15   20  
  
** C.4 打印整个图形  

----------------------- Page 232-----------------------

  
现在已经准备好打印整个图形。  
  
用于打印图形以及正确的坐标的函数遵循在本附录前面已提出的框架结构，但是  
还有一些增加的内容。  
  
下面就是这个函数的具体结构：  
  
      (defun print-graph (numbers-list)  
       "DOCUMENTATION..."  
        (let ((height  ...  
             ...))  
          (print-Y-axis height ... )  
          (graph-body-print numbers-list)  
          (print-X-axis ... )))  
  
这个函数的最终结构与计划的结构有两点不同之处：第一，它包含一些在变量列  
表中计算的变量值；第二，它有一个可选的参量来定义每一坐标的增量。后面这  
一点是必须的，否则有些图形可能有太多的行以至于无法在一张纸或者在一个屏  
幕上显示打印出来。  
  
这个新特征需要对 Y-axis-column 函数作一点改变，增加 vertical-step 函数到其  
中。Y-axis-column 函数最终就是：  
  
      ;;; Final version.  
      (defun Y-axis-column  
        (height width-of-label &optional vertical-step)  
       "Construct list of labels for Y axis.  
     HEIGHT is maximum height of graph.  
     WIDTH-OF-LABEL is maximum width of label.  
     VERTICAL-STEP, an option, is a positive integer  
     that specifies how much a Y axis label increments  
     for each line.  For example, a step of 5 means  
     that each line is five units of the graph."  
        (let (Y-axis  
              (number-per-line (or vertical-step 1)))  
          (while (> height 1)  
            (if (zerop (% height Y-axis-label-spacing))  
                ;; Insert label.  
                (setq Y-axis  
                      (cons  
                       (Y-axis-element  
                        (* height number-per-line)  
                       width-of-label)  

----------------------- Page 233-----------------------

                      Y-axis))  
              ;; Else, insert blanks.  
              (setq Y-axis  
                    (cons  
                     (make-string width-of-label ? )  
                    Y-axis)))  
            (setq height (1- height)))  
          ;; Insert base line.  
          (setq Y-axis (cons (Y-axis-element  
                              (or vertical-step 1)  
                             width-of-label)  
                            Y-axis))  
          (nreverse Y-axis)))  
  
相应的，print-Y-axis 函数修改为：  
  
      (defun print-Y-axis  
         (height full-Y-label-width &optional vertical-step)  
       "Insert Y axis using HEIGHT and FULL-Y-LABEL-WIDTH.  
     Height must be the maximum height of the graph.  
     Full width is the width of the highest label element.  
     Optionally, print according to VERTICAL-STEP."  
      ;; Value of height and full-Y-label-width  
      ;; are passed by `print-graph'.  
        (let ((start (point)))  
          (insert-rectangle  
           (Y-axis-column height full-Y-label-width vertical-step))  
          ;; Place point ready for inserting graph.  
          (goto-char start)  
          ;; Move point forward by value of full-Y-label-width  
          (forward-char full-Y-label-width)))  
  
  
图形的最大高度值和打印图形用的符号的宽度，由 print-graph 函数在它的 let 表  
达式中计算出来，因此 graph-body-print 函数必须作些改变以接收这两个值。  
  
      ;;; Final version.  
      (defun graph-body-print (numbers-list height symbol-width)  
       "Print a bar graph of the NUMBERS-LIST.  
     The numbers-list consists of the Y-axis values.  
     HEIGHT is maximum height of graph.  
     SYMBOL-WIDTH is number of each column."  
        (let (from-position)  
          (while numbers-list  

----------------------- Page 234-----------------------

            (setq from-position (point))  
            (insert-rectangle  
             (column-of-graph height (car numbers-list)))  
            (goto-char from-position)  
            (forward-char symbol-width)  
            ;; Draw graph column by column.  
            (sit-for 0)  
            (setq numbers-list (cdr numbers-list)))  
          ;; Place point for X axis labels.  
          (forward-line height)  
          (insert "\n")))  
  
最后，print-graph 函数的代码是：  
  
      ;;; Final version.  
      (defun print-graph  
        (numbers-list &optional vertical-step)  
       "Print labelled bar graph of the NUMBERS-LIST.  
     The numbers-list consists of the Y-axis values.  
  
     Optionally, VERTICAL-STEP, a positive integer,  
     specifies how much a Y axis label increments for  
     each line.  For example, a step of 5 means that  
     each row is five units."  
        (let* ((symbol-width (length graph-blank))  
               ;; `height' is both the largest number  
               ;; and the number with the most digits.  
               (height (apply 'max numbers-list))  
               (height-of-top-line  
                (if (zerop (% height Y-axis-label-spacing))  
                   height  
                  ;; else  
                  (* (1+ (/ height Y-axis-label-spacing))  
                    Y-axis-label-spacing)))  
               (vertical-step (or vertical-step 1))  
               (full-Y-label-width  
                (length  
                 (concat  
                  (number-to-string  
                   (* height-of-top-line vertical-step))  
                 Y-axis-tic))))  
  
          (print-Y-axis  
          height-of-top-line full-Y-label-width vertical-step)  

----------------------- Page 235-----------------------

          (graph-body-print  
          numbers-list height-of-top-line symbol-width)  
          (print-X-axis numbers-list)))  
  
*** C.4.1 测试 print-graph 函数  
  
可以用一个数字列表来测试 print-graph 函数：  
  
1) 安装最终版本的 Y-axis-column、print-Y-axis、graph-body-print 和  
   print-graph 函数(以及其他另外的代码，比如第十五章的 column-of-graph 函  
   数)。  
  
2) 拷贝下面的表达式：  
  
(print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1))  
  
3) 切换到“*scratch*”缓冲区，将光标置于要绘制坐标轴的开始处。  
  
4) 键入 M-:(eval-expression)。  
  
5) 用 C-y (yank)命令将测试表达式粘贴到小缓冲区。  
  
6) 键入 RET 键来对这个表达式求值。  
  
经过以上几步，Emacs 将打印出下面这样的带坐标的图形来。  
  
     10 -  
  
  
              *  
             **   *  
      5 -   ****  *  
            **** ***  
          * *********  
          ************  
      1 - *************  
  
           |   |    |    |  
          1   5   10   15  
  
在另一方面，如果给这个 print-graph 函数传递一个 vertical-step 的值为 2 的参  
量，对下面的表达式求值：  
  
(print-graph '(3 2 6 6 7 5 3 4 6 4 3 2 1) 2)  

----------------------- Page 236-----------------------

  
就会得到下面的这个图形：  
  
(问题：垂直坐标轴的底端上显示的“2”是一个 bug 吗？如果你认为它是一个  
bug，并认为应当在这个位置打印"1"(甚至是"0")，你可以修改函数代码。)  
  
  
     20 -  
  
  
              *  
             **   *  
     10 -   ****  *  
            **** ***  
          * *********  
          ************  
      2 - *************  
  
           |   |     |    |  
          1   5   10   15  
  
*** C.4.2 绘制函数中单词和符号数的图形  
  
现在是打印函数定义中单词和符号数的出现次数的时候了：这个图形显示有多少  
函数定义中有少于 10 个单词和符号，有多少函数定义中有 10~19 个单词和符号，有  
多少函数定义中有 20~29 个单词和符号，等等。  
  
这是一个多步骤的过程。首先要确保已经加载了所有需要的代码。  
  
如果已经设置过 top-of-ranges 变量的值，最好是重新设置 top-of-ranges 的值。  
这只要对下面的表达式求值就行了：  
  
      (setq top-of-ranges  
      '(10  20  30  40  50  
        60  70  80  90 100  
       110 120 130 140 150  
       160 170 180 190 200  
       210 220 230 240 250  
       260 270 280 290 300))  
  
然后，创建一个有关每一段中单词和符号的个数的列表。  
  
对下面的表达式求值：  
  

----------------------- Page 237-----------------------

      (setq list-for-graph  
             (defuns-per-range  
               (sort  
                (recursive-lengths-list-many-files  
                 (directory-files "/usr/local/emacs/lisp"  
                                 t ".+el$"))  
               '<)  
              top-of-ranges))  
  
在我的计算机中，这个计算过程需要大约一个小时。它检查我计算机中 19.23 版的  
Emacs 的所有 303 个 Lisp 文件。经过这个计算之后，list-for-graph 的值是：  
  
      (537 1027 955 785 594 483 349 292 224 199 166 120 116 99  
     90 80 67 48 52 45 41 33 28 26 25 20 12 28 11 13 220)  
  
从这个列表看出：在我机器中的 Emacs 有 537 个函数定义只有少于 10 个单词和符  
号；有 1027 个函数定义有 10~19 个单词和符号；有 955 个函数定义有 20~29 个单词或  
符号，等等。  
  
很明显，仅仅看一看这个列表，也可以看出大多数函数定义包含 10~30 个单词和符  
号。  
  
现在就可以将它们以图形的方式打印出来。在此不需要打印一个高度是 1030 行的  
图形，相反应当打印一个小于 25 行的图形。这个高度的图形能够在几乎所有的终  
端上显示，并可以方便地打印到纸上。  
  
这意味着 list-of-graph 列表中的每一个值必须缩小 50 倍。  
  
下面就是一个完成这个任务的简短的函数，它使用了两个我们没有用过的函  
数：mapcar 和 lambda。  
  
      (defun one-fiftieth (full-range)  
       "Return list, each number one-fiftieth of previous."  
       (mapcar '(lambda (arg) (/ arg 50)) full-range))  
  
1. lambda 表达式  
  
lambda 是一个匿名函数的符号，匿名函数就是没有函数名的函数。每当使用一个  
匿名函数，都必须将它的整个函数定义包含在内。  
  
因此，  
  
(lambda (arg) (/ arg 50))  
  

----------------------- Page 238-----------------------

这个函数定义就是说：“返回 arg 除以 50 的结果”。  
  
例如，在前面，有一个称为 multiply-by-seven 的函数，这个函数将它的参量乘以  
7。这个匿名函数与之相似，只是它将参量除以 50。而且这个函数没有函数名。  
multiply-by-seven 函数对应的匿名函数是：  
  
(lambda (number) (* 7 number))  
  
(参见 3.1 节，"defun 特殊表”。)  
  
如果要将 3 乘以 7，可以这样编写代码：  
  
      (multiply-by-seven 3)  
      \_______________/ ^  
               |         |  
           function  argument  
  
  
这个表达式返回 21。  
  
类似地，可以这样做：  
  
      ((lambda (number) (* 7 number)) 3)  
      \____________________________/ ^  
                     |                |  
           anonymous function     argument  
  
  
如果我们要将 100 除以 50，可以这样编写表达式：  
  
      ((lambda (arg) (/ arg 50)) 100)  
      \______________________/  \_/  
                   |              |  
         anonymous function   argument  
  
  
这个表达式返回 2。100 被传递给这个匿名函数，这个匿名函数将其参量除以 50。  
  
关于 lambda 的更多的内容，可以参见《GNU Emacs Lisp 技术手册》中的“lambda 表达式”  
一节。Lisp 和 lambda 表达式都是从 lambda 演算中演化出来的。  
  
2.mapcar 函数  
  
mapcar 是一个这样的函数，它依次用其第二个参量中的每一个元素调用第一个参  

----------------------- Page 239-----------------------

量。第二个参量必须是一个列表。  
  
例如，  
  
(mapcar '1+ '(2 4 6))  
    =>(3 5 7)  
  
函数 1+将其参量加 1，在上面这个例子中，1+函数作用在作为 mapcar 的第二个参量  
的列表的每一个元素上，并产生一个新的列表。  
  
与这个函数形成对照的是，apply 函数将其第一个参量作用在其余参量上。(参见  
第 15 章“准备柱型图”中关于 apply 的说明。)  
  
在除以 50 的函数(one-fiftieth)中，第一个元素是匿名函数：  
  
(lambda (arg) (/ arg 50))  
  
而第二个参量是 full-range 变量，这个变量将被绑定到 list-for-graph。  
  
因此整个表达式就是：  
  
(mapcar '(lambda (arg) (/ arg 50)) full-range))  
  
关于 mapcar 函数更详细的说明，可以参见《GNU Emacs Lisp 技术手册》中的“映  
射函数”一节。  
  
使用 one-fiftieth 函数，可以产生一个其中每一个元素都是 list-for-graph 列表  
中相应元素的 1/50 的列表。  
  
(setq fiftieth-list-for-graph  
       (one-fiftieth list-for-graph))  
  
最后的列表就是：  
  
(10 20 19 15 11 9 6 5 4 3 3 2 2  
 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 4)  
  
这个列表几乎就是要打印的列表了！(我们同样注意到，在这个列表中丢失了一些  
信息：许多是 0，这些 0 意味着少于 50 个单词或符号的函数定义，而不一定意味着  
没有单词或符号的函数定义。)  
  
3． 暗藏的另一个 bug  
  
在上面已经说过“这个列表几乎就是要打印的列表了！”。当然，在  

----------------------- Page 240-----------------------

print-graph 函数中有一个 bug。这个函数有一个可选的参量 vertical-step，但是  
没有 horizontal-step 参量。而且列表 top-of-range 中的元素从 10 到 300，每一个  
元素之间的间隔是 10。但是 print-graph 函数将只会每隔 1 打印一列。  
  
这是一个暗藏的 bug 的典型例子，这个 bug 被忽略了。这不是那种你只阅读代码就  
可以发现的 bug，因为它并不在代码之中，它是一个忽略了的特性。最好的办法就  
是尽可能早地、尽可能多地测试你的代码。并尽可能地编写易于理解、易于修改  
的代码。要尽可能地时刻提醒自己，代码总是要重新编写的。这是一个不错的格  
言。  
  
在这个例子中，print-X-axis-numbered-line 函数需要重新编写，然后  
print-x-axis 和 print-graph 函数也需要修改。但这并不需要作很多的改变。其中  
一个细节是：X 轴坐标值需要与坐标标记符号一一对齐。这需要好好思考一下。  
  
下面是修改后的 print-X-axis-numbered-line 函数：  
  
      (defun print-X-axis-numbered-line  
        (number-of-X-tics X-axis-leading-spaces  
        &optional horizontal-step)  
       "Print line of X-axis numbers"  
        (let ((number X-axis-label-spacing)  
              (horizontal-step (or horizontal-step 1)))  
          (insert X-axis-leading-spaces)  
          ;; Delete extra leading spaces.  
          (delete-char  
           (-  (1-  
               (length (number-to-string horizontal-step)))))  
          (insert (concat  
                   (make-string  
                    ;; Insert white space.  
                    (-   (* symbol-width  
                          X-axis-label-spacing)  
                        (1-  
                         (length  
                          (number-to-string horizontal-step)))  
                       2)  
                   ? )  
                   (number-to-string  
                    (* number horizontal-step))))  
          ;; Insert remaining numbers.  
          (setq number (+ number X-axis-label-spacing))  
          (while (> number-of-X-tics 1)  
            (insert (X-axis-element  
                     (* number horizontal-step)))  

----------------------- Page 241-----------------------

            (setq number (+ number X-axis-label-spacing))  
            (setq number-of-X-tics (1- number-of-X-tics)))))  
  
如果你是在 Info 中阅读这份文档的，你可以看到 print-X-axis 和 print-graph 函数  
的新的版本，并可以对它们求值。如果你是在阅读一本打印出来的书，就可以在  
这里看到这些函数的改变的部分(全部文本太长，以至无法全部打印出来)。  
  
      (defun print-X-axis (numbers-list horizontal-step)  
       "Print X axis labels to length of NUMBERS-LIST.  
     Optionally, HORIZONTAL-STEP, a positive integer,  
     specifies how much an X  axis label increments for  
     each column."  
      ;; Value of symbol-width and full-Y-label-width  
      ;; are passed by `print-graph'.  
        (let* ((leading-spaces  
                (make-string full-Y-label-width ? ))  
             ;; symbol-width is provided by graph-body-print  
             (tic-width (* symbol-width X-axis-label-spacing))  
             (X-length (length numbers-list))  
             (X-tic  
              (concat  
               (make-string  
                ;; Make a string of blanks.  
                (-   (* symbol-width X-axis-label-spacing)  
                    (length X-axis-tic-symbol))  
               ? )  
               ;; Concatenate blanks with tic symbol.  
              X-axis-tic-symbol))  
             (tic-number  
              (if (zerop (% X-length tic-width))  
                  (/ X-length tic-width)  
                (1+ (/ X-length tic-width)))))  
  
          (print-X-axis-tic-line  
          tic-number leading-spaces X-tic)  
          (insert "\n")  
          (print-X-axis-numbered-line  
          tic-number leading-spaces horizontal-step)))  
  
      (defun print-graph  
        (numbers-list &optional vertical-step horizontal-step)  
       "Print labelled bar graph of the NUMBERS-LIST.  
     The numbers-list consists of the Y-axis values.  
  

----------------------- Page 242-----------------------

     Optionally, VERTICAL-STEP, a positive integer,  
     specifies how much a Y axis label increments for  
     each line.  For example, a step of 5 means that  
     each row is five units.  
  
     Optionally, HORIZONTAL-STEP, a positive integer,  
     specifies how much an X  axis label increments for  
     each column."  
        (let* ((symbol-width (length graph-blank))  
               ;; `height' is both the largest number  
               ;; and the number with the most digits.  
               (height (apply 'max numbers-list))  
               (height-of-top-line  
                (if (zerop (% height Y-axis-label-spacing))  
                   height  
                  ;; else  
                  (* (1+ (/ height Y-axis-label-spacing))  
                    Y-axis-label-spacing)))  
               (vertical-step (or vertical-step 1))  
               (full-Y-label-width  
                (length  
                 (concat  
                  (number-to-string  
                   (* height-of-top-line vertical-step))  
                 Y-axis-tic))))  
          (print-Y-axis  
          height-of-top-line full-Y-label-width vertical-step)  
          (graph-body-print  
             numbers-list height-of-top-line symbol-width)  
          (print-X-axis numbers-list horizontal-step)))  
  
*** C.4.3 打印出来的圈形  
  
作了上述修改并安装这些函数之后，可以这样调用 print-graph 函数：  
  
(print-graph fiftieth-list-for-graph 50 10)  
  
下面就是打印出来的结果：  
  
  
     1000 -  *  
             **  
             **  
             **  

----------------------- Page 243-----------------------

             **  
      750 -  ***  
             ***  
             ***  
             ***  
             ****  
      500 - *****  
            ******  
            ******  
            ******  
            *******  
      250 - ********  
            *********                     *  
            ***********                   *  
            *************                 *  
       50 - ***************** *           *  
             |   |    |    |    |    |    |    |  
           10  50  100  150  200  250  300  350  
  
  
  
从图中可以看到，函数定义中单词和符号数最多集中于 10~19 之间。  
  
----------------------------------------------------------------------  
  
Chiron 注：在我的 Emacs 23.2 版中数据如下：  
  
  (setq list-for-graph  
             (defuns-per-range  
               (sort  
                (lengths-list-many-files  
                 (directory-files "D:/lispbox-0.7/emacs-23.2/lisp"  
                                 t ".+el$"))  
               '<)  
              top-of-ranges))  
  
list-for-graph 的值是：  
  
(348 1185 1315 929 800 631 504 417 345 303 259 215 185 150 120 109 113  
84 93 86 61 47 51 52 48 51 27 27 36 20 401)  
  
整个求值过程耗时不到 1 分钟。  
  
使用的是 lengths-list-many-files 函数，而不是递归版本  

----------------------- Page 244-----------------------

recursive-lengths-list-many-files。  
  
经过  
  
(setq fiftieth-list-for-graph  
       (one-fiftieth list-for-graph))  
  
fiftieth-list-for-graph 值是：  
  
(6 23 26 18 16 12 10 8 6 6 5 4 3 3 2 2 2 1 1 1 1 0 1 1 0 1 0 0 0 0 8)  
  
最终  
  
对  (print-graph fiftieth-list-for-graph 50 10) 求值，打印出来的结果：  
  
  
 1500 -                                  
                                         
                                         
                                         
         *                              
1250 -   *                              
         *                              
        **                              
        **                              
        **                              
1000 -  **                              
        **                              
        ***                             
        ***                             
        ****                            
 750 -  ****                            
        ****                            
        ****                            
        *****                           
        *****                           
 500 -  ******                          
        ******                          
        *******                      *  
        *******                      *  
       **********                    *  
 250 - ***********                   *  
       ************                  *  
       **************                *  

----------------------- Page 245-----------------------

       *****************             *  
  50 - ********************* ** *    *  
        |   |    |    |    |    |    |    |  
        50  100  150  200  250  300  350  
  
----------------------------------------------------------------------  
  
* Footnotes  
  
[fn:1] 这里是指英文版中前面括号中的 3 个单词，即“(and sometimes  
       numbers)”。——译者注  
  
[fn:2] argument 有时也译作“变元”，本书中采用“参量”的译法。——译者注  
  
[fn:3] 追溯“argument”一词有两种不同含义的过程是有意思的，一种来源于数  
       学，一种出自日常用语。按照《牛津英语词典》，“argument”一词来自  
       拉丁语，表示“澄清，证实”；因此，按照这种词源线索，它其有‘提供  
       证据”的含义，即是“提供的信息”，这就是在 Lisp 中引伸出的意义。但  
       是，按其他词源线索，它又表示“某种论断的方式，这种论断可能引起其  
       他相反的断言”，这就是这个词所包含的争论的意思。(注意，这个单词  
       同时具有两个不同的定义。对比之下，在 Emacs Lisp 中，一个符号不能同  
       时具有两个不同的函数定义。)  
  
[fn:4] 注意计数是从 0 开始的。在下例中，字符“T”就是第 0 个数字。——译者注  
  
[fn:5] 实际上，nil 还有第三种意思，表示符号“nil”。  
  
[fn:6] 这里是指英文原书中此处的句子："Thus, if the cursor were at the  
       beginning of this sentence..."。——译者注  
  
[fn:7] 这句话的英文原文是"Sometimes when you you write text, you  
       duplicate words--as with `you you' near the beginning of this  
       sentence."——译者注  
  
  
  
