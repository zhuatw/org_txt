* text glossary
  hybrid
  glossaries, follow me
  font 到选项里设置雅黑小四
  text object
** vim mode
+ Normal
+ Insert
+ last line mode
** notes
   都是前缀，还需要下个命令字符
   d 单独 d 是删除当前行与上一行，前提还要是的再按下移动类的下个命令
d 作用完还在此模式，c 作用完进入插入模式
D 直接删除到行尾，C 是直接删除到行尾并进入插入模式   
y 是复制，p 是粘贴
Y 是复制当前光标到行尾
r 是一次性的替换当前字符，R 是从当前光标进入替换模式向右，直至 esc
 - S 删除本行，且光标到行首进入插入模式
** char
   hjkl
   i 在当前光标前进入插入模式即输入状态
   I 在当前行非空字符的行首输入
   a 在当前光标后进入插入模式即输入状态
   A 在当前行行尾输入
   x 删除当前光标字符
   s 删除当前光标字符，进入插入模式
   X 删除当前光标左边字符
   c-q 在当前光标左侧一次性的输入一个字符
   xp 交换前后两个字符的位置
   ddp 上下两行的位置交换
** wrod 
   中文是以标点来计算的有很多字符也被认为是 word，比如“.”，”-“和“)”等都被
   认为是一个 word，我们可以自由的定义这些 word，这些我们
   到后面讲配置的时候再说。 
   ------------------------------------ 
   c 命令代替 d 命令就表示作用完进入插入模式
   y 命令代替 d 命令就表示 yank，即“复制”。 
   R 替换模式
   -----------------------------------
   d 如果替换成 c 就是作用完后时入插入模式
   w 到下一个单词的首字母上 word 
   3w 则表示向后移动三个单词
   dw 从当前光标计算，删除当前光标到该单词的尾部，并且删除此后的所有空格
   daw 删除当前光标所在的单词，并且删掉此后的所有空格，光标会到下个单词的词首
   diw 只删除当前光标所在的单词，不删空格
   d4w 4dw 是删除四个单词。  
   b 到前一个单词的首字母上 before
   3b 表示向前移动 三个单词
   e 表示向后移动到下一个单词的最后一个字母上，
   ge 则表示向前移动到下一个单词的最后一个字母上。
   d4e 都是可以删除从该光标处向后的四个单词。
   dG 表示删除当前行至行尾的内容
   dgg 表示删除当前行至 文 件头的内容。
   
** line
   注意有逻辑行的区别，都可加数字前缀
   2$则会移动到下一行的行尾, 0 命令和^命令的
   ----------------------------------------
 - J 把下行并到当前行，不论光标在此行的位置
        "J"命令可以是你选择的行全部连接成一行，行与行之间以一个空格代替所有的换行符
        和空白，在连接行的最后放置两个空格。如果想保留行的前导空白和后缀空白，使用
        "gJ"来代替"J"命令。 该命令在三种 visual 模式下均可操作。
 - c-k emacs 删除当前光标到行尾
 - $ 命令将光标移动到当前行的行尾
 - 0 光标移动到当前行的第一个字符上，不能计数
 - ^ 光标移动到当前行的第一个非空白字符上, 是字符串开始的意思
 - G 文档尾，数字加具体行数
 - gg 到第一行 gogogo 的意思，直接到了第一行。可加数字前缀(vim 是:） 
 - D 删除含当前光标到行尾
 - C 删除当前光标到行尾，并进入插入模式
 - dd 删除整行
 - S 删除本行，且光标到行首进入插入模式
   ---------------------------------------- line config
   linum-mode
:set number 来显示行号，:set nonumber 来取消显示行号。
 ** buffer
spc-tab 与最后一个缓冲区来回切换
** Scroll window
M 当前行到前屏幕的中间
H 参数默认为 6，距离屏幕顶的行数，小于 6 不行，要大于 6 才行
L 参数默认为 6，距离屏幕底的行数，小于 6 不行，要大于 6 才行枯
-------------------可加数字前缀，zb 目前不行，zz 加数字前缀好像是调用了 zt
zt 当前行移动屏幕顶端
zz 当前行到当前屏幕的中间，也可说是当前行在屏幕中居中
zb 当前行移动到屏幕底端
------------------------------------
gg 文件开始位置
G 光标移动到当前文件的最后一行的下一行首（自然是行首）
-------------------------------------
可加数字前缀
c-f 向下翻一页，光标不动
c-b 向上翻一页，光标不动
c-d 向下翻半页，光标不动
c-u 向上翻半页，光标不动
** visual
    平常是以当前光标为参照点用命令操纵
    对选中的区域可用字符移动来高亮选中
    + v Characterwise visual mode

    + V Linewise visual mode
        j  命令表示向下再选中一行
        k 命令向上选中一行
    + c-v
        + gv 重新选中前一次可视化时选中的文本
        + o and O 交换选中块当前光标的位置
        + d 删除当前选中的字符，后面的前移到此位置
        + c 删除当前选中的字符，后面不动
        + r 选一个就替一个，选多个就用你输入的替换成多个
 
** find
   f 加上一个字符的命令，这里的 f 表示“find”,比如 fx 表示在当
   前位置向下定位到第一个 x 所在的位置。 
   F 加一个字符表示向左搜索。 
** t be to
是“to”的简写，比如
tx 表示向右寻找第一个 x 所在的位置，但是它不是把光标停留
在被搜索的字符上，而是在它之前的前一个字符上。小写的 t
表示向右搜索，大写的 T 表示向左搜索。 
据了两行的空间，但是在逻辑上它们是一行，因为它们之间不
包括任何的换行符。 
** %
它会自动把光标定位到与之对应的括号的
** 50%
   命令来跳转到文件的中间位置，用 80%命令跳转到文件的百分之八十的位置
** table
s-tab 对齐和向上个单元格
** undo and redo
| 1 | u   | undo-tree-undo | normal| vim   |
| 2 | c-r | undo-tree-redo | normal| vim   |
| 3 | c-_ | undo-tree-undo | normal| emacs |
| 4 | a-_ | undo-tree-redo | normal| emacs |
** help
| Key Binding | 	Description     |
| <SPC> h d f | describe-function |
| <SPC> h d k | describe-key      |
| <SPC> h d m | describe-mode     |
| <SPC> h d v | describe-variable |
** 加一个单词然后在整个文档中搜索这个单词，然后用数字加 n 的组合来定位第几个单词。 
   如果我们想要单纯的只使用该单词比如 xin，那么我们可以用
   命令/\<xin\>来做到，其中\<表示匹配一个单词的开头，而\>
   则表示匹配一个单词的结束。 
   要找到这个 explode，就直接在命令模式下用/explode 就可以了
   ## vim 是支持正则表达式的
   因为正则表达式对于字符串的匹配来说提供了强劲的支持，vim 也自然对搜索有着强劲
   的支持。^字符匹配一行的开头，
   $匹配一行的结尾，
   比如/^the$是匹配一行之中只有 the 这个单词的情况，即我们必须以该单词
   开头又必须以该单词结尾，那这一行除了这个单词连空格都不
   能有。
.匹配到任何字符，比如 x.g 可以匹配 xig，还可以匹配
到 xinxing。 
\ 为转义字符前缀，如果我们想匹配“xin.”，但是“.”的地位有点特殊，我们可
以在其前面加一个反斜线表示转义，比如我们用 xin\.来匹配
xin.这样子。 
5.由于$命令是移动光标到行尾，所以 d$命令就是删除当前光
标到行尾的内容，而且该行的最后一个字符也会被删除。 
## cc and cw and ce and c$
不过它在命令执行后会进入 Insert 模式。
比如 cw 命令会首先删除该 word，并且会立即进入插入模式。 
## dd 命令可以删除整行，而 cc 命令则可以改变整行。 
## x 其实就是 dl，
表示删除当前光标下的字符，
## X 命令则是 dh
表示删除当前光标左边的字符。
## D 表示 d$,表示删除到行尾的内容
## C 表示 c$
 表示修改到行尾的内容
## s 表示 cl，
即修改一个字符，
## S 表示 cc
即修改一整行内容。 
## 对于某些喜欢钻牛角尖的童鞋来说，它发现 4dw 和 d4w 是
一样的，都是删除四个单词，但是 4dw 是对 dw 命令执行了四
次，每次删除一个单词，执行了四次会删除四个单词，而 d4w
则是执行了一次命令，删除了四个单词。比如 4d2w 则是每次
删除两个单词，重复删除 4 次，因此共计删除了八个单词。 
## r 命令则是把当前位置的字符被我们键入的字符所替换，比
如 rx 则是用 x 来替换当前位置的字符，而 5rx 表示从该字符 之
后的五个字符都是用 x 来替换。 
## 而我们用 r 之后按回车键，则会删除一个字符并且插入一个
换行符，
## 而 r4<Enter> 即我们按下 r 键和 4 键之后再按回车，
会把接下来的四个字符替换为一个换行符。 
 
## . 命令
vim 下重复操作很简单，
我们使用.命令。 
输入/a 来找到所有的 a 字符，截图
然后我们用在命令模式下键入 clb，此时我们把这里的 a 换成
了 b，然后我们在用 Esc 键退回到命令模式下： 
 
5.然后我们用 n 命令来找到下一个被查找出的 a 字符，如下截
图：2014 年辛星 vim 教程秋季版 
 
6.然后我们键入一个.然后我们会发现： 
 
7.然后我们多按几次 n 命令和.命令，之后发现： 
## p
命令把它取出来，这里的 p 是 put 的意思，即“拿出，取出”，
如果单纯的为了记忆，理解为 paste 也不错，即“粘贴”，但是
它并不是 vim 的思维模式，是微软党的思维模式。 
3.如果我们删除的一整行的内容，比如使用了 dd 命令，那么 p
命令会把整个文本行都放到光标下面作为单独的一行。如果我
们删除的是一行的部分内容，比如一个 word，那么 p 命令就
会把这部分内容放到当前光标的后面。 
## P
命令（大写的 P）和小写的 p 命令很相似，只是它会把该内
容粘贴到光标字符之前。对于 dd 删除的整行内容，我们用 P
命令会把它放到当前行的上一行，对于 dw 删除的部分内容，P
会把它放到光标之前。 
5.就像一次复制可以多次粘贴一样，我们可以多次重复使用 p
命令。 
6.该命令依然支持命令计数，比如 3p 命令表示把被删除的 3 份
副本放到当前位置。 
7.这里说一个小窍门把：有时候我们会一时打错东西，比如把
the 打成了 teh，那么我们可以在命令模式下用 dlp 或者 xp 来
把 teh 换成 the，dl 和 x 命令都表示删除 e 字符，而 p 会把它粘
贴到 h 字符之后。 
## y
命令，这里的 y 是“yank ”的意思，翻译成汉语即“拉，抽”。
9.其实用 copy 来表示复制更好理解点，但是很可惜 c 命令同时
也是“change ”的第一个字母，该命令用于表示修改，所以也
就没办法用 c 命令表示复制了，只能用 yank 的 y 命令表示复制。  
10.就像我们的 d4w 表示剪切四个 word 一样，我们的 y4 w 表
示复制四个 word。 
11.需要注意的是，y4w 会把 wo rd 之后的空白字符也给复制过
去，如果我们不想复制该空白字符，那么我们可以用 y4e。 
12.就像 dd 表示删除一行一样，我们可以 用 yy 来表示复制一
行，Y 命令也是复制整行的内容，
## y$命令则是复制当前光标
所在位置至行尾的命令。 
** sentence
   das 如果我们想删除一个句子，我们也希望删除它后面的空白， 就用 das，
   cis 如果我们用新的文本替换它，空白是保留下来的
2er 时候我们希望用新输入的文本来代替那些已经存在的文本，
此时就可以在命令模式下输入 R 来进入替换模式。 
*******************小结**************************** 
1.这一节我们的知识点主要分为两大块。 
2.第 一 大块 就是 知 道如 何 移动 光标 ， 比如 左 下上 右地 移 动光 标 ，
比如如何一次移动四个单词这样的移动方式。 
3.第二大块就是知道如何对文本进行操作，比如剪切、赋值、
粘贴、搜索、替换、重复执行命令等一系列操作。 
4.vim 的操作无难度，它是一学就会的，但是想要用起来得心
应手，还是需要大量的练习的，还有就是对各种命令的记忆。 
** file
   + :e
   + spc-f-s  <->  :w
   + :sav
   + :enew
   + :close
   + :wqa
   + :set filetype=php
- :set  background=dark (注：默认的情况下使用的 background 是 light) 
** window
## :split
## :close
## :only
来关闭其他窗口。 
## :split  qian.php
## :vsplit
** tabedit  xin
tabedit 是 tab (标签页)和 edit(编辑)的合写，
** _vimrc
#宏命令_记录与回放
.命令可以重复最近一次的编辑操作，但是，当我们操作很复杂的时候，或
者我们需要重复的操作变多的时候，又该怎么办呢? 
2.强劲的 vim 自然也考虑到了这一点，
在 vim 中我们这么做通
##使用 q{寄存器名}
开始命令，后续的操作会被记录到该寄存器中，这里的寄存器名必须是 a 到 z 之间的
一个字母。第二步，执行我们的那些繁杂的操作。第三步，按
下 q 表示结束对命令的录制。 
3.我们可以通过@{寄存器名}命令来执行刚刚记录下来的宏了。
其实，支持宏的文本编辑器还是有不少的，但是，支持的比
vim 还强大的，倒是没几个。 
8.然后咱们执行命令 3@x,之后效果如下：2014 年辛星 vim 教程秋季版 
 
10.由于我们最多可以定义 a-z 等 26 个字母可用，因此，我们可
以定义最多 26 个宏，这对于简化咱们的操作是很不错的。 
宏，说明一下，这里的”是双引号，这里的 x 是咱们的宏的名字，
如果你并没有用 x 作为宏的名字，那么相应的命令替换为你的
宏名，下面是该宏的截图： 
#:s
命令或者其全称:substitute 命令。 
：s/查找字符/替换字符/[可选的修饰符] 
##可选的修饰符

* 待整理
：g 表示替换该
行所有的符合的目标字符串，
** p 表示列印
** c 表示每次执行替换
的时候都需要请求确认，如果这个地方什么都不写，表示只是
替换第一个匹配到的字符串。 
** s 前面加一个范围参数，比如 1,5 就表示从第一
行开始，到第五行结束，而且它是包括第一行和第五行的。 
** 如果我们只想修改第 4 行的内容，可以
用:4s/in clude/qian /g 这个命令。 
#:g
命令就是传说中的全局命令，它的全称是:global, 意思是
“全局的”，它允许我们找到某个匹配模式的行然后将命令作
用到它上面。 
##:[范围参数]g/{模式}/{可执行的 vim 命令} 
它和我们的:s 命令很像，而且:g 中的所谓的命令都必须以:开
头，而命令模式下的命令不能直接用。 
这里没想到很好的例子，于是就引用点大家还没有学习的命
令把，不用太担心，知道怎么回事就可以了。 
5.下面我们在同一个文件下操作，咱们写如下的 vim 命令： 
主要是宏、查找和替换。 
#替换字符串的细节
1.好像我前面说过了，这里还是再说一下把，那就是我们用:s 来
进行正则替换的时候。如果我们要替换的是一个单词，而不是
特定的某个文 档，那么可 以用 \<来 表示开头， 用 \>来表 示结尾。  
2.比如下面的这段文字以及下面我输入了修改的命令： 
 
3.下面我们会发现所有带有 xing 字符串的东西都被修改了，于
是乎，我们就有了如下凌乱的形式：2014 年辛星 vim 教程秋季版 
4.下面我们只是把“xing”换成“小倩”，而“xinxi ng”则不
予改动，先看命令怎么写： 
#统计信息
1.有时候我们写了长长的一段，比如如下截图： 
 
2.那么我们可以在命令模式下先用 g 命令，然后 Ctrl 加 G 的命
令，统计一下字数，比如我们执行完毕这些命令之后截图： 
#命令行补齐和历史记录
1.由于我表达能力很稀松，所以很多技巧我也不知道如何去表达。 
2.但是 vim 是支持命令行补齐的，这就方便了我们写命令行的
时候的工作量，虽然很多其他编辑器也支持，但是无疑 vim 在
这方便并不差。 
3.比如我们输入了:s，我们移动键盘上的↑(就是向上的箭头的
那个按键),然后会发现如下的截图： 
 
4.继续按几下该键，会发现更多的历史记录被翻出来，我们可
以通过该历史记录来查看过往的操作，更重要的就是重用它们
了，当我们要执行一个类似的操作的时候，只需要重复它就可
以了。 
5.所谓的自动补全就是用 tab 键来补全，比如我们输入:s 的话，
直接按 tab 键，会自动补齐为:sNext 这个命令。 

 2014 年辛星 vim 教程秋季版 
 
 56 / 71 
 
*************viminfo*********************** 
1.很多编辑器都有一个弊病，那就是对连续工作支持地不够，至
少是不够彻底。 
2.比如我在某个时刻进行了某些操作，但是当我关闭该编辑器
之后，发现很多设置就消失的无影无踪了，于是我只能重新去
设置这些东西，这就非常烦了。 
3.再比如我在这个电脑上的一些工作，我把一些文件上传到网
盘里，结果当我在另一台电脑上用同一个软件打开的时候，结
果这两个软件的设置不一样(不同电脑上的统一软件设置不一样
很正常，因为大家的习惯不一样)，这就很让人头疼。 
4.但是自从有了 viminfo，妈妈再也不用担心我的学习了，我们
先把到现在的记录保存到 viminfo 中，看下面命令： 
 
5.然后我们到 E 盘下找到这个文件，看下效果图： 
 
6.然后我们用 vim 打开它，看看效果： 
 
7.我们也可以用 rviminfo 来读取该文件的一些配置信息来使得
我们当前的文件设置正确： 
   
8.对于该 info 文件，我们也可以手动向其中写入信息和设置信
 
9.而该 viminfo 有时候还和 session 一起用来发挥其强大的威力，
下面我们再说。 
 
 
 
#session
1.像我这种搞 web 出身的对 cookie 和 session 是熟的不能再熟
了，对于搞其他行业出身的，我不知道大家对 session 的理解是
什么样的。 
2.有时候我们辛辛苦苦工作了一天，需要去睡觉了，我们明天
接着干，这个时候，我们需要把目前的状态保存起来，这就是
vim 中所用到的 session。 
3.所谓 session，就是一个会话，咱们 vim 中的会话包含咱们编
辑活动的所有信息，包括文件列表、窗口布局、全局变量、选
项和一些杂七杂八的东西。 
4.咱们用:mksession  E:\xinxi ng.vim 来保存该会话文件，看下面
截图： 
session and viminfo
1.它们两个都能保存一些当前的操作信息，但是性质不同。 
2.session 里面会记住一些比如上次的窗口位置、窗口大小、包
括映射和各个 session 选项都是一样的。 
3.viminfo 包括的信息主要包括标记、寄存器和命令历史记录，
这些都是 session 所不会记录的。 
4.我们可以在结束当天工作的时候先使用:mksession，然后使
用:wviminfo，然后在开始新一天的工作的时候先用:sour ce，然
后我们用:rviminfo。 
#文件浏览
1.比如我打开了一个 python 文件，下面我们可以用:edit . 来查
看它所在目录下的文件，值得注意的是，后面的.不能忽略，否
则不是浏览当前目录，而是会显示当前的文件名，如下截图： 
 
3.可能大家也注意到了，每次我写入文件的时候，都是指定了
盘符的绝对路径，那我用相对路径会怎么样呢？ 
4.如果大家使用过 zendstudio 或者 vs studio 之类的，会发现我
们需要设置一个工作目录，没错，vim 也需要设置当前的工作
目录，
##:pwd
来查看当前的工作目录： 
##:cd
来设置当前的工作目录，比如我把下面
的工作目录设置为 D 盘下的 www 子目录
##:find
文件名的方式来查找文件，它是在当前的
工作目录下查找的，比如我在桌面上的 xin.txt 使用:find my.py
命令，效果如下： 
然后我们键入回车的时候，发现截图如下：
#程序员必备知识 
1.有些知识对于程序员特别重要，但是对于那些普通的文本编辑
来说可以忽略甚至是根本无用的知识。 
2.我 们 把这 部分 内 容拿 出 来， 希望 做 一个 稍 微系 统一 点 的总 结。  
##代码折叠
1.我想代码折叠的重要性就不说了，不过由于 vim 过于强大，
支持好多种代码折叠的方式，我们这里只看最简单的通过缩进
来折叠代码的简单情形。 
2.由于我学过的所有语言中认为 python 对于代码缩进是最严格
的，因此咱们就用 Python 代码为例来说明：2014 年辛星 vim 教程秋季版 
3.下面咱们设置一下折叠的方式，命令:set  foldmethod=indent
来设置，看下面截图： 
4.然后我们折叠代码了，我们用 zm 来进行折叠，用 zo 来展开
这个折叠，也可以用 zR 来展开所有的折叠。 
5.比如我们把光标移动到第一个 if 判断语句那里，然后执行 zm
命令来折叠代码，然后到 else 那里折叠一次，效果如下：2014 年辛星 vim 教程秋季版 
##函数声明进行折叠，即执行 zm 命令
下面截图： 
 
7.然后我们可以在该行上用 zo 命令来打开该折叠，我们首先需
要把光标定位到需要展开的层次上去。值得注意的是，当我们
用 zm 来折叠的时候，光标在上层，当我们用 zo 来展开折叠的
时候，光标在折叠成一行的那部分，而不能在它的上面一行代
码处，否则 vim 会找不到折叠层次。下面是我定位到光标的位
置： 
8.之后我们就可以展开折叠代码了，展开之后的效果图： 
9.我们直接用 zR 来展开所有的折叠层次，如下截图： 
10.下面我们再引入一个折叠层次的概念吧，这个折叠层次就是
##foldlevel，它和 foldmethod 一样，也是用:set 命令来设置，
它是一个数字，加入我们设置 foldlevel 为 0 的时候，它就只能显
示一层，剩下的代码就会全部折叠起来。 
11.我们下面直接通过设置 foldlevel 为 0，代码如下： 
 
12.当我们按下回车的那一刻，效果如下： 
13.那么，当我们设置 foldlevel 为 1 的时候，它的情形是这样子
的： 
 
14.不得不说，vim 的折叠太强大了，它可以手工折行、根据缩
进折行、根据标记折行、根据语法折行、根据表达式折行等很
多折行功能。 
15.我的意思是，咱们先掌握一种最基本的折叠代码的方式，然
后其他的慢慢研究，先学习主干知识。 
